import request from "request";
import { Configuration } from "../internal/configuration";
import { addQueryParameterToUrl } from "../internal/requestHelper";
import { ObjectSerializer } from "../internal/objectSerializer";

export class ValueType {

    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return ValueType.attributeTypeMap;
    }

    public constructor(init?: Partial<ValueType>) {        
        Object.assign(this, init);
    }        
}

export class Point {

    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "x",
            baseName: "X",
            type: "number",
        },
        {
            name: "y",
            baseName: "Y",
            type: "number",
        } 
    ];

    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return ValueType.attributeTypeMap;
    }
    public x: number;
    public y: number;
    public constructor(init?: Partial<Point>) {        
        Object.assign(this, init);
    }        
}

/// Class for disc space information.   
export class DiscUsage  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "usedSize",
            baseName: "UsedSize",
            type: "number",
        },
        {
            name: "totalSize",
            baseName: "TotalSize",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DiscUsage.attributeTypeMap;

    }

    public usedSize: number;
    public totalSize: number;

    public constructor(init?: Partial< DiscUsage >) {  
    
        Object.assign(this, init);
    } 
}
/// Object exists   
export class ObjectExist  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "exists",
            baseName: "Exists",
            type: "boolean",
        },
        {
            name: "isFolder",
            baseName: "IsFolder",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ObjectExist.attributeTypeMap;

    }

    public exists: boolean;
    public isFolder: boolean;

    public constructor(init?: Partial< ObjectExist >) {  
    
        Object.assign(this, init);
    } 
}
   
export class ObjectExistsExtensions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ObjectExistsExtensions.attributeTypeMap;

    }


    public constructor(init?: Partial< ObjectExistsExtensions >) {  
    
        Object.assign(this, init);
    } 
}
/// File or folder information   
export class StorageFile  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "isFolder",
            baseName: "IsFolder",
            type: "boolean",
        },
        {
            name: "modifiedDate",
            baseName: "ModifiedDate",
            type: "Date",
        },
        {
            name: "size",
            baseName: "Size",
            type: "number",
        },
        {
            name: "path",
            baseName: "Path",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  StorageFile.attributeTypeMap;

    }

    public name: string;
    public isFolder: boolean;
    public modifiedDate: Date;
    public size: number;
    public path: string;

    public constructor(init?: Partial< StorageFile >) {  
    
        Object.assign(this, init);
    } 
}
   
export class FileVersion  extends StorageFile  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "versionId",
            baseName: "VersionId",
            type: "string",
        },
        {
            name: "isLatest",
            baseName: "IsLatest",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FileVersion.attributeTypeMap) ;

    }

    public versionId: string;
    public isLatest: boolean;

    public constructor(init?: Partial< FileVersion >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Storage exists   
export class StorageExist  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "exists",
            baseName: "Exists",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  StorageExist.attributeTypeMap;

    }

    public exists: boolean;

    public constructor(init?: Partial< StorageExist >) {  
    
        Object.assign(this, init);
    } 
}
/// File versions FileVersion.   
export class FileVersions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "value",
            baseName: "Value",
            type: "Array<FileVersion>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  FileVersions.attributeTypeMap;

    }

    public value: Array<FileVersion>;

    public constructor(init?: Partial< FileVersions >) {  
    
        Object.assign(this, init);
    } 
}
/// Files list   
export class FilesList  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "value",
            baseName: "Value",
            type: "Array<StorageFile>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  FilesList.attributeTypeMap;

    }

    public value: Array<StorageFile>;

    public constructor(init?: Partial< FilesList >) {  
    
        Object.assign(this, init);
    } 
}
/// Error   
export class Error  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Error.attributeTypeMap;

    }


    public constructor(init?: Partial< Error >) {  
    
        Object.assign(this, init);
    } 
}
/// File upload result   
export class FilesUploadResult  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "uploaded",
            baseName: "Uploaded",
            type: "Array<string>",
        },
        {
            name: "errors",
            baseName: "Errors",
            type: "Array<Error>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  FilesUploadResult.attributeTypeMap;

    }

    public uploaded: Array<string>;
    public errors: Array<Error>;

    public constructor(init?: Partial< FilesUploadResult >) {  
    
        Object.assign(this, init);
    } 
}
   
export class GoogleDriveStorageFile  extends StorageFile  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "mimeType",
            baseName: "MimeType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(GoogleDriveStorageFile.attributeTypeMap) ;

    }

    public mimeType: string;

    public constructor(init?: Partial< GoogleDriveStorageFile >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Describe the AboveAverage conditional formatting rule. This conditional formatting
///     rule highlights cells that are above or below the average for all values
///     in the range.   
export class AboveAverage  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "isAboveAverage",
            baseName: "IsAboveAverage",
            type: "boolean",
        },
        {
            name: "isEqualAverage",
            baseName: "IsEqualAverage",
            type: "boolean",
        },
        {
            name: "stdDev",
            baseName: "StdDev",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  AboveAverage.attributeTypeMap;

    }

    public isAboveAverage: boolean;
    public isEqualAverage: boolean;
    public stdDev: number;

    public constructor(init?: Partial< AboveAverage >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents user's custom calculation engine to extend the default calculation engine of Aspose.Cells.
///     
export class AbstractCalculationEngine  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "isParamLiteralRequired",
            baseName: "IsParamLiteralRequired",
            type: "boolean",
        },
        {
            name: "isParamArrayModeRequired",
            baseName: "IsParamArrayModeRequired",
            type: "boolean",
        },
        {
            name: "processBuiltInFunctions",
            baseName: "ProcessBuiltInFunctions",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  AbstractCalculationEngine.attributeTypeMap;

    }

    public isParamLiteralRequired: boolean;
    public isParamArrayModeRequired: boolean;
    public processBuiltInFunctions: boolean;

    public constructor(init?: Partial< AbstractCalculationEngine >) {  
    
        Object.assign(this, init);
    } 
}
/// Monitor for user to track the progress of formula calculation.
///     
export class AbstractCalculationMonitor  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "originalValue",
            baseName: "OriginalValue",
            type: "Object",
        },
        {
            name: "valueChanged",
            baseName: "ValueChanged",
            type: "boolean",
        },
        {
            name: "calculatedValue",
            baseName: "CalculatedValue",
            type: "Object",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  AbstractCalculationMonitor.attributeTypeMap;

    }

    public originalValue: Object;
    public valueChanged: boolean;
    public calculatedValue: Object;

    public constructor(init?: Partial< AbstractCalculationMonitor >) {  
    
        Object.assign(this, init);
    } 
}
   
export class LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "link",
            baseName: "link",
            type: "Link",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  LinkElement.attributeTypeMap;

    }

    public link: Link;

    public constructor(init?: Partial< LinkElement >) {  
    
        Object.assign(this, init);
    } 
}
/// Summary description for DataSorter.   
export class DataSorter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "caseSensitive",
            baseName: "CaseSensitive",
            type: "boolean",
        },
        {
            name: "hasHeaders",
            baseName: "HasHeaders",
            type: "boolean",
        },
        {
            name: "keyList",
            baseName: "KeyList",
            type: "Array<SortKey>",
        },
        {
            name: "sortLeftToRight",
            baseName: "SortLeftToRight",
            type: "boolean",
        },
        {
            name: "sortAsNumber",
            baseName: "SortAsNumber",
            type: "boolean",
        },
        {
            name: "keys",
            baseName: "Keys",
            type: "Array<DataSorterKey>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DataSorter.attributeTypeMap;

    }

    public caseSensitive: boolean;
    public hasHeaders: boolean;
    public keyList: Array<SortKey>;
    public sortLeftToRight: boolean;
    public sortAsNumber: boolean;
    public keys: Array<DataSorterKey>;

    public constructor(init?: Partial< DataSorter >) {  
    
        Object.assign(this, init);
    } 
}
   
export class FilterColumn  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "fieldIndex",
            baseName: "FieldIndex",
            type: "number",
        },
        {
            name: "filterType",
            baseName: "FilterType",
            type: "string",
        },
        {
            name: "multipleFilters",
            baseName: "MultipleFilters",
            type: "MultipleFilters",
        },
        {
            name: "colorFilter",
            baseName: "ColorFilter",
            type: "ColorFilter",
        },
        {
            name: "customFilters",
            baseName: "CustomFilters",
            type: "Array<CustomFilter>",
        },
        {
            name: "dynamicFilter",
            baseName: "DynamicFilter",
            type: "DynamicFilter",
        },
        {
            name: "iconFilter",
            baseName: "IconFilter",
            type: "IconFilter",
        },
        {
            name: "top10Filter",
            baseName: "Top10Filter",
            type: "Top10Filter",
        },
        {
            name: "visibledropdown",
            baseName: "Visibledropdown",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  FilterColumn.attributeTypeMap;

    }

    public fieldIndex: number;
    public filterType: string;
    public multipleFilters: MultipleFilters;
    public colorFilter: ColorFilter;
    public customFilters: Array<CustomFilter>;
    public dynamicFilter: DynamicFilter;
    public iconFilter: IconFilter;
    public top10Filter: Top10Filter;
    public visibledropdown: string;

    public constructor(init?: Partial< FilterColumn >) {  
    
        Object.assign(this, init);
    } 
}
   
export class Link  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "href",
            baseName: "Href",
            type: "string",
        },
        {
            name: "rel",
            baseName: "Rel",
            type: "string",
        },
        {
            name: "title",
            baseName: "Title",
            type: "string",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Link.attributeTypeMap;

    }

    public href: string;
    public rel: string;
    public title: string;
    public type: string;

    public constructor(init?: Partial< Link >) {  
    
        Object.assign(this, init);
    } 
}
   
export class AutoFilter  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "filterColumns",
            baseName: "FilterColumns",
            type: "Array<FilterColumn>",
        },
        {
            name: "range",
            baseName: "Range",
            type: "string",
        },
        {
            name: "sorter",
            baseName: "Sorter",
            type: "DataSorter",
        },
        {
            name: "showFilterButton",
            baseName: "ShowFilterButton",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(AutoFilter.attributeTypeMap) ;

    }

    public filterColumns: Array<FilterColumn>;
    public range: string;
    public sorter: DataSorter;
    public showFilterButton: boolean;

    public constructor(init?: Partial< AutoFilter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class AutoFitterOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoFitMergedCellsType",
            baseName: "AutoFitMergedCellsType",
            type: "string",
        },
        {
            name: "autoFitMergedCells",
            baseName: "AutoFitMergedCells",
            type: "boolean",
        },
        {
            name: "ignoreHidden",
            baseName: "IgnoreHidden",
            type: "boolean",
        },
        {
            name: "onlyAuto",
            baseName: "OnlyAuto",
            type: "boolean",
        },
        {
            name: "defaultEditLanguage",
            baseName: "DefaultEditLanguage",
            type: "string",
        },
        {
            name: "maxRowHeight",
            baseName: "MaxRowHeight",
            type: "number",
        },
        {
            name: "autoFitWrappedTextType",
            baseName: "AutoFitWrappedTextType",
            type: "string",
        },
        {
            name: "formatStrategy",
            baseName: "FormatStrategy",
            type: "string",
        },
        {
            name: "forRendering",
            baseName: "ForRendering",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  AutoFitterOptions.attributeTypeMap;

    }

    public autoFitMergedCellsType: string;
    public autoFitMergedCells: boolean;
    public ignoreHidden: boolean;
    public onlyAuto: boolean;
    public defaultEditLanguage: string;
    public maxRowHeight: number;
    public autoFitWrappedTextType: string;
    public formatStrategy: string;
    public forRendering: boolean;

    public constructor(init?: Partial< AutoFitterOptions >) {  
    
        Object.assign(this, init);
    } 
}
   
export class Color  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "a",
            baseName: "A",
            type: "number",
        },
        {
            name: "r",
            baseName: "R",
            type: "number",
        },
        {
            name: "g",
            baseName: "G",
            type: "number",
        },
        {
            name: "b",
            baseName: "B",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Color.attributeTypeMap;

    }

    public a: number;
    public r: number;
    public g: number;
    public b: number;

    public constructor(init?: Partial< Color >) {  
    
        Object.assign(this, init);
    } 
}
   
export class ThemeColor  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "colorType",
            baseName: "ColorType",
            type: "string",
        },
        {
            name: "tint",
            baseName: "Tint",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ThemeColor.attributeTypeMap;

    }

    public colorType: string;
    public tint: number;

    public constructor(init?: Partial< ThemeColor >) {  
    
        Object.assign(this, init);
    } 
}
   
export class Border  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "lineStyle",
            baseName: "LineStyle",
            type: "string",
        },
        {
            name: "color",
            baseName: "Color",
            type: "Color",
        },
        {
            name: "borderType",
            baseName: "BorderType",
            type: "string",
        },
        {
            name: "themeColor",
            baseName: "ThemeColor",
            type: "ThemeColor",
        },
        {
            name: "argbColor",
            baseName: "ArgbColor",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Border.attributeTypeMap;

    }

    public lineStyle: string;
    public color: Color;
    public borderType: string;
    public themeColor: ThemeColor;
    public argbColor: number;

    public constructor(init?: Partial< Border >) {  
    
        Object.assign(this, init);
    } 
}
   
export class Workbook  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "fileName",
            baseName: "FileName",
            type: "string",
        },
        {
            name: "links",
            baseName: "Links",
            type: "Array<Link>",
        },
        {
            name: "worksheets",
            baseName: "Worksheets",
            type: "LinkElement",
        },
        {
            name: "defaultStyle",
            baseName: "DefaultStyle",
            type: "LinkElement",
        },
        {
            name: "documentProperties",
            baseName: "DocumentProperties",
            type: "LinkElement",
        },
        {
            name: "names",
            baseName: "Names",
            type: "LinkElement",
        },
        {
            name: "settings",
            baseName: "Settings",
            type: "LinkElement",
        },
        {
            name: "isWriteProtected",
            baseName: "IsWriteProtected",
            type: "string",
        },
        {
            name: "isProtected",
            baseName: "IsProtected",
            type: "string",
        },
        {
            name: "isEncryption",
            baseName: "IsEncryption",
            type: "string",
        },
        {
            name: "password",
            baseName: "Password",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Workbook.attributeTypeMap;

    }

    public fileName: string;
    public links: Array<Link>;
    public worksheets: LinkElement;
    public defaultStyle: LinkElement;
    public documentProperties: LinkElement;
    public names: LinkElement;
    public settings: LinkElement;
    public isWriteProtected: string;
    public isProtected: string;
    public isEncryption: string;
    public password: string;

    public constructor(init?: Partial< Workbook >) {  
    
        Object.assign(this, init);
    } 
}
   
export class CalculationOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "calcStackSize",
            baseName: "CalcStackSize",
            type: "number",
        },
        {
            name: "ignoreError",
            baseName: "IgnoreError",
            type: "boolean",
        },
        {
            name: "precisionStrategy",
            baseName: "PrecisionStrategy",
            type: "string",
        },
        {
            name: "recursive",
            baseName: "Recursive",
            type: "boolean",
        },
        {
            name: "customEngine",
            baseName: "CustomEngine",
            type: "AbstractCalculationEngine",
        },
        {
            name: "calculationMonitor",
            baseName: "CalculationMonitor",
            type: "AbstractCalculationMonitor",
        },
        {
            name: "linkedDataSources",
            baseName: "LinkedDataSources",
            type: "Array<Workbook>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CalculationOptions.attributeTypeMap;

    }

    public calcStackSize: number;
    public ignoreError: boolean;
    public precisionStrategy: string;
    public recursive: boolean;
    public customEngine: AbstractCalculationEngine;
    public calculationMonitor: AbstractCalculationMonitor;
    public linkedDataSources: Array<Workbook>;

    public constructor(init?: Partial< CalculationOptions >) {  
    
        Object.assign(this, init);
    } 
}
   
export class Cell  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "row",
            baseName: "Row",
            type: "number",
        },
        {
            name: "column",
            baseName: "Column",
            type: "number",
        },
        {
            name: "value",
            baseName: "Value",
            type: "string",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "formula",
            baseName: "Formula",
            type: "string",
        },
        {
            name: "isFormula",
            baseName: "IsFormula",
            type: "boolean",
        },
        {
            name: "isMerged",
            baseName: "IsMerged",
            type: "boolean",
        },
        {
            name: "isArrayHeader",
            baseName: "IsArrayHeader",
            type: "boolean",
        },
        {
            name: "isInArray",
            baseName: "IsInArray",
            type: "boolean",
        },
        {
            name: "isErrorValue",
            baseName: "IsErrorValue",
            type: "boolean",
        },
        {
            name: "isInTable",
            baseName: "IsInTable",
            type: "boolean",
        },
        {
            name: "isStyleSet",
            baseName: "IsStyleSet",
            type: "boolean",
        },
        {
            name: "htmlString",
            baseName: "HtmlString",
            type: "string",
        },
        {
            name: "style",
            baseName: "Style",
            type: "LinkElement",
        },
        {
            name: "worksheet",
            baseName: "Worksheet",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Cell.attributeTypeMap) ;

    }

    public name: string;
    public row: number;
    public column: number;
    public value: string;
    public type: string;
    public formula: string;
    public isFormula: boolean;
    public isMerged: boolean;
    public isArrayHeader: boolean;
    public isInArray: boolean;
    public isErrorValue: boolean;
    public isInTable: boolean;
    public isStyleSet: boolean;
    public htmlString: string;
    public style: LinkElement;
    public worksheet: string;

    public constructor(init?: Partial< Cell >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class CellArea  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "endColumn",
            baseName: "EndColumn",
            type: "number",
        },
        {
            name: "endRow",
            baseName: "EndRow",
            type: "number",
        },
        {
            name: "startColumn",
            baseName: "StartColumn",
            type: "number",
        },
        {
            name: "startRow",
            baseName: "StartRow",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CellArea.attributeTypeMap;

    }

    public endColumn: number;
    public endRow: number;
    public startColumn: number;
    public startRow: number;

    public constructor(init?: Partial< CellArea >) {  
    
        Object.assign(this, init);
    } 
}
   
export class Cells  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "maxRow",
            baseName: "MaxRow",
            type: "number",
        },
        {
            name: "maxColumn",
            baseName: "MaxColumn",
            type: "number",
        },
        {
            name: "cellCount",
            baseName: "CellCount",
            type: "number",
        },
        {
            name: "rows",
            baseName: "Rows",
            type: "LinkElement",
        },
        {
            name: "columns",
            baseName: "Columns",
            type: "LinkElement",
        },
        {
            name: "cellList",
            baseName: "CellList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Cells.attributeTypeMap) ;

    }

    public maxRow: number;
    public maxColumn: number;
    public cellCount: number;
    public rows: LinkElement;
    public columns: LinkElement;
    public cellList: Array<LinkElement>;

    public constructor(init?: Partial< Cells >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class CellsCloudFileInfo  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "size",
            baseName: "Size",
            type: "number",
        },
        {
            name: "folder",
            baseName: "Folder",
            type: "string",
        },
        {
            name: "storage",
            baseName: "Storage",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CellsCloudFileInfo.attributeTypeMap;

    }

    public name: string;
    public size: number;
    public folder: string;
    public storage: string;

    public constructor(init?: Partial< CellsCloudFileInfo >) {  
    
        Object.assign(this, init);
    } 
}
   
export class CellsColor  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "color",
            baseName: "Color",
            type: "Color",
        },
        {
            name: "colorIndex",
            baseName: "ColorIndex",
            type: "number",
        },
        {
            name: "isShapeColor",
            baseName: "IsShapeColor",
            type: "boolean",
        },
        {
            name: "tint",
            baseName: "tint",
            type: "number",
        },
        {
            name: "argb",
            baseName: "Argb",
            type: "number",
        },
        {
            name: "themeColor",
            baseName: "ThemeColor",
            type: "ThemeColor",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "transparency",
            baseName: "Transparency",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CellsColor.attributeTypeMap;

    }

    public color: Color;
    public colorIndex: number;
    public isShapeColor: boolean;
    public tint: number;
    public argb: number;
    public themeColor: ThemeColor;
    public type: string;
    public transparency: number;

    public constructor(init?: Partial< CellsColor >) {  
    
        Object.assign(this, init);
    } 
}
   
export class CellsDocumentProperty  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "value",
            baseName: "Value",
            type: "string",
        },
        {
            name: "isLinkedToContent",
            baseName: "IsLinkedToContent",
            type: "string",
        },
        {
            name: "source",
            baseName: "Source",
            type: "string",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "isGeneratedName",
            baseName: "IsGeneratedName",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CellsDocumentProperty.attributeTypeMap;

    }

    public name: string;
    public value: string;
    public isLinkedToContent: string;
    public source: string;
    public type: string;
    public isGeneratedName: string;

    public constructor(init?: Partial< CellsDocumentProperty >) {  
    
        Object.assign(this, init);
    } 
}
   
export class CellsDocumentProperties  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "documentPropertyList",
            baseName: "DocumentPropertyList",
            type: "Array<CellsDocumentProperty>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CellsDocumentProperties.attributeTypeMap;

    }

    public documentPropertyList: Array<CellsDocumentProperty>;

    public constructor(init?: Partial< CellsDocumentProperties >) {  
    
        Object.assign(this, init);
    } 
}
   
export class ColorFilter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "filterByFillColor",
            baseName: "FilterByFillColor",
            type: "boolean",
        },
        {
            name: "pattern",
            baseName: "Pattern",
            type: "string",
        },
        {
            name: "color",
            baseName: "Color",
            type: "CellsColor",
        },
        {
            name: "foregroundColorColor",
            baseName: "ForegroundColorColor",
            type: "CellsColor",
        },
        {
            name: "backgroundColor",
            baseName: "BackgroundColor",
            type: "CellsColor",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ColorFilter.attributeTypeMap;

    }

    public filterByFillColor: boolean;
    public pattern: string;
    public color: CellsColor;
    public foregroundColorColor: CellsColor;
    public backgroundColor: CellsColor;

    public constructor(init?: Partial< ColorFilter >) {  
    
        Object.assign(this, init);
    } 
}
   
export class ConditionalFormattingValue  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "isGTE",
            baseName: "IsGTE",
            type: "boolean",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "value",
            baseName: "Value",
            type: "Object",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ConditionalFormattingValue.attributeTypeMap;

    }

    public isGTE: boolean;
    public type: string;
    public value: Object;

    public constructor(init?: Partial< ConditionalFormattingValue >) {  
    
        Object.assign(this, init);
    } 
}
/// Describe the ColorScale conditional formatting rule. This conditional formatting
///    rule creates a gradated color scale on the cells.
///                
export class ColorScale  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "maxCfvo",
            baseName: "MaxCfvo",
            type: "ConditionalFormattingValue",
        },
        {
            name: "maxColor",
            baseName: "MaxColor",
            type: "Color",
        },
        {
            name: "midCfvo",
            baseName: "MidCfvo",
            type: "ConditionalFormattingValue",
        },
        {
            name: "midColor",
            baseName: "MidColor",
            type: "Color",
        },
        {
            name: "minCfvo",
            baseName: "MinCfvo",
            type: "ConditionalFormattingValue",
        },
        {
            name: "minColor",
            baseName: "MinColor",
            type: "Color",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ColorScale.attributeTypeMap;

    }

    public maxCfvo: ConditionalFormattingValue;
    public maxColor: Color;
    public midCfvo: ConditionalFormattingValue;
    public midColor: Color;
    public minCfvo: ConditionalFormattingValue;
    public minColor: Color;

    public constructor(init?: Partial< ColorScale >) {  
    
        Object.assign(this, init);
    } 
}
   
export class Column  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "groupLevel",
            baseName: "GroupLevel",
            type: "number",
        },
        {
            name: "index",
            baseName: "Index",
            type: "number",
        },
        {
            name: "isHidden",
            baseName: "IsHidden",
            type: "boolean",
        },
        {
            name: "width",
            baseName: "Width",
            type: "number",
        },
        {
            name: "style",
            baseName: "Style",
            type: "LinkElement",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Column.attributeTypeMap) ;

    }

    public groupLevel: number;
    public index: number;
    public isHidden: boolean;
    public width: number;
    public style: LinkElement;

    public constructor(init?: Partial< Column >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class Columns  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "maxColumn",
            baseName: "MaxColumn",
            type: "number",
        },
        {
            name: "columnsCount",
            baseName: "ColumnsCount",
            type: "number",
        },
        {
            name: "columnsList",
            baseName: "ColumnsList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Columns.attributeTypeMap) ;

    }

    public maxColumn: number;
    public columnsCount: number;
    public columnsList: Array<LinkElement>;

    public constructor(init?: Partial< Columns >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class Comment  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "cellName",
            baseName: "CellName",
            type: "string",
        },
        {
            name: "author",
            baseName: "Author",
            type: "string",
        },
        {
            name: "htmlNote",
            baseName: "HtmlNote",
            type: "string",
        },
        {
            name: "note",
            baseName: "Note",
            type: "string",
        },
        {
            name: "autoSize",
            baseName: "AutoSize",
            type: "boolean",
        },
        {
            name: "isVisible",
            baseName: "IsVisible",
            type: "boolean",
        },
        {
            name: "width",
            baseName: "Width",
            type: "number",
        },
        {
            name: "height",
            baseName: "Height",
            type: "number",
        },
        {
            name: "textHorizontalAlignment",
            baseName: "TextHorizontalAlignment",
            type: "string",
        },
        {
            name: "textOrientationType",
            baseName: "TextOrientationType",
            type: "string",
        },
        {
            name: "textVerticalAlignment",
            baseName: "TextVerticalAlignment",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Comment.attributeTypeMap) ;

    }

    public cellName: string;
    public author: string;
    public htmlNote: string;
    public note: string;
    public autoSize: boolean;
    public isVisible: boolean;
    public width: number;
    public height: number;
    public textHorizontalAlignment: string;
    public textOrientationType: string;
    public textVerticalAlignment: string;

    public constructor(init?: Partial< Comment >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class Comments  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "commentList",
            baseName: "CommentList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Comments.attributeTypeMap) ;

    }

    public commentList: Array<LinkElement>;

    public constructor(init?: Partial< Comments >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class FormatCondition  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "priority",
            baseName: "Priority",
            type: "number",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "stopIfTrue",
            baseName: "StopIfTrue",
            type: "boolean",
        },
        {
            name: "aboveAverage",
            baseName: "AboveAverage",
            type: "AboveAverage",
        },
        {
            name: "colorScale",
            baseName: "ColorScale",
            type: "ColorScale",
        },
        {
            name: "dataBar",
            baseName: "DataBar",
            type: "DataBar",
        },
        {
            name: "formula1",
            baseName: "Formula1",
            type: "string",
        },
        {
            name: "formula2",
            baseName: "Formula2",
            type: "string",
        },
        {
            name: "iconSet",
            baseName: "IconSet",
            type: "IconSet",
        },
        {
            name: "operator",
            baseName: "Operator",
            type: "string",
        },
        {
            name: "style",
            baseName: "Style",
            type: "Style",
        },
        {
            name: "text",
            baseName: "Text",
            type: "string",
        },
        {
            name: "timePeriod",
            baseName: "TimePeriod",
            type: "string",
        },
        {
            name: "top10",
            baseName: "Top10",
            type: "Top10",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FormatCondition.attributeTypeMap) ;

    }

    public priority: number;
    public type: string;
    public stopIfTrue: boolean;
    public aboveAverage: AboveAverage;
    public colorScale: ColorScale;
    public dataBar: DataBar;
    public formula1: string;
    public formula2: string;
    public iconSet: IconSet;
    public operator: string;
    public style: Style;
    public text: string;
    public timePeriod: string;
    public top10: Top10;

    public constructor(init?: Partial< FormatCondition >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class ConditionalFormatting  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sqref",
            baseName: "sqref",
            type: "string",
        },
        {
            name: "formatConditions",
            baseName: "FormatConditions",
            type: "Array<FormatCondition>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ConditionalFormatting.attributeTypeMap) ;

    }

    public sqref: string;
    public formatConditions: Array<FormatCondition>;

    public constructor(init?: Partial< ConditionalFormatting >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class ConditionalFormattingIcon  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "imageData",
            baseName: "ImageData",
            type: "string",
        },
        {
            name: "index",
            baseName: "Index",
            type: "number",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ConditionalFormattingIcon.attributeTypeMap;

    }

    public imageData: string;
    public index: number;
    public type: string;

    public constructor(init?: Partial< ConditionalFormattingIcon >) {  
    
        Object.assign(this, init);
    } 
}
   
export class ConditionalFormattings  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "count",
            baseName: "Count",
            type: "number",
        },
        {
            name: "conditionalFormattingList",
            baseName: "ConditionalFormattingList",
            type: "Array<ConditionalFormatting>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ConditionalFormattings.attributeTypeMap) ;

    }

    public count: number;
    public conditionalFormattingList: Array<ConditionalFormatting>;

    public constructor(init?: Partial< ConditionalFormattings >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the copy options.   
export class CopyOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "columnCharacterWidth",
            baseName: "ColumnCharacterWidth",
            type: "boolean",
        },
        {
            name: "copyInvalidFormulasAsValues",
            baseName: "CopyInvalidFormulasAsValues",
            type: "boolean",
        },
        {
            name: "copyNames",
            baseName: "CopyNames",
            type: "boolean",
        },
        {
            name: "extendToAdjacentRange",
            baseName: "ExtendToAdjacentRange",
            type: "boolean",
        },
        {
            name: "referToDestinationSheet",
            baseName: "ReferToDestinationSheet",
            type: "boolean",
        },
        {
            name: "referToSheetWithSameName",
            baseName: "ReferToSheetWithSameName",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CopyOptions.attributeTypeMap;

    }

    public columnCharacterWidth: boolean;
    public copyInvalidFormulasAsValues: boolean;
    public copyNames: boolean;
    public extendToAdjacentRange: boolean;
    public referToDestinationSheet: boolean;
    public referToSheetWithSameName: boolean;

    public constructor(init?: Partial< CopyOptions >) {  
    
        Object.assign(this, init);
    } 
}
   
export class MultipleFilter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  MultipleFilter.attributeTypeMap;

    }


    public constructor(init?: Partial< MultipleFilter >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class CriteriaMultipleFilter  extends MultipleFilter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "criteria",
            baseName: "Criteria",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CriteriaMultipleFilter.attributeTypeMap) ;

    }

    public criteria: string;

    public constructor(init?: Partial< CriteriaMultipleFilter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class CustomFilter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "criteria",
            baseName: "Criteria",
            type: "Object",
        },
        {
            name: "filterOperatorType",
            baseName: "FilterOperatorType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CustomFilter.attributeTypeMap;

    }

    public criteria: Object;
    public filterOperatorType: string;

    public constructor(init?: Partial< CustomFilter >) {  
    
        Object.assign(this, init);
    } 
}
   
export class DataBarBorder  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "color",
            baseName: "Color",
            type: "Color",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DataBarBorder.attributeTypeMap;

    }

    public color: Color;
    public type: string;

    public constructor(init?: Partial< DataBarBorder >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents the color settings of the data bars for negative values that are
///    defined by a data bar conditional formating rule.
///                
export class NegativeBarFormat  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "borderColor",
            baseName: "BorderColor",
            type: "Color",
        },
        {
            name: "borderColorType",
            baseName: "BorderColorType",
            type: "string",
        },
        {
            name: "color",
            baseName: "Color",
            type: "Color",
        },
        {
            name: "colorType",
            baseName: "ColorType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  NegativeBarFormat.attributeTypeMap;

    }

    public borderColor: Color;
    public borderColorType: string;
    public color: Color;
    public colorType: string;

    public constructor(init?: Partial< NegativeBarFormat >) {  
    
        Object.assign(this, init);
    } 
}
/// Describe the DataBar conditional formatting rule. This conditional formatting
///    rule displays a gradated data bar in the range of cells.   
export class DataBar  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "axisColor",
            baseName: "AxisColor",
            type: "Color",
        },
        {
            name: "axisPosition",
            baseName: "AxisPosition",
            type: "string",
        },
        {
            name: "barBorder",
            baseName: "BarBorder",
            type: "DataBarBorder",
        },
        {
            name: "barFillType",
            baseName: "BarFillType",
            type: "string",
        },
        {
            name: "color",
            baseName: "Color",
            type: "Color",
        },
        {
            name: "direction",
            baseName: "Direction",
            type: "string",
        },
        {
            name: "maxCfvo",
            baseName: "MaxCfvo",
            type: "ConditionalFormattingValue",
        },
        {
            name: "maxLength",
            baseName: "MaxLength",
            type: "number",
        },
        {
            name: "minCfvo",
            baseName: "MinCfvo",
            type: "ConditionalFormattingValue",
        },
        {
            name: "minLength",
            baseName: "MinLength",
            type: "number",
        },
        {
            name: "negativeBarFormat",
            baseName: "NegativeBarFormat",
            type: "NegativeBarFormat",
        },
        {
            name: "showValue",
            baseName: "ShowValue",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DataBar.attributeTypeMap;

    }

    public axisColor: Color;
    public axisPosition: string;
    public barBorder: DataBarBorder;
    public barFillType: string;
    public color: Color;
    public direction: string;
    public maxCfvo: ConditionalFormattingValue;
    public maxLength: number;
    public minCfvo: ConditionalFormattingValue;
    public minLength: number;
    public negativeBarFormat: NegativeBarFormat;
    public showValue: boolean;

    public constructor(init?: Partial< DataBar >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents the key of the data sorter.
///     
export class DataSorterKey  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "order",
            baseName: "Order",
            type: "string",
        },
        {
            name: "index",
            baseName: "Index",
            type: "number",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "iconSetType",
            baseName: "IconSetType",
            type: "string",
        },
        {
            name: "iconId",
            baseName: "IconId",
            type: "number",
        },
        {
            name: "color",
            baseName: "Color",
            type: "Color",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DataSorterKey.attributeTypeMap;

    }

    public order: string;
    public index: number;
    public type: string;
    public iconSetType: string;
    public iconId: number;
    public color: Color;

    public constructor(init?: Partial< DataSorterKey >) {  
    
        Object.assign(this, init);
    } 
}
   
export class SortKey  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "key",
            baseName: "Key",
            type: "number",
        },
        {
            name: "sortOrder",
            baseName: "SortOrder",
            type: "string",
        },
        {
            name: "customList",
            baseName: "CustomList",
            type: "Array<string>",
        },
        {
            name: "order",
            baseName: "Order",
            type: "string",
        },
        {
            name: "index",
            baseName: "Index",
            type: "number",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  SortKey.attributeTypeMap;

    }

    public key: number;
    public sortOrder: string;
    public customList: Array<string>;
    public order: string;
    public index: number;
    public type: string;

    public constructor(init?: Partial< SortKey >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class DateTimeGroupItem  extends MultipleFilter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dateTimeGroupingType",
            baseName: "DateTimeGroupingType",
            type: "string",
        },
        {
            name: "day",
            baseName: "Day",
            type: "number",
        },
        {
            name: "hour",
            baseName: "Hour",
            type: "number",
        },
        {
            name: "minute",
            baseName: "Minute",
            type: "number",
        },
        {
            name: "month",
            baseName: "Month",
            type: "number",
        },
        {
            name: "second",
            baseName: "Second",
            type: "number",
        },
        {
            name: "year",
            baseName: "Year",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DateTimeGroupItem.attributeTypeMap) ;

    }

    public dateTimeGroupingType: string;
    public day: number;
    public hour: number;
    public minute: number;
    public month: number;
    public second: number;
    public year: number;

    public constructor(init?: Partial< DateTimeGroupItem >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class DynamicFilter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dynamicFilterType",
            baseName: "DynamicFilterType",
            type: "string",
        },
        {
            name: "maxValue",
            baseName: "MaxValue",
            type: "Object",
        },
        {
            name: "value",
            baseName: "Value",
            type: "Object",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DynamicFilter.attributeTypeMap;

    }

    public dynamicFilterType: string;
    public maxValue: Object;
    public value: Object;

    public constructor(init?: Partial< DynamicFilter >) {  
    
        Object.assign(this, init);
    } 
}
   
export class FileInfo  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "filename",
            baseName: "Filename",
            type: "string",
        },
        {
            name: "fileSize",
            baseName: "FileSize",
            type: "number",
        },
        {
            name: "fileContent",
            baseName: "FileContent",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  FileInfo.attributeTypeMap;

    }

    public filename: string;
    public fileSize: number;
    public fileContent: string;

    public constructor(init?: Partial< FileInfo >) {  
    
        Object.assign(this, init);
    } 
}
   
export class FilesResult  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "files",
            baseName: "Files",
            type: "Array<FileInfo>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  FilesResult.attributeTypeMap;

    }

    public files: Array<FileInfo>;

    public constructor(init?: Partial< FilesResult >) {  
    
        Object.assign(this, init);
    } 
}
   
export class IconFilter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "iconId",
            baseName: "IconId",
            type: "number",
        },
        {
            name: "iconSetType",
            baseName: "IconSetType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  IconFilter.attributeTypeMap;

    }

    public iconId: number;
    public iconSetType: string;

    public constructor(init?: Partial< IconFilter >) {  
    
        Object.assign(this, init);
    } 
}
   
export class MultipleFilters  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "matchBlank",
            baseName: "MatchBlank",
            type: "boolean",
        },
        {
            name: "multipleFilterList",
            baseName: "MultipleFilterList",
            type: "Array<MultipleFilter>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  MultipleFilters.attributeTypeMap;

    }

    public matchBlank: boolean;
    public multipleFilterList: Array<MultipleFilter>;

    public constructor(init?: Partial< MultipleFilters >) {  
    
        Object.assign(this, init);
    } 
}
   
export class Top10Filter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "criteria",
            baseName: "Criteria",
            type: "string",
        },
        {
            name: "isPercent",
            baseName: "IsPercent",
            type: "boolean",
        },
        {
            name: "isTop",
            baseName: "IsTop",
            type: "boolean",
        },
        {
            name: "items",
            baseName: "Items",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Top10Filter.attributeTypeMap;

    }

    public criteria: string;
    public isPercent: boolean;
    public isTop: boolean;
    public items: number;

    public constructor(init?: Partial< Top10Filter >) {  
    
        Object.assign(this, init);
    } 
}
   
export class Font  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "color",
            baseName: "Color",
            type: "Color",
        },
        {
            name: "doubleSize",
            baseName: "DoubleSize",
            type: "number",
        },
        {
            name: "isBold",
            baseName: "IsBold",
            type: "boolean",
        },
        {
            name: "isItalic",
            baseName: "IsItalic",
            type: "boolean",
        },
        {
            name: "isStrikeout",
            baseName: "IsStrikeout",
            type: "boolean",
        },
        {
            name: "isSubscript",
            baseName: "IsSubscript",
            type: "boolean",
        },
        {
            name: "isSuperscript",
            baseName: "IsSuperscript",
            type: "boolean",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "size",
            baseName: "Size",
            type: "number",
        },
        {
            name: "underline",
            baseName: "Underline",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Font.attributeTypeMap;

    }

    public color: Color;
    public doubleSize: number;
    public isBold: boolean;
    public isItalic: boolean;
    public isStrikeout: boolean;
    public isSubscript: boolean;
    public isSuperscript: boolean;
    public name: string;
    public size: number;
    public underline: string;

    public constructor(init?: Partial< Font >) {  
    
        Object.assign(this, init);
    } 
}
   
export class TextOptions  extends Font  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "fill",
            baseName: "Fill",
            type: "FillFormat",
        },
        {
            name: "kerning",
            baseName: "Kerning",
            type: "number",
        },
        {
            name: "outline",
            baseName: "Outline",
            type: "LineFormat",
        },
        {
            name: "shadow",
            baseName: "Shadow",
            type: "ShadowEffect",
        },
        {
            name: "spacing",
            baseName: "Spacing",
            type: "number",
        },
        {
            name: "underlineColor",
            baseName: "UnderlineColor",
            type: "CellsColor",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TextOptions.attributeTypeMap) ;

    }

    public fill: FillFormat;
    public kerning: number;
    public outline: LineFormat;
    public shadow: ShadowEffect;
    public spacing: number;
    public underlineColor: CellsColor;

    public constructor(init?: Partial< TextOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class FontSetting  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "font",
            baseName: "Font",
            type: "Font",
        },
        {
            name: "length",
            baseName: "Length",
            type: "number",
        },
        {
            name: "startIndex",
            baseName: "StartIndex",
            type: "number",
        },
        {
            name: "textOptions",
            baseName: "TextOptions",
            type: "TextOptions",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  FontSetting.attributeTypeMap;

    }

    public font: Font;
    public length: number;
    public startIndex: number;
    public textOptions: TextOptions;
    public type: string;

    public constructor(init?: Partial< FontSetting >) {  
    
        Object.assign(this, init);
    } 
}
/// Describe the IconSet conditional formatting rule. This conditional formatting
///     rule applies icons to cells according to their values.   
export class IconSet  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "cfIcons",
            baseName: "CfIcons",
            type: "Array<ConditionalFormattingIcon>",
        },
        {
            name: "cfvos",
            baseName: "Cfvos",
            type: "Array<ConditionalFormattingValue>",
        },
        {
            name: "isCustom",
            baseName: "IsCustom",
            type: "boolean",
        },
        {
            name: "reverse",
            baseName: "Reverse",
            type: "boolean",
        },
        {
            name: "showValue",
            baseName: "ShowValue",
            type: "boolean",
        },
        {
            name: "iconSetType",
            baseName: "IconSetType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  IconSet.attributeTypeMap;

    }

    public cfIcons: Array<ConditionalFormattingIcon>;
    public cfvos: Array<ConditionalFormattingValue>;
    public isCustom: boolean;
    public reverse: boolean;
    public showValue: boolean;
    public iconSetType: string;

    public constructor(init?: Partial< IconSet >) {  
    
        Object.assign(this, init);
    } 
}
   
export class Style  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "font",
            baseName: "Font",
            type: "Font",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "cultureCustom",
            baseName: "CultureCustom",
            type: "string",
        },
        {
            name: "custom",
            baseName: "Custom",
            type: "string",
        },
        {
            name: "backgroundColor",
            baseName: "BackgroundColor",
            type: "Color",
        },
        {
            name: "foregroundColor",
            baseName: "ForegroundColor",
            type: "Color",
        },
        {
            name: "isFormulaHidden",
            baseName: "IsFormulaHidden",
            type: "boolean",
        },
        {
            name: "isDateTime",
            baseName: "IsDateTime",
            type: "boolean",
        },
        {
            name: "isTextWrapped",
            baseName: "IsTextWrapped",
            type: "boolean",
        },
        {
            name: "isGradient",
            baseName: "IsGradient",
            type: "boolean",
        },
        {
            name: "isLocked",
            baseName: "IsLocked",
            type: "boolean",
        },
        {
            name: "isPercent",
            baseName: "IsPercent",
            type: "boolean",
        },
        {
            name: "shrinkToFit",
            baseName: "ShrinkToFit",
            type: "boolean",
        },
        {
            name: "indentLevel",
            baseName: "IndentLevel",
            type: "number",
        },
        {
            name: "number",
            baseName: "Number",
            type: "number",
        },
        {
            name: "rotationAngle",
            baseName: "RotationAngle",
            type: "number",
        },
        {
            name: "pattern",
            baseName: "Pattern",
            type: "string",
        },
        {
            name: "textDirection",
            baseName: "TextDirection",
            type: "string",
        },
        {
            name: "verticalAlignment",
            baseName: "VerticalAlignment",
            type: "string",
        },
        {
            name: "horizontalAlignment",
            baseName: "HorizontalAlignment",
            type: "string",
        },
        {
            name: "borderCollection",
            baseName: "BorderCollection",
            type: "Array<Border>",
        },
        {
            name: "backgroundThemeColor",
            baseName: "BackgroundThemeColor",
            type: "ThemeColor",
        },
        {
            name: "foregroundThemeColor",
            baseName: "ForegroundThemeColor",
            type: "ThemeColor",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Style.attributeTypeMap;

    }

    public font: Font;
    public name: string;
    public cultureCustom: string;
    public custom: string;
    public backgroundColor: Color;
    public foregroundColor: Color;
    public isFormulaHidden: boolean;
    public isDateTime: boolean;
    public isTextWrapped: boolean;
    public isGradient: boolean;
    public isLocked: boolean;
    public isPercent: boolean;
    public shrinkToFit: boolean;
    public indentLevel: number;
    public number: number;
    public rotationAngle: number;
    public pattern: string;
    public textDirection: string;
    public verticalAlignment: string;
    public horizontalAlignment: string;
    public borderCollection: Array<Border>;
    public backgroundThemeColor: ThemeColor;
    public foregroundThemeColor: ThemeColor;

    public constructor(init?: Partial< Style >) {  
    
        Object.assign(this, init);
    } 
}
/// Describe the Top10 conditional formatting rule. This conditional formatting
///     rule highlights cells whose values fall in the top N or bottom N bracket,
///     as specified.   
export class Top10  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "isBottom",
            baseName: "IsBottom",
            type: "boolean",
        },
        {
            name: "isPercent",
            baseName: "IsPercent",
            type: "boolean",
        },
        {
            name: "rank",
            baseName: "Rank",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Top10.attributeTypeMap;

    }

    public isBottom: boolean;
    public isPercent: boolean;
    public rank: number;

    public constructor(init?: Partial< Top10 >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class FormulaFormatCondition  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "formula1",
            baseName: "Formula1",
            type: "string",
        },
        {
            name: "formula2",
            baseName: "Formula2",
            type: "string",
        },
        {
            name: "operator",
            baseName: "Operator",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  FormulaFormatCondition.attributeTypeMap;

    }

    public formula1: string;
    public formula2: string;
    public operator: string;

    public constructor(init?: Partial< FormulaFormatCondition >) {  
    
        Object.assign(this, init);
    } 
}
/// Settings of formulas and calculation.
///     
export class FormulaSettings  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "calculateOnOpen",
            baseName: "CalculateOnOpen",
            type: "boolean",
        },
        {
            name: "calculateOnSave",
            baseName: "CalculateOnSave",
            type: "boolean",
        },
        {
            name: "forceFullCalculation",
            baseName: "ForceFullCalculation",
            type: "boolean",
        },
        {
            name: "calculationMode",
            baseName: "CalculationMode",
            type: "string",
        },
        {
            name: "calculationId",
            baseName: "CalculationId",
            type: "string",
        },
        {
            name: "enableIterativeCalculation",
            baseName: "EnableIterativeCalculation",
            type: "boolean",
        },
        {
            name: "maxIteration",
            baseName: "MaxIteration",
            type: "number",
        },
        {
            name: "maxChange",
            baseName: "MaxChange",
            type: "number",
        },
        {
            name: "precisionAsDisplayed",
            baseName: "PrecisionAsDisplayed",
            type: "boolean",
        },
        {
            name: "enableCalculationChain",
            baseName: "EnableCalculationChain",
            type: "boolean",
        },
        {
            name: "preservePaddingSpaces",
            baseName: "PreservePaddingSpaces",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  FormulaSettings.attributeTypeMap;

    }

    public calculateOnOpen: boolean;
    public calculateOnSave: boolean;
    public forceFullCalculation: boolean;
    public calculationMode: string;
    public calculationId: string;
    public enableIterativeCalculation: boolean;
    public maxIteration: number;
    public maxChange: number;
    public precisionAsDisplayed: boolean;
    public enableCalculationChain: boolean;
    public preservePaddingSpaces: boolean;

    public constructor(init?: Partial< FormulaSettings >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents the globalization settings for chart.
///     
export class ChartGlobalizationSettings  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ChartGlobalizationSettings.attributeTypeMap;

    }


    public constructor(init?: Partial< ChartGlobalizationSettings >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents the globalization settings for pivot tables.
///     
export class PivotGlobalizationSettings  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  PivotGlobalizationSettings.attributeTypeMap;

    }


    public constructor(init?: Partial< PivotGlobalizationSettings >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents the globalization settings.
///     
export class GlobalizationSettings  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "chartSettings",
            baseName: "ChartSettings",
            type: "ChartGlobalizationSettings",
        },
        {
            name: "pivotSettings",
            baseName: "PivotSettings",
            type: "PivotGlobalizationSettings",
        },
        {
            name: "listSeparator",
            baseName: "ListSeparator",
            type: "string",
        },
        {
            name: "rowSeparatorOfFormulaArray",
            baseName: "RowSeparatorOfFormulaArray",
            type: "string",
        },
        {
            name: "columnSeparatorOfFormulaArray",
            baseName: "ColumnSeparatorOfFormulaArray",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  GlobalizationSettings.attributeTypeMap;

    }

    public chartSettings: ChartGlobalizationSettings;
    public pivotSettings: PivotGlobalizationSettings;
    public listSeparator: string;
    public rowSeparatorOfFormulaArray: string;
    public columnSeparatorOfFormulaArray: string;

    public constructor(init?: Partial< GlobalizationSettings >) {  
    
        Object.assign(this, init);
    } 
}
   
export class HorizontalPageBreak  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "row",
            baseName: "Row",
            type: "number",
        },
        {
            name: "endColumn",
            baseName: "EndColumn",
            type: "number",
        },
        {
            name: "startColumn",
            baseName: "StartColumn",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  HorizontalPageBreak.attributeTypeMap;

    }

    public row: number;
    public endColumn: number;
    public startColumn: number;

    public constructor(init?: Partial< HorizontalPageBreak >) {  
    
        Object.assign(this, init);
    } 
}
   
export class HorizontalPageBreaks  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(HorizontalPageBreaks.attributeTypeMap) ;

    }


    public constructor(init?: Partial< HorizontalPageBreaks >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class Hyperlink  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "address",
            baseName: "Address",
            type: "string",
        },
        {
            name: "area",
            baseName: "Area",
            type: "CellArea",
        },
        {
            name: "screenTip",
            baseName: "ScreenTip",
            type: "string",
        },
        {
            name: "textToDisplay",
            baseName: "TextToDisplay",
            type: "string",
        },
        {
            name: "linkType",
            baseName: "LinkType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Hyperlink.attributeTypeMap) ;

    }

    public address: string;
    public area: CellArea;
    public screenTip: string;
    public textToDisplay: string;
    public linkType: string;

    public constructor(init?: Partial< Hyperlink >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class Hyperlinks  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "count",
            baseName: "Count",
            type: "number",
        },
        {
            name: "hyperlinkList",
            baseName: "HyperlinkList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Hyperlinks.attributeTypeMap) ;

    }

    public count: number;
    public hyperlinkList: Array<LinkElement>;

    public constructor(init?: Partial< Hyperlinks >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class LoadOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "convertNumericData",
            baseName: "ConvertNumericData",
            type: "string",
        },
        {
            name: "interruptMonitor",
            baseName: "InterruptMonitor",
            type: "string",
        },
        {
            name: "languageCode",
            baseName: "LanguageCode",
            type: "string",
        },
        {
            name: "loadDataOptions",
            baseName: "LoadDataOptions",
            type: "string",
        },
        {
            name: "loadFormat",
            baseName: "LoadFormat",
            type: "string",
        },
        {
            name: "onlyLoadDocumentProperties",
            baseName: "OnlyLoadDocumentProperties",
            type: "string",
        },
        {
            name: "parsingFormulaOnOpen",
            baseName: "ParsingFormulaOnOpen",
            type: "string",
        },
        {
            name: "password",
            baseName: "Password",
            type: "string",
        },
        {
            name: "region",
            baseName: "Region",
            type: "string",
        },
        {
            name: "standardFont",
            baseName: "StandardFont",
            type: "string",
        },
        {
            name: "standardFontSize",
            baseName: "StandardFontSize",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  LoadOptions.attributeTypeMap;

    }

    public convertNumericData: string;
    public interruptMonitor: string;
    public languageCode: string;
    public loadDataOptions: string;
    public loadFormat: string;
    public onlyLoadDocumentProperties: string;
    public parsingFormulaOnOpen: string;
    public password: string;
    public region: string;
    public standardFont: string;
    public standardFontSize: number;

    public constructor(init?: Partial< LoadOptions >) {  
    
        Object.assign(this, init);
    } 
}
   
export class MergedCell  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "endColumn",
            baseName: "EndColumn",
            type: "number",
        },
        {
            name: "endRow",
            baseName: "EndRow",
            type: "number",
        },
        {
            name: "startColumn",
            baseName: "StartColumn",
            type: "number",
        },
        {
            name: "startRow",
            baseName: "StartRow",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(MergedCell.attributeTypeMap) ;

    }

    public endColumn: number;
    public endRow: number;
    public startColumn: number;
    public startRow: number;

    public constructor(init?: Partial< MergedCell >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class MergedCells  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "count",
            baseName: "Count",
            type: "number",
        },
        {
            name: "mergedCellList",
            baseName: "MergedCellList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(MergedCells.attributeTypeMap) ;

    }

    public count: number;
    public mergedCellList: Array<LinkElement>;

    public constructor(init?: Partial< MergedCells >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class Name  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "comment",
            baseName: "Comment",
            type: "string",
        },
        {
            name: "worksheetIndex",
            baseName: "WorksheetIndex",
            type: "number",
        },
        {
            name: "isReferred",
            baseName: "IsReferred",
            type: "boolean",
        },
        {
            name: "isVisible",
            baseName: "IsVisible",
            type: "boolean",
        },
        {
            name: "r1C1RefersTo",
            baseName: "R1C1RefersTo",
            type: "string",
        },
        {
            name: "refersTo",
            baseName: "RefersTo",
            type: "string",
        },
        {
            name: "text",
            baseName: "Text",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Name.attributeTypeMap) ;

    }

    public comment: string;
    public worksheetIndex: number;
    public isReferred: boolean;
    public isVisible: boolean;
    public r1C1RefersTo: string;
    public refersTo: string;
    public text: string;

    public constructor(init?: Partial< Name >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class Names  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "count",
            baseName: "Count",
            type: "number",
        },
        {
            name: "nameList",
            baseName: "NameList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Names.attributeTypeMap) ;

    }

    public count: number;
    public nameList: Array<LinkElement>;

    public constructor(init?: Partial< Names >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class PageSection  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "section",
            baseName: "Section",
            type: "number",
        },
        {
            name: "context",
            baseName: "Context",
            type: "string",
        },
        {
            name: "picture",
            baseName: "Picture",
            type: "string",
        },
        {
            name: "fisrtPageContext",
            baseName: "FisrtPageContext",
            type: "string",
        },
        {
            name: "evenPageContext",
            baseName: "EvenPageContext",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  PageSection.attributeTypeMap;

    }

    public section: number;
    public context: string;
    public picture: string;
    public fisrtPageContext: string;
    public evenPageContext: string;

    public constructor(init?: Partial< PageSection >) {  
    
        Object.assign(this, init);
    } 
}
   
export class PageSetup  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "blackAndWhite",
            baseName: "BlackAndWhite",
            type: "boolean",
        },
        {
            name: "bottomMargin",
            baseName: "BottomMargin",
            type: "number",
        },
        {
            name: "centerHorizontally",
            baseName: "CenterHorizontally",
            type: "boolean",
        },
        {
            name: "centerVertically",
            baseName: "CenterVertically",
            type: "boolean",
        },
        {
            name: "firstPageNumber",
            baseName: "FirstPageNumber",
            type: "number",
        },
        {
            name: "fitToPagesTall",
            baseName: "FitToPagesTall",
            type: "number",
        },
        {
            name: "fitToPagesWide",
            baseName: "FitToPagesWide",
            type: "number",
        },
        {
            name: "footerMargin",
            baseName: "FooterMargin",
            type: "number",
        },
        {
            name: "headerMargin",
            baseName: "HeaderMargin",
            type: "number",
        },
        {
            name: "isAutoFirstPageNumber",
            baseName: "IsAutoFirstPageNumber",
            type: "boolean",
        },
        {
            name: "isHFAlignMargins",
            baseName: "IsHFAlignMargins",
            type: "boolean",
        },
        {
            name: "isHFDiffFirst",
            baseName: "IsHFDiffFirst",
            type: "boolean",
        },
        {
            name: "isHFDiffOddEven",
            baseName: "IsHFDiffOddEven",
            type: "boolean",
        },
        {
            name: "isHFScaleWithDoc",
            baseName: "IsHFScaleWithDoc",
            type: "boolean",
        },
        {
            name: "isPercentScale",
            baseName: "IsPercentScale",
            type: "boolean",
        },
        {
            name: "leftMargin",
            baseName: "LeftMargin",
            type: "number",
        },
        {
            name: "order",
            baseName: "Order",
            type: "string",
        },
        {
            name: "orientation",
            baseName: "Orientation",
            type: "string",
        },
        {
            name: "paperSize",
            baseName: "PaperSize",
            type: "string",
        },
        {
            name: "printArea",
            baseName: "PrintArea",
            type: "string",
        },
        {
            name: "printComments",
            baseName: "PrintComments",
            type: "string",
        },
        {
            name: "printCopies",
            baseName: "PrintCopies",
            type: "number",
        },
        {
            name: "printDraft",
            baseName: "PrintDraft",
            type: "boolean",
        },
        {
            name: "printErrors",
            baseName: "PrintErrors",
            type: "string",
        },
        {
            name: "printGridlines",
            baseName: "PrintGridlines",
            type: "boolean",
        },
        {
            name: "printHeadings",
            baseName: "PrintHeadings",
            type: "boolean",
        },
        {
            name: "printQuality",
            baseName: "PrintQuality",
            type: "number",
        },
        {
            name: "printTitleColumns",
            baseName: "PrintTitleColumns",
            type: "string",
        },
        {
            name: "printTitleRows",
            baseName: "PrintTitleRows",
            type: "string",
        },
        {
            name: "rightMargin",
            baseName: "RightMargin",
            type: "number",
        },
        {
            name: "topMargin",
            baseName: "TopMargin",
            type: "number",
        },
        {
            name: "zoom",
            baseName: "Zoom",
            type: "number",
        },
        {
            name: "header",
            baseName: "Header",
            type: "Array<PageSection>",
        },
        {
            name: "footer",
            baseName: "Footer",
            type: "Array<PageSection>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PageSetup.attributeTypeMap) ;

    }

    public blackAndWhite: boolean;
    public bottomMargin: number;
    public centerHorizontally: boolean;
    public centerVertically: boolean;
    public firstPageNumber: number;
    public fitToPagesTall: number;
    public fitToPagesWide: number;
    public footerMargin: number;
    public headerMargin: number;
    public isAutoFirstPageNumber: boolean;
    public isHFAlignMargins: boolean;
    public isHFDiffFirst: boolean;
    public isHFDiffOddEven: boolean;
    public isHFScaleWithDoc: boolean;
    public isPercentScale: boolean;
    public leftMargin: number;
    public order: string;
    public orientation: string;
    public paperSize: string;
    public printArea: string;
    public printComments: string;
    public printCopies: number;
    public printDraft: boolean;
    public printErrors: string;
    public printGridlines: boolean;
    public printHeadings: boolean;
    public printQuality: number;
    public printTitleColumns: string;
    public printTitleRows: string;
    public rightMargin: number;
    public topMargin: number;
    public zoom: number;
    public header: Array<PageSection>;
    public footer: Array<PageSection>;

    public constructor(init?: Partial< PageSetup >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the paste special options.
///                
export class PasteOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "onlyVisibleCells",
            baseName: "OnlyVisibleCells",
            type: "boolean",
        },
        {
            name: "pasteType",
            baseName: "PasteType",
            type: "string",
        },
        {
            name: "skipBlanks",
            baseName: "SkipBlanks",
            type: "boolean",
        },
        {
            name: "transpose",
            baseName: "Transpose",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  PasteOptions.attributeTypeMap;

    }

    public onlyVisibleCells: boolean;
    public pasteType: string;
    public skipBlanks: boolean;
    public transpose: boolean;

    public constructor(init?: Partial< PasteOptions >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class PdfSecurityOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "annotationsPermission",
            baseName: "AnnotationsPermission",
            type: "boolean",
        },
        {
            name: "assembleDocumentPermission",
            baseName: "AssembleDocumentPermission",
            type: "boolean",
        },
        {
            name: "extractContentPermission",
            baseName: "ExtractContentPermission",
            type: "boolean",
        },
        {
            name: "extractContentPermissionObsolete",
            baseName: "ExtractContentPermissionObsolete",
            type: "boolean",
        },
        {
            name: "fillFormsPermission",
            baseName: "FillFormsPermission",
            type: "boolean",
        },
        {
            name: "fullQualityPrintPermission",
            baseName: "FullQualityPrintPermission",
            type: "boolean",
        },
        {
            name: "modifyDocumentPermission",
            baseName: "ModifyDocumentPermission",
            type: "boolean",
        },
        {
            name: "ownerPassword",
            baseName: "OwnerPassword",
            type: "string",
        },
        {
            name: "printPermission",
            baseName: "PrintPermission",
            type: "boolean",
        },
        {
            name: "userPassword",
            baseName: "UserPassword",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  PdfSecurityOptions.attributeTypeMap;

    }

    public annotationsPermission: boolean;
    public assembleDocumentPermission: boolean;
    public extractContentPermission: boolean;
    public extractContentPermissionObsolete: boolean;
    public fillFormsPermission: boolean;
    public fullQualityPrintPermission: boolean;
    public modifyDocumentPermission: boolean;
    public ownerPassword: string;
    public printPermission: boolean;
    public userPassword: string;

    public constructor(init?: Partial< PdfSecurityOptions >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents the various types of protection options available for a worksheet.
///                
export class Protection  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "allowDeletingColumn",
            baseName: "AllowDeletingColumn",
            type: "boolean",
        },
        {
            name: "allowDeletingRow",
            baseName: "AllowDeletingRow",
            type: "boolean",
        },
        {
            name: "allowFiltering",
            baseName: "AllowFiltering",
            type: "boolean",
        },
        {
            name: "allowFormattingCell",
            baseName: "AllowFormattingCell",
            type: "boolean",
        },
        {
            name: "allowFormattingColumn",
            baseName: "AllowFormattingColumn",
            type: "boolean",
        },
        {
            name: "allowFormattingRow",
            baseName: "AllowFormattingRow",
            type: "boolean",
        },
        {
            name: "allowInsertingColumn",
            baseName: "AllowInsertingColumn",
            type: "boolean",
        },
        {
            name: "allowInsertingHyperlink",
            baseName: "AllowInsertingHyperlink",
            type: "boolean",
        },
        {
            name: "allowInsertingRow",
            baseName: "AllowInsertingRow",
            type: "boolean",
        },
        {
            name: "allowSorting",
            baseName: "AllowSorting",
            type: "boolean",
        },
        {
            name: "allowUsingPivotTable",
            baseName: "AllowUsingPivotTable",
            type: "boolean",
        },
        {
            name: "allowEditingContent",
            baseName: "AllowEditingContent",
            type: "boolean",
        },
        {
            name: "allowEditingObject",
            baseName: "AllowEditingObject",
            type: "boolean",
        },
        {
            name: "allowEditingScenario",
            baseName: "AllowEditingScenario",
            type: "boolean",
        },
        {
            name: "password",
            baseName: "Password",
            type: "string",
        },
        {
            name: "allowSelectingLockedCell",
            baseName: "AllowSelectingLockedCell",
            type: "boolean",
        },
        {
            name: "allowSelectingUnlockedCell",
            baseName: "AllowSelectingUnlockedCell",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Protection.attributeTypeMap;

    }

    public allowDeletingColumn: boolean;
    public allowDeletingRow: boolean;
    public allowFiltering: boolean;
    public allowFormattingCell: boolean;
    public allowFormattingColumn: boolean;
    public allowFormattingRow: boolean;
    public allowInsertingColumn: boolean;
    public allowInsertingHyperlink: boolean;
    public allowInsertingRow: boolean;
    public allowSorting: boolean;
    public allowUsingPivotTable: boolean;
    public allowEditingContent: boolean;
    public allowEditingObject: boolean;
    public allowEditingScenario: boolean;
    public password: string;
    public allowSelectingLockedCell: boolean;
    public allowSelectingUnlockedCell: boolean;

    public constructor(init?: Partial< Protection >) {  
    
        Object.assign(this, init);
    } 
}
   
export class ProtectSheetParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "protectionType",
            baseName: "ProtectionType",
            type: "string",
        },
        {
            name: "password",
            baseName: "Password",
            type: "string",
        },
        {
            name: "allowEditArea",
            baseName: "AllowEditArea",
            type: "Array<string>",
        },
        {
            name: "allowDeletingColumn",
            baseName: "AllowDeletingColumn",
            type: "string",
        },
        {
            name: "allowDeletingRow",
            baseName: "AllowDeletingRow",
            type: "string",
        },
        {
            name: "allowFiltering",
            baseName: "AllowFiltering",
            type: "string",
        },
        {
            name: "allowFormattingCell",
            baseName: "AllowFormattingCell",
            type: "string",
        },
        {
            name: "allowFormattingColumn",
            baseName: "AllowFormattingColumn",
            type: "string",
        },
        {
            name: "allowFormattingRow",
            baseName: "AllowFormattingRow",
            type: "string",
        },
        {
            name: "allowInsertingColumn",
            baseName: "AllowInsertingColumn",
            type: "string",
        },
        {
            name: "allowInsertingHyperlink",
            baseName: "AllowInsertingHyperlink",
            type: "string",
        },
        {
            name: "allowInsertingRow",
            baseName: "AllowInsertingRow",
            type: "string",
        },
        {
            name: "allowSelectingLockedCell",
            baseName: "AllowSelectingLockedCell",
            type: "string",
        },
        {
            name: "allowSelectingUnlockedCell",
            baseName: "AllowSelectingUnlockedCell",
            type: "string",
        },
        {
            name: "allowSorting",
            baseName: "AllowSorting",
            type: "string",
        },
        {
            name: "allowUsingPivotTable",
            baseName: "AllowUsingPivotTable",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ProtectSheetParameter.attributeTypeMap;

    }

    public protectionType: string;
    public password: string;
    public allowEditArea: Array<string>;
    public allowDeletingColumn: string;
    public allowDeletingRow: string;
    public allowFiltering: string;
    public allowFormattingCell: string;
    public allowFormattingColumn: string;
    public allowFormattingRow: string;
    public allowInsertingColumn: string;
    public allowInsertingHyperlink: string;
    public allowInsertingRow: string;
    public allowSelectingLockedCell: string;
    public allowSelectingUnlockedCell: string;
    public allowSorting: string;
    public allowUsingPivotTable: string;

    public constructor(init?: Partial< ProtectSheetParameter >) {  
    
        Object.assign(this, init);
    } 
}
   
export class Range  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "columnCount",
            baseName: "ColumnCount",
            type: "number",
        },
        {
            name: "columnWidth",
            baseName: "ColumnWidth",
            type: "number",
        },
        {
            name: "firstColumn",
            baseName: "FirstColumn",
            type: "number",
        },
        {
            name: "firstRow",
            baseName: "FirstRow",
            type: "number",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "refersTo",
            baseName: "RefersTo",
            type: "string",
        },
        {
            name: "rowCount",
            baseName: "RowCount",
            type: "number",
        },
        {
            name: "rowHeight",
            baseName: "RowHeight",
            type: "number",
        },
        {
            name: "worksheet",
            baseName: "Worksheet",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Range.attributeTypeMap;

    }

    public columnCount: number;
    public columnWidth: number;
    public firstColumn: number;
    public firstRow: number;
    public name: string;
    public refersTo: string;
    public rowCount: number;
    public rowHeight: number;
    public worksheet: string;

    public constructor(init?: Partial< Range >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents QueryTable information.   
export class QueryTable  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "connectionId",
            baseName: "ConnectionId",
            type: "number",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "resultRange",
            baseName: "ResultRange",
            type: "Range",
        },
        {
            name: "preserveFormatting",
            baseName: "PreserveFormatting",
            type: "boolean",
        },
        {
            name: "adjustColumnWidth",
            baseName: "AdjustColumnWidth",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  QueryTable.attributeTypeMap;

    }

    public connectionId: number;
    public name: string;
    public resultRange: Range;
    public preserveFormatting: boolean;
    public adjustColumnWidth: boolean;

    public constructor(init?: Partial< QueryTable >) {  
    
        Object.assign(this, init);
    } 
}
   
export class Ranges  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "rangeList",
            baseName: "RangeList",
            type: "Array<Range>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Ranges.attributeTypeMap;

    }

    public rangeList: Array<Range>;

    public constructor(init?: Partial< Ranges >) {  
    
        Object.assign(this, init);
    } 
}
   
export class Row  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "groupLevel",
            baseName: "GroupLevel",
            type: "number",
        },
        {
            name: "height",
            baseName: "Height",
            type: "number",
        },
        {
            name: "index",
            baseName: "Index",
            type: "number",
        },
        {
            name: "isBlank",
            baseName: "IsBlank",
            type: "boolean",
        },
        {
            name: "isHeightMatched",
            baseName: "IsHeightMatched",
            type: "boolean",
        },
        {
            name: "isHidden",
            baseName: "IsHidden",
            type: "boolean",
        },
        {
            name: "style",
            baseName: "Style",
            type: "LinkElement",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Row.attributeTypeMap) ;

    }

    public groupLevel: number;
    public height: number;
    public index: number;
    public isBlank: boolean;
    public isHeightMatched: boolean;
    public isHidden: boolean;
    public style: LinkElement;

    public constructor(init?: Partial< Row >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class Rows  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "maxRow",
            baseName: "MaxRow",
            type: "number",
        },
        {
            name: "rowsCount",
            baseName: "RowsCount",
            type: "number",
        },
        {
            name: "rowsList",
            baseName: "RowsList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Rows.attributeTypeMap) ;

    }

    public maxRow: number;
    public rowsCount: number;
    public rowsList: Array<LinkElement>;

    public constructor(init?: Partial< Rows >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class SaveResult  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "documents",
            baseName: "Documents",
            type: "Array<CellsCloudFileInfo>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  SaveResult.attributeTypeMap;

    }

    public documents: Array<CellsCloudFileInfo>;

    public constructor(init?: Partial< SaveResult >) {  
    
        Object.assign(this, init);
    } 
}
   
export class SingleValue  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "value",
            baseName: "Value",
            type: "string",
        },
        {
            name: "valueType",
            baseName: "ValueType",
            type: "ValueType",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  SingleValue.attributeTypeMap;

    }

    public value: string;
    public valueType: ValueType;

    public constructor(init?: Partial< SingleValue >) {  
    
        Object.assign(this, init);
    } 
}
   
export class SplitResult  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "documents",
            baseName: "Documents",
            type: "Array<CellsCloudFileInfo>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  SplitResult.attributeTypeMap;

    }

    public documents: Array<CellsCloudFileInfo>;

    public constructor(init?: Partial< SplitResult >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class SplitResultDocument  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "id",
            baseName: "Id",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SplitResultDocument.attributeTypeMap) ;

    }

    public id: number;

    public constructor(init?: Partial< SplitResultDocument >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class StyleFormatCondition  extends FormatCondition  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(StyleFormatCondition.attributeTypeMap) ;

    }


    public constructor(init?: Partial< StyleFormatCondition >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class Styles  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "styleList",
            baseName: "StyleList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Styles.attributeTypeMap) ;

    }

    public styleList: Array<LinkElement>;

    public constructor(init?: Partial< Styles >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class TextFormatCondition  extends FormulaFormatCondition  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "text",
            baseName: "Text",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TextFormatCondition.attributeTypeMap) ;

    }

    public text: string;

    public constructor(init?: Partial< TextFormatCondition >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class TextItem  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "text",
            baseName: "Text",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TextItem.attributeTypeMap) ;

    }

    public text: string;

    public constructor(init?: Partial< TextItem >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class TextItems  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "textItemList",
            baseName: "TextItemList",
            type: "Array<TextItem>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TextItems.attributeTypeMap) ;

    }

    public textItemList: Array<TextItem>;

    public constructor(init?: Partial< TextItems >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class FillFormat  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "solidFill",
            baseName: "SolidFill",
            type: "SolidFill",
        },
        {
            name: "patternFill",
            baseName: "PatternFill",
            type: "PatternFill",
        },
        {
            name: "textureFill",
            baseName: "TextureFill",
            type: "TextureFill",
        },
        {
            name: "gradientFill",
            baseName: "GradientFill",
            type: "GradientFill",
        },
        {
            name: "imageData",
            baseName: "ImageData",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  FillFormat.attributeTypeMap;

    }

    public type: string;
    public solidFill: SolidFill;
    public patternFill: PatternFill;
    public textureFill: TextureFill;
    public gradientFill: GradientFill;
    public imageData: string;

    public constructor(init?: Partial< FillFormat >) {  
    
        Object.assign(this, init);
    } 
}
   
export class LineFormat  extends FillFormat  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "beginArrowheadLength",
            baseName: "BeginArrowheadLength",
            type: "string",
        },
        {
            name: "beginArrowheadStyle",
            baseName: "BeginArrowheadStyle",
            type: "string",
        },
        {
            name: "beginArrowheadWidth",
            baseName: "BeginArrowheadWidth",
            type: "string",
        },
        {
            name: "capType",
            baseName: "CapType",
            type: "string",
        },
        {
            name: "compoundType",
            baseName: "CompoundType",
            type: "string",
        },
        {
            name: "dashStyle",
            baseName: "DashStyle",
            type: "string",
        },
        {
            name: "endArrowheadLength",
            baseName: "EndArrowheadLength",
            type: "string",
        },
        {
            name: "endArrowheadStyle",
            baseName: "EndArrowheadStyle",
            type: "string",
        },
        {
            name: "endArrowheadWidth",
            baseName: "EndArrowheadWidth",
            type: "string",
        },
        {
            name: "joinType",
            baseName: "JoinType",
            type: "string",
        },
        {
            name: "weight",
            baseName: "Weight",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LineFormat.attributeTypeMap) ;

    }

    public beginArrowheadLength: string;
    public beginArrowheadStyle: string;
    public beginArrowheadWidth: string;
    public capType: string;
    public compoundType: string;
    public dashStyle: string;
    public endArrowheadLength: string;
    public endArrowheadStyle: string;
    public endArrowheadWidth: string;
    public joinType: string;
    public weight: number;

    public constructor(init?: Partial< LineFormat >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class ShadowEffect  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "angle",
            baseName: "Angle",
            type: "number",
        },
        {
            name: "blur",
            baseName: "Blur",
            type: "number",
        },
        {
            name: "color",
            baseName: "Color",
            type: "CellsColor",
        },
        {
            name: "distance",
            baseName: "Distance",
            type: "number",
        },
        {
            name: "presetType",
            baseName: "PresetType",
            type: "string",
        },
        {
            name: "size",
            baseName: "Size",
            type: "number",
        },
        {
            name: "transparency",
            baseName: "Transparency",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ShadowEffect.attributeTypeMap;

    }

    public angle: number;
    public blur: number;
    public color: CellsColor;
    public distance: number;
    public presetType: string;
    public size: number;
    public transparency: number;

    public constructor(init?: Partial< ShadowEffect >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class TimePeriodFormatCondition  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "timePeriod",
            baseName: "TimePeriod",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  TimePeriodFormatCondition.attributeTypeMap;

    }

    public timePeriod: string;

    public constructor(init?: Partial< TimePeriodFormatCondition >) {  
    
        Object.assign(this, init);
    } 
}
   
export class Validation  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "alertStyle",
            baseName: "AlertStyle",
            type: "string",
        },
        {
            name: "areaList",
            baseName: "AreaList",
            type: "Array<CellArea>",
        },
        {
            name: "errorMessage",
            baseName: "ErrorMessage",
            type: "string",
        },
        {
            name: "errorTitle",
            baseName: "ErrorTitle",
            type: "string",
        },
        {
            name: "formula1",
            baseName: "Formula1",
            type: "string",
        },
        {
            name: "formula2",
            baseName: "Formula2",
            type: "string",
        },
        {
            name: "ignoreBlank",
            baseName: "IgnoreBlank",
            type: "boolean",
        },
        {
            name: "inCellDropDown",
            baseName: "InCellDropDown",
            type: "boolean",
        },
        {
            name: "inputMessage",
            baseName: "InputMessage",
            type: "string",
        },
        {
            name: "inputTitle",
            baseName: "InputTitle",
            type: "string",
        },
        {
            name: "operator",
            baseName: "Operator",
            type: "string",
        },
        {
            name: "showError",
            baseName: "ShowError",
            type: "boolean",
        },
        {
            name: "showInput",
            baseName: "ShowInput",
            type: "boolean",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "value1",
            baseName: "Value1",
            type: "string",
        },
        {
            name: "value2",
            baseName: "Value2",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Validation.attributeTypeMap) ;

    }

    public alertStyle: string;
    public areaList: Array<CellArea>;
    public errorMessage: string;
    public errorTitle: string;
    public formula1: string;
    public formula2: string;
    public ignoreBlank: boolean;
    public inCellDropDown: boolean;
    public inputMessage: string;
    public inputTitle: string;
    public operator: string;
    public showError: boolean;
    public showInput: boolean;
    public type: string;
    public value1: string;
    public value2: string;

    public constructor(init?: Partial< Validation >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class Validations  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "count",
            baseName: "Count",
            type: "number",
        },
        {
            name: "validationList",
            baseName: "ValidationList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Validations.attributeTypeMap) ;

    }

    public count: number;
    public validationList: Array<LinkElement>;

    public constructor(init?: Partial< Validations >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class VerticalPageBreak  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "column",
            baseName: "Column",
            type: "number",
        },
        {
            name: "endRow",
            baseName: "EndRow",
            type: "number",
        },
        {
            name: "startRow",
            baseName: "StartRow",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  VerticalPageBreak.attributeTypeMap;

    }

    public column: number;
    public endRow: number;
    public startRow: number;

    public constructor(init?: Partial< VerticalPageBreak >) {  
    
        Object.assign(this, init);
    } 
}
   
export class VerticalPageBreaks  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(VerticalPageBreaks.attributeTypeMap) ;

    }


    public constructor(init?: Partial< VerticalPageBreaks >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Specifies write protection settings for a workbook.
///     
export class WriteProtection  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "author",
            baseName: "Author",
            type: "string",
        },
        {
            name: "recommendReadOnly",
            baseName: "RecommendReadOnly",
            type: "boolean",
        },
        {
            name: "isWriteProtected",
            baseName: "IsWriteProtected",
            type: "boolean",
        },
        {
            name: "password",
            baseName: "Password",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  WriteProtection.attributeTypeMap;

    }

    public author: string;
    public recommendReadOnly: boolean;
    public isWriteProtected: boolean;
    public password: string;

    public constructor(init?: Partial< WriteProtection >) {  
    
        Object.assign(this, init);
    } 
}
   
export class WorkbookSettings  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoCompressPictures",
            baseName: "AutoCompressPictures",
            type: "boolean",
        },
        {
            name: "autoRecover",
            baseName: "AutoRecover",
            type: "boolean",
        },
        {
            name: "buildVersion",
            baseName: "BuildVersion",
            type: "string",
        },
        {
            name: "calcMode",
            baseName: "CalcMode",
            type: "string",
        },
        {
            name: "calcStackSize",
            baseName: "CalcStackSize",
            type: "number",
        },
        {
            name: "calculationId",
            baseName: "CalculationId",
            type: "string",
        },
        {
            name: "checkComptiliblity",
            baseName: "CheckComptiliblity",
            type: "boolean",
        },
        {
            name: "checkExcelRestriction",
            baseName: "CheckExcelRestriction",
            type: "boolean",
        },
        {
            name: "crashSave",
            baseName: "CrashSave",
            type: "boolean",
        },
        {
            name: "createCalcChain",
            baseName: "CreateCalcChain",
            type: "boolean",
        },
        {
            name: "dataExtractLoad",
            baseName: "DataExtractLoad",
            type: "boolean",
        },
        {
            name: "date1904",
            baseName: "Date1904",
            type: "boolean",
        },
        {
            name: "displayDrawingObjects",
            baseName: "DisplayDrawingObjects",
            type: "string",
        },
        {
            name: "enableMacros",
            baseName: "EnableMacros",
            type: "boolean",
        },
        {
            name: "firstVisibleTab",
            baseName: "FirstVisibleTab",
            type: "number",
        },
        {
            name: "hidePivotFieldList",
            baseName: "HidePivotFieldList",
            type: "boolean",
        },
        {
            name: "isDefaultEncrypted",
            baseName: "IsDefaultEncrypted",
            type: "boolean",
        },
        {
            name: "isHidden",
            baseName: "IsHidden",
            type: "boolean",
        },
        {
            name: "isHScrollBarVisible",
            baseName: "IsHScrollBarVisible",
            type: "boolean",
        },
        {
            name: "isMinimized",
            baseName: "IsMinimized",
            type: "boolean",
        },
        {
            name: "isVScrollBarVisible",
            baseName: "IsVScrollBarVisible",
            type: "boolean",
        },
        {
            name: "iteration",
            baseName: "Iteration",
            type: "boolean",
        },
        {
            name: "languageCode",
            baseName: "LanguageCode",
            type: "string",
        },
        {
            name: "maxChange",
            baseName: "MaxChange",
            type: "number",
        },
        {
            name: "maxIteration",
            baseName: "MaxIteration",
            type: "number",
        },
        {
            name: "memorySetting",
            baseName: "MemorySetting",
            type: "string",
        },
        {
            name: "numberDecimalSeparator",
            baseName: "NumberDecimalSeparator",
            type: "string",
        },
        {
            name: "numberGroupSeparator",
            baseName: "NumberGroupSeparator",
            type: "string",
        },
        {
            name: "parsingFormulaOnOpen",
            baseName: "ParsingFormulaOnOpen",
            type: "boolean",
        },
        {
            name: "precisionAsDisplayed",
            baseName: "PrecisionAsDisplayed",
            type: "boolean",
        },
        {
            name: "recalculateBeforeSave",
            baseName: "RecalculateBeforeSave",
            type: "boolean",
        },
        {
            name: "reCalculateOnOpen",
            baseName: "ReCalculateOnOpen",
            type: "boolean",
        },
        {
            name: "recommendReadOnly",
            baseName: "RecommendReadOnly",
            type: "boolean",
        },
        {
            name: "region",
            baseName: "Region",
            type: "string",
        },
        {
            name: "removePersonalInformation",
            baseName: "RemovePersonalInformation",
            type: "boolean",
        },
        {
            name: "repairLoad",
            baseName: "RepairLoad",
            type: "boolean",
        },
        {
            name: "shared",
            baseName: "Shared",
            type: "boolean",
        },
        {
            name: "sheetTabBarWidth",
            baseName: "SheetTabBarWidth",
            type: "number",
        },
        {
            name: "showTabs",
            baseName: "ShowTabs",
            type: "boolean",
        },
        {
            name: "updateAdjacentCellsBorder",
            baseName: "UpdateAdjacentCellsBorder",
            type: "boolean",
        },
        {
            name: "updateLinksType",
            baseName: "UpdateLinksType",
            type: "string",
        },
        {
            name: "windowHeight",
            baseName: "WindowHeight",
            type: "number",
        },
        {
            name: "windowLeft",
            baseName: "WindowLeft",
            type: "number",
        },
        {
            name: "windowTop",
            baseName: "WindowTop",
            type: "number",
        },
        {
            name: "windowWidth",
            baseName: "WindowWidth",
            type: "number",
        },
        {
            name: "author",
            baseName: "Author",
            type: "string",
        },
        {
            name: "checkCustomNumberFormat",
            baseName: "CheckCustomNumberFormat",
            type: "boolean",
        },
        {
            name: "protectionType",
            baseName: "ProtectionType",
            type: "string",
        },
        {
            name: "globalizationSettings",
            baseName: "GlobalizationSettings",
            type: "GlobalizationSettings",
        },
        {
            name: "password",
            baseName: "Password",
            type: "string",
        },
        {
            name: "writeProtection",
            baseName: "WriteProtection",
            type: "WriteProtection",
        },
        {
            name: "isEncrypted",
            baseName: "IsEncrypted",
            type: "boolean",
        },
        {
            name: "isProtected",
            baseName: "IsProtected",
            type: "boolean",
        },
        {
            name: "maxRow",
            baseName: "MaxRow",
            type: "number",
        },
        {
            name: "maxColumn",
            baseName: "MaxColumn",
            type: "number",
        },
        {
            name: "significantDigits",
            baseName: "SignificantDigits",
            type: "number",
        },
        {
            name: "checkCompatibility",
            baseName: "CheckCompatibility",
            type: "boolean",
        },
        {
            name: "paperSize",
            baseName: "PaperSize",
            type: "string",
        },
        {
            name: "maxRowsOfSharedFormula",
            baseName: "MaxRowsOfSharedFormula",
            type: "number",
        },
        {
            name: "compliance",
            baseName: "Compliance",
            type: "string",
        },
        {
            name: "quotePrefixToStyle",
            baseName: "QuotePrefixToStyle",
            type: "boolean",
        },
        {
            name: "formulaSettings",
            baseName: "FormulaSettings",
            type: "FormulaSettings",
        },
        {
            name: "forceFullCalculate",
            baseName: "ForceFullCalculate",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  WorkbookSettings.attributeTypeMap;

    }

    public autoCompressPictures: boolean;
    public autoRecover: boolean;
    public buildVersion: string;
    public calcMode: string;
    public calcStackSize: number;
    public calculationId: string;
    public checkComptiliblity: boolean;
    public checkExcelRestriction: boolean;
    public crashSave: boolean;
    public createCalcChain: boolean;
    public dataExtractLoad: boolean;
    public date1904: boolean;
    public displayDrawingObjects: string;
    public enableMacros: boolean;
    public firstVisibleTab: number;
    public hidePivotFieldList: boolean;
    public isDefaultEncrypted: boolean;
    public isHidden: boolean;
    public isHScrollBarVisible: boolean;
    public isMinimized: boolean;
    public isVScrollBarVisible: boolean;
    public iteration: boolean;
    public languageCode: string;
    public maxChange: number;
    public maxIteration: number;
    public memorySetting: string;
    public numberDecimalSeparator: string;
    public numberGroupSeparator: string;
    public parsingFormulaOnOpen: boolean;
    public precisionAsDisplayed: boolean;
    public recalculateBeforeSave: boolean;
    public reCalculateOnOpen: boolean;
    public recommendReadOnly: boolean;
    public region: string;
    public removePersonalInformation: boolean;
    public repairLoad: boolean;
    public shared: boolean;
    public sheetTabBarWidth: number;
    public showTabs: boolean;
    public updateAdjacentCellsBorder: boolean;
    public updateLinksType: string;
    public windowHeight: number;
    public windowLeft: number;
    public windowTop: number;
    public windowWidth: number;
    public author: string;
    public checkCustomNumberFormat: boolean;
    public protectionType: string;
    public globalizationSettings: GlobalizationSettings;
    public password: string;
    public writeProtection: WriteProtection;
    public isEncrypted: boolean;
    public isProtected: boolean;
    public maxRow: number;
    public maxColumn: number;
    public significantDigits: number;
    public checkCompatibility: boolean;
    public paperSize: string;
    public maxRowsOfSharedFormula: number;
    public compliance: string;
    public quotePrefixToStyle: boolean;
    public formulaSettings: FormulaSettings;
    public forceFullCalculate: boolean;

    public constructor(init?: Partial< WorkbookSettings >) {  
    
        Object.assign(this, init);
    } 
}
   
export class Worksheet  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "links",
            baseName: "Links",
            type: "Array<Link>",
        },
        {
            name: "displayRightToLeft",
            baseName: "DisplayRightToLeft",
            type: "boolean",
        },
        {
            name: "displayZeros",
            baseName: "DisplayZeros",
            type: "boolean",
        },
        {
            name: "firstVisibleColumn",
            baseName: "FirstVisibleColumn",
            type: "number",
        },
        {
            name: "firstVisibleRow",
            baseName: "FirstVisibleRow",
            type: "number",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "index",
            baseName: "Index",
            type: "number",
        },
        {
            name: "isGridlinesVisible",
            baseName: "IsGridlinesVisible",
            type: "boolean",
        },
        {
            name: "isOutlineShown",
            baseName: "IsOutlineShown",
            type: "boolean",
        },
        {
            name: "isPageBreakPreview",
            baseName: "IsPageBreakPreview",
            type: "boolean",
        },
        {
            name: "isVisible",
            baseName: "IsVisible",
            type: "boolean",
        },
        {
            name: "isProtected",
            baseName: "IsProtected",
            type: "boolean",
        },
        {
            name: "isRowColumnHeadersVisible",
            baseName: "IsRowColumnHeadersVisible",
            type: "boolean",
        },
        {
            name: "isRulerVisible",
            baseName: "IsRulerVisible",
            type: "boolean",
        },
        {
            name: "isSelected",
            baseName: "IsSelected",
            type: "boolean",
        },
        {
            name: "tabColor",
            baseName: "TabColor",
            type: "Color",
        },
        {
            name: "transitionEntry",
            baseName: "TransitionEntry",
            type: "boolean",
        },
        {
            name: "transitionEvaluation",
            baseName: "TransitionEvaluation",
            type: "boolean",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "viewType",
            baseName: "ViewType",
            type: "string",
        },
        {
            name: "visibilityType",
            baseName: "VisibilityType",
            type: "string",
        },
        {
            name: "zoom",
            baseName: "Zoom",
            type: "number",
        },
        {
            name: "cells",
            baseName: "Cells",
            type: "LinkElement",
        },
        {
            name: "charts",
            baseName: "Charts",
            type: "LinkElement",
        },
        {
            name: "autoShapes",
            baseName: "AutoShapes",
            type: "LinkElement",
        },
        {
            name: "oleObjects",
            baseName: "OleObjects",
            type: "LinkElement",
        },
        {
            name: "comments",
            baseName: "Comments",
            type: "LinkElement",
        },
        {
            name: "pictures",
            baseName: "Pictures",
            type: "LinkElement",
        },
        {
            name: "mergedCells",
            baseName: "MergedCells",
            type: "LinkElement",
        },
        {
            name: "validations",
            baseName: "Validations",
            type: "LinkElement",
        },
        {
            name: "conditionalFormattings",
            baseName: "ConditionalFormattings",
            type: "LinkElement",
        },
        {
            name: "hyperlinks",
            baseName: "Hyperlinks",
            type: "LinkElement",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Worksheet.attributeTypeMap;

    }

    public links: Array<Link>;
    public displayRightToLeft: boolean;
    public displayZeros: boolean;
    public firstVisibleColumn: number;
    public firstVisibleRow: number;
    public name: string;
    public index: number;
    public isGridlinesVisible: boolean;
    public isOutlineShown: boolean;
    public isPageBreakPreview: boolean;
    public isVisible: boolean;
    public isProtected: boolean;
    public isRowColumnHeadersVisible: boolean;
    public isRulerVisible: boolean;
    public isSelected: boolean;
    public tabColor: Color;
    public transitionEntry: boolean;
    public transitionEvaluation: boolean;
    public type: string;
    public viewType: string;
    public visibilityType: string;
    public zoom: number;
    public cells: LinkElement;
    public charts: LinkElement;
    public autoShapes: LinkElement;
    public oleObjects: LinkElement;
    public comments: LinkElement;
    public pictures: LinkElement;
    public mergedCells: LinkElement;
    public validations: LinkElement;
    public conditionalFormattings: LinkElement;
    public hyperlinks: LinkElement;

    public constructor(init?: Partial< Worksheet >) {  
    
        Object.assign(this, init);
    } 
}
   
export class Worksheets  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "worksheetList",
            baseName: "WorksheetList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Worksheets.attributeTypeMap) ;

    }

    public worksheetList: Array<LinkElement>;

    public constructor(init?: Partial< Worksheets >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents Xml Data Binding information.
///     
export class XmlDataBinding  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "url",
            baseName: "Url",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  XmlDataBinding.attributeTypeMap;

    }

    public url: string;

    public constructor(init?: Partial< XmlDataBinding >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents Xml map information.
///     
export class XmlMap  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "rootElementName",
            baseName: "RootElementName",
            type: "string",
        },
        {
            name: "dataBinding",
            baseName: "DataBinding",
            type: "XmlDataBinding",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  XmlMap.attributeTypeMap;

    }

    public name: string;
    public rootElementName: string;
    public dataBinding: XmlDataBinding;

    public constructor(init?: Partial< XmlMap >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class TaskParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  TaskParameter.attributeTypeMap;

    }


    public constructor(init?: Partial< TaskParameter >) {  
    
        Object.assign(this, init);
    } 
}
   
export class FileSource  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "fileSourceType",
            baseName: "FileSourceType",
            type: "string",
        },
        {
            name: "filePath",
            baseName: "FilePath",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  FileSource.attributeTypeMap;

    }

    public fileSourceType: string;
    public filePath: string;

    public constructor(init?: Partial< FileSource >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class OperateObject  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "operateObjectType",
            baseName: "OperateObjectType",
            type: "string",
        },
        {
            name: "position",
            baseName: "Position",
            type: "OperateObjectPosition",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  OperateObject.attributeTypeMap;

    }

    public operateObjectType: string;
    public position: OperateObjectPosition;

    public constructor(init?: Partial< OperateObject >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class OperateParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "operateType",
            baseName: "OperateType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  OperateParameter.attributeTypeMap;

    }

    public operateType: string;

    public constructor(init?: Partial< OperateParameter >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class CellsObjectOperateTaskParameter  extends TaskParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "operateObject",
            baseName: "OperateObject",
            type: "OperateObject",
        },
        {
            name: "operateParameter",
            baseName: "OperateParameter",
            type: "OperateParameter",
        },
        {
            name: "destinationWorkbook",
            baseName: "DestinationWorkbook",
            type: "FileSource",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CellsObjectOperateTaskParameter.attributeTypeMap) ;

    }

    public operateObject: OperateObject;
    public operateParameter: OperateParameter;
    public destinationWorkbook: FileSource;

    public constructor(init?: Partial< CellsObjectOperateTaskParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents all save options   
export class SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "saveFormat",
            baseName: "SaveFormat",
            type: "string",
        },
        {
            name: "cachedFileFolder",
            baseName: "CachedFileFolder",
            type: "string",
        },
        {
            name: "clearData",
            baseName: "ClearData",
            type: "boolean",
        },
        {
            name: "createDirectory",
            baseName: "CreateDirectory",
            type: "boolean",
        },
        {
            name: "enableHTTPCompression",
            baseName: "EnableHTTPCompression",
            type: "boolean",
        },
        {
            name: "refreshChartCache",
            baseName: "RefreshChartCache",
            type: "boolean",
        },
        {
            name: "sortNames",
            baseName: "SortNames",
            type: "boolean",
        },
        {
            name: "validateMergedAreas",
            baseName: "ValidateMergedAreas",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  SaveOptions.attributeTypeMap;

    }

    public saveFormat: string;
    public cachedFileFolder: string;
    public clearData: boolean;
    public createDirectory: boolean;
    public enableHTTPCompression: boolean;
    public refreshChartCache: boolean;
    public sortNames: boolean;
    public validateMergedAreas: boolean;

    public constructor(init?: Partial< SaveOptions >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class ConvertTaskParameter  extends TaskParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "workbook",
            baseName: "Workbook",
            type: "FileSource",
        },
        {
            name: "destinationFile",
            baseName: "DestinationFile",
            type: "string",
        },
        {
            name: "saveOptions",
            baseName: "SaveOptions",
            type: "SaveOptions",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ConvertTaskParameter.attributeTypeMap) ;

    }

    public workbook: FileSource;
    public destinationFile: string;
    public saveOptions: SaveOptions;

    public constructor(init?: Partial< ConvertTaskParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ConvertWorksheetTaskParameter  extends TaskParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "workbook",
            baseName: "Workbook",
            type: "FileSource",
        },
        {
            name: "sheet",
            baseName: "Sheet",
            type: "string",
        },
        {
            name: "target",
            baseName: "Target",
            type: "FileSource",
        },
        {
            name: "format",
            baseName: "Format",
            type: "string",
        },
        {
            name: "area",
            baseName: "Area",
            type: "string",
        },
        {
            name: "pageIndex",
            baseName: "PageIndex",
            type: "number",
        },
        {
            name: "verticalResolution",
            baseName: "VerticalResolution",
            type: "number",
        },
        {
            name: "horizontalResolution",
            baseName: "HorizontalResolution",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ConvertWorksheetTaskParameter.attributeTypeMap) ;

    }

    public workbook: FileSource;
    public sheet: string;
    public target: FileSource;
    public format: string;
    public area: string;
    public pageIndex: number;
    public verticalResolution: number;
    public horizontalResolution: number;

    public constructor(init?: Partial< ConvertWorksheetTaskParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class ImportOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "destinationWorksheet",
            baseName: "DestinationWorksheet",
            type: "string",
        },
        {
            name: "isInsert",
            baseName: "IsInsert",
            type: "boolean",
        },
        {
            name: "importDataType",
            baseName: "ImportDataType",
            type: "string",
        },
        {
            name: "source",
            baseName: "Source",
            type: "FileSource",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ImportOption.attributeTypeMap;

    }

    public destinationWorksheet: string;
    public isInsert: boolean;
    public importDataType: string;
    public source: FileSource;

    public constructor(init?: Partial< ImportOption >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class ImportDataTaskParameter  extends TaskParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "workbook",
            baseName: "Workbook",
            type: "FileSource",
        },
        {
            name: "importOption",
            baseName: "ImportOption",
            type: "ImportOption",
        },
        {
            name: "destinationWorkbook",
            baseName: "DestinationWorkbook",
            type: "FileSource",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImportDataTaskParameter.attributeTypeMap) ;

    }

    public workbook: FileSource;
    public importOption: ImportOption;
    public destinationWorkbook: FileSource;

    public constructor(init?: Partial< ImportDataTaskParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ResultDestination  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "destinationType",
            baseName: "DestinationType",
            type: "string",
        },
        {
            name: "inputFile",
            baseName: "InputFile",
            type: "string",
        },
        {
            name: "outputFile",
            baseName: "OutputFile",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ResultDestination.attributeTypeMap;

    }

    public destinationType: string;
    public inputFile: string;
    public outputFile: string;

    public constructor(init?: Partial< ResultDestination >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class TaskRunResult  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "description",
            baseName: "Description",
            type: "string",
        },
        {
            name: "outFileList",
            baseName: "OutFileList",
            type: "Array<FileSource>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  TaskRunResult.attributeTypeMap;

    }

    public description: string;
    public outFileList: Array<FileSource>;

    public constructor(init?: Partial< TaskRunResult >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class SaveFilesToCloudResult  extends TaskRunResult  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "savedFiles",
            baseName: "SavedFiles",
            type: "Array<Link>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SaveFilesToCloudResult.attributeTypeMap) ;

    }

    public savedFiles: Array<Link>;

    public constructor(init?: Partial< SaveFilesToCloudResult >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class SaveResultTaskParameter  extends TaskParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "resultSource",
            baseName: "ResultSource",
            type: "string",
        },
        {
            name: "resultDestination",
            baseName: "ResultDestination",
            type: "ResultDestination",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SaveResultTaskParameter.attributeTypeMap) ;

    }

    public resultSource: string;
    public resultDestination: ResultDestination;

    public constructor(init?: Partial< SaveResultTaskParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class SmartMarkerTaskParameter  extends TaskParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sourceWorkbook",
            baseName: "SourceWorkbook",
            type: "FileSource",
        },
        {
            name: "destinationWorkbook",
            baseName: "DestinationWorkbook",
            type: "FileSource",
        },
        {
            name: "xmlFile",
            baseName: "xmlFile",
            type: "FileSource",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SmartMarkerTaskParameter.attributeTypeMap) ;

    }

    public sourceWorkbook: FileSource;
    public destinationWorkbook: FileSource;
    public xmlFile: FileSource;

    public constructor(init?: Partial< SmartMarkerTaskParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class SplitWorkbookTaskParameter  extends TaskParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "workbook",
            baseName: "Workbook",
            type: "FileSource",
        },
        {
            name: "destinationFilePosition",
            baseName: "DestinationFilePosition",
            type: "FileSource",
        },
        {
            name: "destinationFileFormat",
            baseName: "DestinationFileFormat",
            type: "string",
        },
        {
            name: "splitNameRule",
            baseName: "SplitNameRule",
            type: "string",
        },
        {
            name: "verticalResolution",
            baseName: "VerticalResolution",
            type: "number",
        },
        {
            name: "horizontalResolution",
            baseName: "HorizontalResolution",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SplitWorkbookTaskParameter.attributeTypeMap) ;

    }

    public workbook: FileSource;
    public destinationFilePosition: FileSource;
    public destinationFileFormat: string;
    public splitNameRule: string;
    public verticalResolution: number;
    public horizontalResolution: number;

    public constructor(init?: Partial< SplitWorkbookTaskParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class TaskDescription  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "taskType",
            baseName: "TaskType",
            type: "string",
        },
        {
            name: "taskParameter",
            baseName: "TaskParameter",
            type: "TaskParameter",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  TaskDescription.attributeTypeMap;

    }

    public taskType: string;
    public taskParameter: TaskParameter;

    public constructor(init?: Partial< TaskDescription >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class TaskData  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "tasks",
            baseName: "Tasks",
            type: "Array<TaskDescription>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  TaskData.attributeTypeMap;

    }

    public tasks: Array<TaskDescription>;

    public constructor(init?: Partial< TaskData >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class TaskResultParameter  extends TaskParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TaskResultParameter.attributeTypeMap) ;

    }


    public constructor(init?: Partial< TaskResultParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ChartOperateParameter  extends OperateParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "chartIndex",
            baseName: "ChartIndex",
            type: "number",
        },
        {
            name: "chartType",
            baseName: "ChartType",
            type: "string",
        },
        {
            name: "upperLeftRow",
            baseName: "UpperLeftRow",
            type: "number",
        },
        {
            name: "upperLeftColumn",
            baseName: "UpperLeftColumn",
            type: "number",
        },
        {
            name: "lowerRightRow",
            baseName: "LowerRightRow",
            type: "number",
        },
        {
            name: "lowerRightColumn",
            baseName: "LowerRightColumn",
            type: "number",
        },
        {
            name: "area",
            baseName: "Area",
            type: "string",
        },
        {
            name: "isVertical",
            baseName: "IsVertical",
            type: "boolean",
        },
        {
            name: "categoryData",
            baseName: "CategoryData",
            type: "string",
        },
        {
            name: "isAutoGetSerialName",
            baseName: "IsAutoGetSerialName",
            type: "boolean",
        },
        {
            name: "title",
            baseName: "Title",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartOperateParameter.attributeTypeMap) ;

    }

    public chartIndex: number;
    public chartType: string;
    public upperLeftRow: number;
    public upperLeftColumn: number;
    public lowerRightRow: number;
    public lowerRightColumn: number;
    public area: string;
    public isVertical: boolean;
    public categoryData: string;
    public isAutoGetSerialName: boolean;
    public title: string;

    public constructor(init?: Partial< ChartOperateParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class ListObject  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoFilter",
            baseName: "AutoFilter",
            type: "AutoFilter",
        },
        {
            name: "displayName",
            baseName: "DisplayName",
            type: "string",
        },
        {
            name: "startColumn",
            baseName: "StartColumn",
            type: "number",
        },
        {
            name: "startRow",
            baseName: "StartRow",
            type: "number",
        },
        {
            name: "endColumn",
            baseName: "EndColumn",
            type: "number",
        },
        {
            name: "endRow",
            baseName: "EndRow",
            type: "number",
        },
        {
            name: "listColumns",
            baseName: "ListColumns",
            type: "Array<ListColumn>",
        },
        {
            name: "showHeaderRow",
            baseName: "ShowHeaderRow",
            type: "boolean",
        },
        {
            name: "showTableStyleColumnStripes",
            baseName: "ShowTableStyleColumnStripes",
            type: "boolean",
        },
        {
            name: "showTableStyleFirstColumn",
            baseName: "ShowTableStyleFirstColumn",
            type: "boolean",
        },
        {
            name: "showTableStyleLastColumn",
            baseName: "ShowTableStyleLastColumn",
            type: "boolean",
        },
        {
            name: "showTableStyleRowStripes",
            baseName: "ShowTableStyleRowStripes",
            type: "boolean",
        },
        {
            name: "showTotals",
            baseName: "ShowTotals",
            type: "boolean",
        },
        {
            name: "tableStyleName",
            baseName: "TableStyleName",
            type: "string",
        },
        {
            name: "tableStyleType",
            baseName: "TableStyleType",
            type: "string",
        },
        {
            name: "dataRange",
            baseName: "DataRange",
            type: "Range",
        },
        {
            name: "dataSourceType",
            baseName: "DataSourceType",
            type: "string",
        },
        {
            name: "comment",
            baseName: "Comment",
            type: "string",
        },
        {
            name: "xmlMap",
            baseName: "XmlMap",
            type: "XmlMap",
        },
        {
            name: "alternativeText",
            baseName: "AlternativeText",
            type: "string",
        },
        {
            name: "alternativeDescription",
            baseName: "AlternativeDescription",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ListObject.attributeTypeMap) ;

    }

    public autoFilter: AutoFilter;
    public displayName: string;
    public startColumn: number;
    public startRow: number;
    public endColumn: number;
    public endRow: number;
    public listColumns: Array<ListColumn>;
    public showHeaderRow: boolean;
    public showTableStyleColumnStripes: boolean;
    public showTableStyleFirstColumn: boolean;
    public showTableStyleLastColumn: boolean;
    public showTableStyleRowStripes: boolean;
    public showTotals: boolean;
    public tableStyleName: string;
    public tableStyleType: string;
    public dataRange: Range;
    public dataSourceType: string;
    public comment: string;
    public xmlMap: XmlMap;
    public alternativeText: string;
    public alternativeDescription: string;

    public constructor(init?: Partial< ListObject >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ListObjectOperateParameter  extends OperateParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "listObject",
            baseName: "ListObject",
            type: "ListObject",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ListObjectOperateParameter.attributeTypeMap) ;

    }

    public listObject: ListObject;

    public constructor(init?: Partial< ListObjectOperateParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class OperateObjectPosition  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "workbook",
            baseName: "Workbook",
            type: "FileSource",
        },
        {
            name: "sheetName",
            baseName: "SheetName",
            type: "string",
        },
        {
            name: "chartIndex",
            baseName: "ChartIndex",
            type: "number",
        },
        {
            name: "shapeIndex",
            baseName: "ShapeIndex",
            type: "number",
        },
        {
            name: "cellName",
            baseName: "CellName",
            type: "string",
        },
        {
            name: "listObjectIndex",
            baseName: "ListObjectIndex",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  OperateObjectPosition.attributeTypeMap;

    }

    public workbook: FileSource;
    public sheetName: string;
    public chartIndex: number;
    public shapeIndex: number;
    public cellName: string;
    public listObjectIndex: number;

    public constructor(init?: Partial< OperateObjectPosition >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class PageBreakOperateParameter  extends OperateParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pageBreakType",
            baseName: "PageBreakType",
            type: "string",
        },
        {
            name: "index",
            baseName: "Index",
            type: "number",
        },
        {
            name: "row",
            baseName: "Row",
            type: "number",
        },
        {
            name: "column",
            baseName: "Column",
            type: "number",
        },
        {
            name: "startIndex",
            baseName: "StartIndex",
            type: "number",
        },
        {
            name: "endIndex",
            baseName: "EndIndex",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PageBreakOperateParameter.attributeTypeMap) ;

    }

    public pageBreakType: string;
    public index: number;
    public row: number;
    public column: number;
    public startIndex: number;
    public endIndex: number;

    public constructor(init?: Partial< PageBreakOperateParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class PageSetupOperateParameter  extends OperateParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pageSetup",
            baseName: "PageSetup",
            type: "PageSetup",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PageSetupOperateParameter.attributeTypeMap) ;

    }

    public pageSetup: PageSetup;

    public constructor(init?: Partial< PageSetupOperateParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class PivotTableOperateParameter  extends OperateParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sourceData",
            baseName: "SourceData",
            type: "string",
        },
        {
            name: "destCellName",
            baseName: "DestCellName",
            type: "string",
        },
        {
            name: "tableName",
            baseName: "TableName",
            type: "string",
        },
        {
            name: "useSameSource",
            baseName: "UseSameSource",
            type: "boolean",
        },
        {
            name: "pivotTableIndex",
            baseName: "PivotTableIndex",
            type: "number",
        },
        {
            name: "pivotFieldRows",
            baseName: "PivotFieldRows",
            type: "Array<number>",
        },
        {
            name: "pivotFieldColumns",
            baseName: "PivotFieldColumns",
            type: "Array<number>",
        },
        {
            name: "pivotFieldData",
            baseName: "PivotFieldData",
            type: "Array<number>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PivotTableOperateParameter.attributeTypeMap) ;

    }

    public sourceData: string;
    public destCellName: string;
    public tableName: string;
    public useSameSource: boolean;
    public pivotTableIndex: number;
    public pivotFieldRows: Array<number>;
    public pivotFieldColumns: Array<number>;
    public pivotFieldData: Array<number>;

    public constructor(init?: Partial< PivotTableOperateParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class Shape  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "msoDrawingType",
            baseName: "MsoDrawingType",
            type: "string",
        },
        {
            name: "autoShapeType",
            baseName: "AutoShapeType",
            type: "string",
        },
        {
            name: "placement",
            baseName: "Placement",
            type: "string",
        },
        {
            name: "upperLeftRow",
            baseName: "UpperLeftRow",
            type: "number",
        },
        {
            name: "top",
            baseName: "Top",
            type: "number",
        },
        {
            name: "upperLeftColumn",
            baseName: "UpperLeftColumn",
            type: "number",
        },
        {
            name: "left",
            baseName: "Left",
            type: "number",
        },
        {
            name: "lowerRightRow",
            baseName: "LowerRightRow",
            type: "number",
        },
        {
            name: "bottom",
            baseName: "Bottom",
            type: "number",
        },
        {
            name: "lowerRightColumn",
            baseName: "LowerRightColumn",
            type: "number",
        },
        {
            name: "right",
            baseName: "Right",
            type: "number",
        },
        {
            name: "width",
            baseName: "Width",
            type: "number",
        },
        {
            name: "height",
            baseName: "Height",
            type: "number",
        },
        {
            name: "x",
            baseName: "X",
            type: "number",
        },
        {
            name: "y",
            baseName: "Y",
            type: "number",
        },
        {
            name: "rotationAngle",
            baseName: "RotationAngle",
            type: "number",
        },
        {
            name: "htmlText",
            baseName: "HtmlText",
            type: "string",
        },
        {
            name: "text",
            baseName: "Text",
            type: "string",
        },
        {
            name: "alternativeText",
            baseName: "AlternativeText",
            type: "string",
        },
        {
            name: "textHorizontalAlignment",
            baseName: "TextHorizontalAlignment",
            type: "string",
        },
        {
            name: "textHorizontalOverflow",
            baseName: "TextHorizontalOverflow",
            type: "string",
        },
        {
            name: "textOrientationType",
            baseName: "TextOrientationType",
            type: "string",
        },
        {
            name: "textVerticalAlignment",
            baseName: "TextVerticalAlignment",
            type: "string",
        },
        {
            name: "textVerticalOverflow",
            baseName: "TextVerticalOverflow",
            type: "string",
        },
        {
            name: "isGroup",
            baseName: "IsGroup",
            type: "boolean",
        },
        {
            name: "isHidden",
            baseName: "IsHidden",
            type: "boolean",
        },
        {
            name: "isLockAspectRatio",
            baseName: "IsLockAspectRatio",
            type: "boolean",
        },
        {
            name: "isLocked",
            baseName: "IsLocked",
            type: "boolean",
        },
        {
            name: "isPrintable",
            baseName: "IsPrintable",
            type: "boolean",
        },
        {
            name: "isTextWrapped",
            baseName: "IsTextWrapped",
            type: "boolean",
        },
        {
            name: "isWordArt",
            baseName: "IsWordArt",
            type: "boolean",
        },
        {
            name: "linkedCell",
            baseName: "LinkedCell",
            type: "string",
        },
        {
            name: "zOrderPosition",
            baseName: "ZOrderPosition",
            type: "number",
        },
        {
            name: "font",
            baseName: "Font",
            type: "Font",
        },
        {
            name: "hyperlink",
            baseName: "Hyperlink",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Shape.attributeTypeMap) ;

    }

    public name: string;
    public msoDrawingType: string;
    public autoShapeType: string;
    public placement: string;
    public upperLeftRow: number;
    public top: number;
    public upperLeftColumn: number;
    public left: number;
    public lowerRightRow: number;
    public bottom: number;
    public lowerRightColumn: number;
    public right: number;
    public width: number;
    public height: number;
    public x: number;
    public y: number;
    public rotationAngle: number;
    public htmlText: string;
    public text: string;
    public alternativeText: string;
    public textHorizontalAlignment: string;
    public textHorizontalOverflow: string;
    public textOrientationType: string;
    public textVerticalAlignment: string;
    public textVerticalOverflow: string;
    public isGroup: boolean;
    public isHidden: boolean;
    public isLockAspectRatio: boolean;
    public isLocked: boolean;
    public isPrintable: boolean;
    public isTextWrapped: boolean;
    public isWordArt: boolean;
    public linkedCell: string;
    public zOrderPosition: number;
    public font: Font;
    public hyperlink: string;

    public constructor(init?: Partial< Shape >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ShapeOperateParameter  extends OperateParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "Shape",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ShapeOperateParameter.attributeTypeMap) ;

    }

    public shape: Shape;

    public constructor(init?: Partial< ShapeOperateParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class WorkbookOperateParameter  extends OperateParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WorkbookOperateParameter.attributeTypeMap) ;

    }


    public constructor(init?: Partial< WorkbookOperateParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class WorkbookSettingsOperateParameter  extends OperateParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "workbookSettings",
            baseName: "WorkbookSettings",
            type: "WorkbookSettings",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WorkbookSettingsOperateParameter.attributeTypeMap) ;

    }

    public workbookSettings: WorkbookSettings;

    public constructor(init?: Partial< WorkbookSettingsOperateParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Used by workbook moving requests.   
export class WorksheetMovingRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "destinationWorksheet",
            baseName: "DestinationWorksheet",
            type: "string",
        },
        {
            name: "position",
            baseName: "Position",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  WorksheetMovingRequest.attributeTypeMap;

    }

    public destinationWorksheet: string;
    public position: string;

    public constructor(init?: Partial< WorksheetMovingRequest >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class WorksheetOperateParameter  extends OperateParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "sheetType",
            baseName: "SheetType",
            type: "string",
        },
        {
            name: "newName",
            baseName: "NewName",
            type: "string",
        },
        {
            name: "movingRequest",
            baseName: "MovingRequest",
            type: "WorksheetMovingRequest",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WorksheetOperateParameter.attributeTypeMap) ;

    }

    public name: string;
    public sheetType: string;
    public newName: string;
    public movingRequest: WorksheetMovingRequest;

    public constructor(init?: Partial< WorksheetOperateParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class ListColumn  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "range",
            baseName: "Range",
            type: "Range",
        },
        {
            name: "totalsCalculation",
            baseName: "TotalsCalculation",
            type: "string",
        },
        {
            name: "formula",
            baseName: "Formula",
            type: "string",
        },
        {
            name: "totalsRowLabel",
            baseName: "TotalsRowLabel",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ListColumn.attributeTypeMap;

    }

    public name: string;
    public range: Range;
    public totalsCalculation: string;
    public formula: string;
    public totalsRowLabel: string;

    public constructor(init?: Partial< ListColumn >) {  
    
        Object.assign(this, init);
    } 
}
   
export class ListObjects  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "listObjectList",
            baseName: "ListObjectList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ListObjects.attributeTypeMap) ;

    }

    public listObjectList: Array<LinkElement>;

    public constructor(init?: Partial< ListObjects >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the options of saving dif file.   
export class DifSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DifSaveOptions.attributeTypeMap) ;

    }


    public constructor(init?: Partial< DifSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents options of saving .docx file.   
export class DocxSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DocxSaveOptions.attributeTypeMap) ;

    }


    public constructor(init?: Partial< DocxSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ImageOrPrintOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "textCrossType",
            baseName: "TextCrossType",
            type: "string",
        },
        {
            name: "gridlineType",
            baseName: "GridlineType",
            type: "string",
        },
        {
            name: "outputBlankPageWhenNothingToPrint",
            baseName: "OutputBlankPageWhenNothingToPrint",
            type: "boolean",
        },
        {
            name: "checkWorkbookDefaultFont",
            baseName: "CheckWorkbookDefaultFont",
            type: "boolean",
        },
        {
            name: "defaultFont",
            baseName: "DefaultFont",
            type: "string",
        },
        {
            name: "isOptimized",
            baseName: "IsOptimized",
            type: "boolean",
        },
        {
            name: "pageCount",
            baseName: "PageCount",
            type: "number",
        },
        {
            name: "pageIndex",
            baseName: "PageIndex",
            type: "number",
        },
        {
            name: "isFontSubstitutionCharGranularity",
            baseName: "IsFontSubstitutionCharGranularity",
            type: "boolean",
        },
        {
            name: "transparent",
            baseName: "Transparent",
            type: "boolean",
        },
        {
            name: "onlyArea",
            baseName: "OnlyArea",
            type: "boolean",
        },
        {
            name: "sVGFitToViewPort",
            baseName: "SVGFitToViewPort",
            type: "boolean",
        },
        {
            name: "embededImageNameInSvg",
            baseName: "EmbededImageNameInSvg",
            type: "string",
        },
        {
            name: "allColumnsInOnePagePerSheet",
            baseName: "AllColumnsInOnePagePerSheet",
            type: "boolean",
        },
        {
            name: "printWithStatusDialog",
            baseName: "PrintWithStatusDialog",
            type: "boolean",
        },
        {
            name: "horizontalResolution",
            baseName: "HorizontalResolution",
            type: "number",
        },
        {
            name: "verticalResolution",
            baseName: "VerticalResolution",
            type: "number",
        },
        {
            name: "defaultEditLanguage",
            baseName: "DefaultEditLanguage",
            type: "string",
        },
        {
            name: "tiffColorDepth",
            baseName: "TiffColorDepth",
            type: "string",
        },
        {
            name: "tiffCompression",
            baseName: "TiffCompression",
            type: "string",
        },
        {
            name: "printingPage",
            baseName: "PrintingPage",
            type: "string",
        },
        {
            name: "quality",
            baseName: "Quality",
            type: "number",
        },
        {
            name: "imageType",
            baseName: "ImageType",
            type: "string",
        },
        {
            name: "onePagePerSheet",
            baseName: "OnePagePerSheet",
            type: "boolean",
        },
        {
            name: "tiffBinarizationMethod",
            baseName: "TiffBinarizationMethod",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ImageOrPrintOptions.attributeTypeMap;

    }

    public textCrossType: string;
    public gridlineType: string;
    public outputBlankPageWhenNothingToPrint: boolean;
    public checkWorkbookDefaultFont: boolean;
    public defaultFont: string;
    public isOptimized: boolean;
    public pageCount: number;
    public pageIndex: number;
    public isFontSubstitutionCharGranularity: boolean;
    public transparent: boolean;
    public onlyArea: boolean;
    public sVGFitToViewPort: boolean;
    public embededImageNameInSvg: string;
    public allColumnsInOnePagePerSheet: boolean;
    public printWithStatusDialog: boolean;
    public horizontalResolution: number;
    public verticalResolution: number;
    public defaultEditLanguage: string;
    public tiffColorDepth: string;
    public tiffCompression: string;
    public printingPage: string;
    public quality: number;
    public imageType: string;
    public onePagePerSheet: boolean;
    public tiffBinarizationMethod: string;

    public constructor(init?: Partial< ImageOrPrintOptions >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents options of saving .html file.   
export class HtmlSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "exportPageHeaders",
            baseName: "ExportPageHeaders",
            type: "boolean",
        },
        {
            name: "exportPageFooters",
            baseName: "ExportPageFooters",
            type: "boolean",
        },
        {
            name: "exportRowColumnHeadings",
            baseName: "ExportRowColumnHeadings",
            type: "boolean",
        },
        {
            name: "showAllSheets",
            baseName: "ShowAllSheets",
            type: "boolean",
        },
        {
            name: "imageOptions",
            baseName: "ImageOptions",
            type: "ImageOrPrintOptions",
        },
        {
            name: "saveAsSingleFile",
            baseName: "SaveAsSingleFile",
            type: "boolean",
        },
        {
            name: "exportHiddenWorksheet",
            baseName: "ExportHiddenWorksheet",
            type: "boolean",
        },
        {
            name: "exportGridLines",
            baseName: "ExportGridLines",
            type: "boolean",
        },
        {
            name: "presentationPreference",
            baseName: "PresentationPreference",
            type: "boolean",
        },
        {
            name: "cellCssPrefix",
            baseName: "CellCssPrefix",
            type: "string",
        },
        {
            name: "tableCssId",
            baseName: "TableCssId",
            type: "string",
        },
        {
            name: "isFullPathLink",
            baseName: "IsFullPathLink",
            type: "boolean",
        },
        {
            name: "exportWorksheetCSSSeparately",
            baseName: "ExportWorksheetCSSSeparately",
            type: "boolean",
        },
        {
            name: "exportSimilarBorderStyle",
            baseName: "ExportSimilarBorderStyle",
            type: "boolean",
        },
        {
            name: "mergeEmptyTdForcely",
            baseName: "MergeEmptyTdForcely",
            type: "boolean",
        },
        {
            name: "exportCellCoordinate",
            baseName: "ExportCellCoordinate",
            type: "boolean",
        },
        {
            name: "exportExtraHeadings",
            baseName: "ExportExtraHeadings",
            type: "boolean",
        },
        {
            name: "exportHeadings",
            baseName: "ExportHeadings",
            type: "boolean",
        },
        {
            name: "exportFormula",
            baseName: "ExportFormula",
            type: "boolean",
        },
        {
            name: "addTooltipText",
            baseName: "AddTooltipText",
            type: "boolean",
        },
        {
            name: "exportBogusRowData",
            baseName: "ExportBogusRowData",
            type: "boolean",
        },
        {
            name: "excludeUnusedStyles",
            baseName: "ExcludeUnusedStyles",
            type: "boolean",
        },
        {
            name: "exportDocumentProperties",
            baseName: "ExportDocumentProperties",
            type: "boolean",
        },
        {
            name: "exportWorksheetProperties",
            baseName: "ExportWorksheetProperties",
            type: "boolean",
        },
        {
            name: "exportWorkbookProperties",
            baseName: "ExportWorkbookProperties",
            type: "boolean",
        },
        {
            name: "exportFrameScriptsAndProperties",
            baseName: "ExportFrameScriptsAndProperties",
            type: "boolean",
        },
        {
            name: "attachedFilesDirectory",
            baseName: "AttachedFilesDirectory",
            type: "string",
        },
        {
            name: "attachedFilesUrlPrefix",
            baseName: "AttachedFilesUrlPrefix",
            type: "string",
        },
        {
            name: "encoding",
            baseName: "Encoding",
            type: "string",
        },
        {
            name: "exportActiveWorksheetOnly",
            baseName: "ExportActiveWorksheetOnly",
            type: "boolean",
        },
        {
            name: "exportChartImageFormat",
            baseName: "ExportChartImageFormat",
            type: "string",
        },
        {
            name: "exportImagesAsBase64",
            baseName: "ExportImagesAsBase64",
            type: "boolean",
        },
        {
            name: "hiddenColDisplayType",
            baseName: "HiddenColDisplayType",
            type: "string",
        },
        {
            name: "hiddenRowDisplayType",
            baseName: "HiddenRowDisplayType",
            type: "string",
        },
        {
            name: "htmlCrossStringType",
            baseName: "HtmlCrossStringType",
            type: "string",
        },
        {
            name: "isExpImageToTempDir",
            baseName: "IsExpImageToTempDir",
            type: "boolean",
        },
        {
            name: "pageTitle",
            baseName: "PageTitle",
            type: "string",
        },
        {
            name: "parseHtmlTagInCell",
            baseName: "ParseHtmlTagInCell",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(HtmlSaveOptions.attributeTypeMap) ;

    }

    public exportPageHeaders: boolean;
    public exportPageFooters: boolean;
    public exportRowColumnHeadings: boolean;
    public showAllSheets: boolean;
    public imageOptions: ImageOrPrintOptions;
    public saveAsSingleFile: boolean;
    public exportHiddenWorksheet: boolean;
    public exportGridLines: boolean;
    public presentationPreference: boolean;
    public cellCssPrefix: string;
    public tableCssId: string;
    public isFullPathLink: boolean;
    public exportWorksheetCSSSeparately: boolean;
    public exportSimilarBorderStyle: boolean;
    public mergeEmptyTdForcely: boolean;
    public exportCellCoordinate: boolean;
    public exportExtraHeadings: boolean;
    public exportHeadings: boolean;
    public exportFormula: boolean;
    public addTooltipText: boolean;
    public exportBogusRowData: boolean;
    public excludeUnusedStyles: boolean;
    public exportDocumentProperties: boolean;
    public exportWorksheetProperties: boolean;
    public exportWorkbookProperties: boolean;
    public exportFrameScriptsAndProperties: boolean;
    public attachedFilesDirectory: string;
    public attachedFilesUrlPrefix: string;
    public encoding: string;
    public exportActiveWorksheetOnly: boolean;
    public exportChartImageFormat: string;
    public exportImagesAsBase64: boolean;
    public hiddenColDisplayType: string;
    public hiddenRowDisplayType: string;
    public htmlCrossStringType: string;
    public isExpImageToTempDir: boolean;
    public pageTitle: string;
    public parseHtmlTagInCell: boolean;

    public constructor(init?: Partial< HtmlSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents options of saving image file.   
export class ImageSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "chartImageType",
            baseName: "ChartImageType",
            type: "string",
        },
        {
            name: "embededImageNameInSvg",
            baseName: "EmbededImageNameInSvg",
            type: "string",
        },
        {
            name: "horizontalResolution",
            baseName: "HorizontalResolution",
            type: "number",
        },
        {
            name: "imageFormat",
            baseName: "ImageFormat",
            type: "string",
        },
        {
            name: "isCellAutoFit",
            baseName: "IsCellAutoFit",
            type: "boolean",
        },
        {
            name: "onePagePerSheet",
            baseName: "OnePagePerSheet",
            type: "boolean",
        },
        {
            name: "onlyArea",
            baseName: "OnlyArea",
            type: "boolean",
        },
        {
            name: "printingPage",
            baseName: "PrintingPage",
            type: "string",
        },
        {
            name: "printWithStatusDialog",
            baseName: "PrintWithStatusDialog",
            type: "boolean",
        },
        {
            name: "quality",
            baseName: "Quality",
            type: "number",
        },
        {
            name: "tiffCompression",
            baseName: "TiffCompression",
            type: "string",
        },
        {
            name: "verticalResolution",
            baseName: "VerticalResolution",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImageSaveOptions.attributeTypeMap) ;

    }

    public chartImageType: string;
    public embededImageNameInSvg: string;
    public horizontalResolution: number;
    public imageFormat: string;
    public isCellAutoFit: boolean;
    public onePagePerSheet: boolean;
    public onlyArea: boolean;
    public printingPage: string;
    public printWithStatusDialog: boolean;
    public quality: number;
    public tiffCompression: string;
    public verticalResolution: number;

    public constructor(init?: Partial< ImageSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents options of saving .json file.   
export class JsonSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "exportArea",
            baseName: "ExportArea",
            type: "CellArea",
        },
        {
            name: "hasHeaderRow",
            baseName: "HasHeaderRow",
            type: "boolean",
        },
        {
            name: "exportAsString",
            baseName: "ExportAsString",
            type: "boolean",
        },
        {
            name: "indent",
            baseName: "Indent",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(JsonSaveOptions.attributeTypeMap) ;

    }

    public exportArea: CellArea;
    public hasHeaderRow: boolean;
    public exportAsString: boolean;
    public indent: string;

    public constructor(init?: Partial< JsonSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents options of saving .md file.   
export class MarkdownSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "encoding",
            baseName: "Encoding",
            type: "string",
        },
        {
            name: "formatStrategy",
            baseName: "FormatStrategy",
            type: "string",
        },
        {
            name: "lineSeparator",
            baseName: "LineSeparator",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(MarkdownSaveOptions.attributeTypeMap) ;

    }

    public encoding: string;
    public formatStrategy: string;
    public lineSeparator: string;

    public constructor(init?: Partial< MarkdownSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents options of saving .mhtml file.   
export class MHtmlSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "attachedFilesDirectory",
            baseName: "AttachedFilesDirectory",
            type: "string",
        },
        {
            name: "attachedFilesUrlPrefix",
            baseName: "AttachedFilesUrlPrefix",
            type: "string",
        },
        {
            name: "encoding",
            baseName: "Encoding",
            type: "string",
        },
        {
            name: "exportActiveWorksheetOnly",
            baseName: "ExportActiveWorksheetOnly",
            type: "boolean",
        },
        {
            name: "exportChartImageFormat",
            baseName: "ExportChartImageFormat",
            type: "string",
        },
        {
            name: "exportImagesAsBase64",
            baseName: "ExportImagesAsBase64",
            type: "boolean",
        },
        {
            name: "hiddenColDisplayType",
            baseName: "HiddenColDisplayType",
            type: "string",
        },
        {
            name: "hiddenRowDisplayType",
            baseName: "HiddenRowDisplayType",
            type: "string",
        },
        {
            name: "htmlCrossStringType",
            baseName: "HtmlCrossStringType",
            type: "string",
        },
        {
            name: "isExpImageToTempDir",
            baseName: "IsExpImageToTempDir",
            type: "boolean",
        },
        {
            name: "pageTitle",
            baseName: "PageTitle",
            type: "string",
        },
        {
            name: "parseHtmlTagInCell",
            baseName: "ParseHtmlTagInCell",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(MHtmlSaveOptions.attributeTypeMap) ;

    }

    public attachedFilesDirectory: string;
    public attachedFilesUrlPrefix: string;
    public encoding: string;
    public exportActiveWorksheetOnly: boolean;
    public exportChartImageFormat: string;
    public exportImagesAsBase64: boolean;
    public hiddenColDisplayType: string;
    public hiddenRowDisplayType: string;
    public htmlCrossStringType: string;
    public isExpImageToTempDir: boolean;
    public pageTitle: string;
    public parseHtmlTagInCell: boolean;

    public constructor(init?: Partial< MHtmlSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents options of saving .ods file.   
export class OdsSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(OdsSaveOptions.attributeTypeMap) ;

    }


    public constructor(init?: Partial< OdsSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents options of saving ooxml file.   
export class OoxmlSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "exportCellName",
            baseName: "ExportCellName",
            type: "boolean",
        },
        {
            name: "updateZoom",
            baseName: "UpdateZoom",
            type: "boolean",
        },
        {
            name: "enableZip64",
            baseName: "EnableZip64",
            type: "boolean",
        },
        {
            name: "embedOoxmlAsOleObject",
            baseName: "EmbedOoxmlAsOleObject",
            type: "boolean",
        },
        {
            name: "compressionType",
            baseName: "CompressionType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(OoxmlSaveOptions.attributeTypeMap) ;

    }

    public exportCellName: boolean;
    public updateZoom: boolean;
    public enableZip64: boolean;
    public embedOoxmlAsOleObject: boolean;
    public compressionType: string;

    public constructor(init?: Partial< OoxmlSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class RenderingWatermark  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "rotation",
            baseName: "Rotation",
            type: "number",
        },
        {
            name: "scaleToPagePercent",
            baseName: "ScaleToPagePercent",
            type: "number",
        },
        {
            name: "opacity",
            baseName: "Opacity",
            type: "number",
        },
        {
            name: "isBackground",
            baseName: "IsBackground",
            type: "boolean",
        },
        {
            name: "text",
            baseName: "Text",
            type: "string",
        },
        {
            name: "font",
            baseName: "Font",
            type: "RenderingFont",
        },
        {
            name: "image",
            baseName: "Image",
            type: "Array<number>",
        },
        {
            name: "hAlignment",
            baseName: "HAlignment",
            type: "string",
        },
        {
            name: "vAlignment",
            baseName: "VAlignment",
            type: "string",
        },
        {
            name: "offsetX",
            baseName: "OffsetX",
            type: "number",
        },
        {
            name: "offsetY",
            baseName: "OffsetY",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  RenderingWatermark.attributeTypeMap;

    }

    public rotation: number;
    public scaleToPagePercent: number;
    public opacity: number;
    public isBackground: boolean;
    public text: string;
    public font: RenderingFont;
    public image: Array<number>;
    public hAlignment: string;
    public vAlignment: string;
    public offsetX: number;
    public offsetY: number;

    public constructor(init?: Partial< RenderingWatermark >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents options of saving pdf file.   
export class PdfSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "displayDocTitle",
            baseName: "DisplayDocTitle",
            type: "boolean",
        },
        {
            name: "exportDocumentStructure",
            baseName: "ExportDocumentStructure",
            type: "boolean",
        },
        {
            name: "emfRenderSetting",
            baseName: "EmfRenderSetting",
            type: "string",
        },
        {
            name: "customPropertiesExport",
            baseName: "CustomPropertiesExport",
            type: "string",
        },
        {
            name: "optimizationType",
            baseName: "OptimizationType",
            type: "string",
        },
        {
            name: "producer",
            baseName: "Producer",
            type: "string",
        },
        {
            name: "pdfCompression",
            baseName: "PdfCompression",
            type: "string",
        },
        {
            name: "fontEncoding",
            baseName: "FontEncoding",
            type: "string",
        },
        {
            name: "watermark",
            baseName: "Watermark",
            type: "RenderingWatermark",
        },
        {
            name: "calculateFormula",
            baseName: "CalculateFormula",
            type: "boolean",
        },
        {
            name: "checkFontCompatibility",
            baseName: "CheckFontCompatibility",
            type: "boolean",
        },
        {
            name: "compliance",
            baseName: "Compliance",
            type: "string",
        },
        {
            name: "defaultFont",
            baseName: "DefaultFont",
            type: "string",
        },
        {
            name: "onePagePerSheet",
            baseName: "OnePagePerSheet",
            type: "boolean",
        },
        {
            name: "printingPageType",
            baseName: "PrintingPageType",
            type: "string",
        },
        {
            name: "securityOptions",
            baseName: "SecurityOptions",
            type: "PdfSecurityOptions",
        },
        {
            name: "desiredPPI",
            baseName: "desiredPPI",
            type: "number",
        },
        {
            name: "jpegQuality",
            baseName: "jpegQuality",
            type: "number",
        },
        {
            name: "imageType",
            baseName: "ImageType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PdfSaveOptions.attributeTypeMap) ;

    }

    public displayDocTitle: boolean;
    public exportDocumentStructure: boolean;
    public emfRenderSetting: string;
    public customPropertiesExport: string;
    public optimizationType: string;
    public producer: string;
    public pdfCompression: string;
    public fontEncoding: string;
    public watermark: RenderingWatermark;
    public calculateFormula: boolean;
    public checkFontCompatibility: boolean;
    public compliance: string;
    public defaultFont: string;
    public onePagePerSheet: boolean;
    public printingPageType: string;
    public securityOptions: PdfSecurityOptions;
    public desiredPPI: number;
    public jpegQuality: number;
    public imageType: string;

    public constructor(init?: Partial< PdfSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the options of saving pptx file.   
export class PptxSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PptxSaveOptions.attributeTypeMap) ;

    }


    public constructor(init?: Partial< PptxSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the options of saving .xml file.   
export class SpreadsheetML2003SaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "exportColumnIndexOfCell",
            baseName: "ExportColumnIndexOfCell",
            type: "boolean",
        },
        {
            name: "isIndentedFormatting",
            baseName: "IsIndentedFormatting",
            type: "boolean",
        },
        {
            name: "limitAsXls",
            baseName: "LimitAsXls",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SpreadsheetML2003SaveOptions.attributeTypeMap) ;

    }

    public exportColumnIndexOfCell: boolean;
    public isIndentedFormatting: boolean;
    public limitAsXls: boolean;

    public constructor(init?: Partial< SpreadsheetML2003SaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the options of saving .sql file.   
export class SqlScriptSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "checkIfTableExists",
            baseName: "CheckIfTableExists",
            type: "boolean",
        },
        {
            name: "columnTypeMap",
            baseName: "ColumnTypeMap",
            type: "string",
        },
        {
            name: "checkAllDataForColumnType",
            baseName: "CheckAllDataForColumnType",
            type: "boolean",
        },
        {
            name: "addBlankLineBetweenRows",
            baseName: "AddBlankLineBetweenRows",
            type: "boolean",
        },
        {
            name: "separator",
            baseName: "Separator",
            type: "string",
        },
        {
            name: "operatorType",
            baseName: "OperatorType",
            type: "string",
        },
        {
            name: "primaryKey",
            baseName: "PrimaryKey",
            type: "number",
        },
        {
            name: "createTable",
            baseName: "CreateTable",
            type: "boolean",
        },
        {
            name: "idName",
            baseName: "IdName",
            type: "string",
        },
        {
            name: "startId",
            baseName: "StartId",
            type: "number",
        },
        {
            name: "tableName",
            baseName: "TableName",
            type: "string",
        },
        {
            name: "exportAsString",
            baseName: "ExportAsString",
            type: "boolean",
        },
        {
            name: "exportArea",
            baseName: "ExportArea",
            type: "CellArea",
        },
        {
            name: "hasHeaderRow",
            baseName: "HasHeaderRow",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SqlScriptSaveOptions.attributeTypeMap) ;

    }

    public checkIfTableExists: boolean;
    public columnTypeMap: string;
    public checkAllDataForColumnType: boolean;
    public addBlankLineBetweenRows: boolean;
    public separator: string;
    public operatorType: string;
    public primaryKey: number;
    public createTable: boolean;
    public idName: string;
    public startId: number;
    public tableName: string;
    public exportAsString: boolean;
    public exportArea: CellArea;
    public hasHeaderRow: boolean;

    public constructor(init?: Partial< SqlScriptSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the options of saving .svg file.   
export class SvgSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sheetIndex",
            baseName: "SheetIndex",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SvgSaveOptions.attributeTypeMap) ;

    }

    public sheetIndex: number;

    public constructor(init?: Partial< SvgSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the options of saving .txt file.   
export class TxtSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "quoteType",
            baseName: "QuoteType",
            type: "string",
        },
        {
            name: "separator",
            baseName: "Separator",
            type: "string",
        },
        {
            name: "separatorString",
            baseName: "SeparatorString",
            type: "string",
        },
        {
            name: "alwaysQuoted",
            baseName: "AlwaysQuoted",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TxtSaveOptions.attributeTypeMap) ;

    }

    public quoteType: string;
    public separator: string;
    public separatorString: string;
    public alwaysQuoted: boolean;

    public constructor(init?: Partial< TxtSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the options of saving .xlsb file.   
export class XlsbSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(XlsbSaveOptions.attributeTypeMap) ;

    }


    public constructor(init?: Partial< XlsbSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the options of saving .xls file.   
export class XlsSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(XlsSaveOptions.attributeTypeMap) ;

    }


    public constructor(init?: Partial< XlsSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the options of saving .xps file.   
export class XpsSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(XpsSaveOptions.attributeTypeMap) ;

    }


    public constructor(init?: Partial< XpsSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "code",
            baseName: "Code",
            type: "number",
        },
        {
            name: "status",
            baseName: "Status",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CellsCloudResponse.attributeTypeMap;

    }

    public code: number;
    public status: string;

    public constructor(init?: Partial< CellsCloudResponse >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class ArcShape  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "beginArrowheadLength",
            baseName: "BeginArrowheadLength",
            type: "string",
        },
        {
            name: "beginArrowheadStyle",
            baseName: "BeginArrowheadStyle",
            type: "string",
        },
        {
            name: "beginArrowheadWidth",
            baseName: "BeginArrowheadWidth",
            type: "string",
        },
        {
            name: "endArrowheadLength",
            baseName: "EndArrowheadLength",
            type: "string",
        },
        {
            name: "endArrowheadStyle",
            baseName: "EndArrowheadStyle",
            type: "string",
        },
        {
            name: "endArrowheadWidth",
            baseName: "EndArrowheadWidth",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ArcShape.attributeTypeMap) ;

    }

    public beginArrowheadLength: string;
    public beginArrowheadStyle: string;
    public beginArrowheadWidth: string;
    public endArrowheadLength: string;
    public endArrowheadStyle: string;
    public endArrowheadWidth: string;

    public constructor(init?: Partial< ArcShape >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ArcShapeResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "ArcShape",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ArcShapeResponse.attributeTypeMap) ;

    }

    public shape: ArcShape;

    public constructor(init?: Partial< ArcShapeResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class AutoFilterResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoFilter",
            baseName: "AutoFilter",
            type: "AutoFilter",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(AutoFilterResponse.attributeTypeMap) ;

    }

    public autoFilter: AutoFilter;

    public constructor(init?: Partial< AutoFilterResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class AutoShape  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(AutoShape.attributeTypeMap) ;

    }


    public constructor(init?: Partial< AutoShape >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class AutoShapeResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoShape",
            baseName: "AutoShape",
            type: "AutoShape",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(AutoShapeResponse.attributeTypeMap) ;

    }

    public autoShape: AutoShape;

    public constructor(init?: Partial< AutoShapeResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class AutoShapes  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoShapeList",
            baseName: "AutoShapeList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(AutoShapes.attributeTypeMap) ;

    }

    public autoShapeList: Array<LinkElement>;

    public constructor(init?: Partial< AutoShapes >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class AutoShapesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoShapes",
            baseName: "AutoShapes",
            type: "AutoShapes",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(AutoShapesResponse.attributeTypeMap) ;

    }

    public autoShapes: AutoShapes;

    public constructor(init?: Partial< AutoShapesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class Axis  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "area",
            baseName: "Area",
            type: "Area",
        },
        {
            name: "axisBetweenCategories",
            baseName: "AxisBetweenCategories",
            type: "boolean",
        },
        {
            name: "axisLine",
            baseName: "AxisLine",
            type: "Line",
        },
        {
            name: "baseUnitScale",
            baseName: "BaseUnitScale",
            type: "string",
        },
        {
            name: "categoryType",
            baseName: "CategoryType",
            type: "string",
        },
        {
            name: "crossAt",
            baseName: "CrossAt",
            type: "number",
        },
        {
            name: "crossType",
            baseName: "CrossType",
            type: "string",
        },
        {
            name: "displayUnit",
            baseName: "DisplayUnit",
            type: "string",
        },
        {
            name: "displayUnitLabel",
            baseName: "DisplayUnitLabel",
            type: "LinkElement",
        },
        {
            name: "hasMultiLevelLabels",
            baseName: "HasMultiLevelLabels",
            type: "boolean",
        },
        {
            name: "isAutomaticMajorUnit",
            baseName: "IsAutomaticMajorUnit",
            type: "boolean",
        },
        {
            name: "isAutomaticMaxValue",
            baseName: "IsAutomaticMaxValue",
            type: "boolean",
        },
        {
            name: "isAutomaticMinorUnit",
            baseName: "IsAutomaticMinorUnit",
            type: "boolean",
        },
        {
            name: "isAutomaticMinValue",
            baseName: "IsAutomaticMinValue",
            type: "boolean",
        },
        {
            name: "isDisplayUnitLabelShown",
            baseName: "IsDisplayUnitLabelShown",
            type: "boolean",
        },
        {
            name: "isLogarithmic",
            baseName: "IsLogarithmic",
            type: "boolean",
        },
        {
            name: "isPlotOrderReversed",
            baseName: "IsPlotOrderReversed",
            type: "boolean",
        },
        {
            name: "isVisible",
            baseName: "IsVisible",
            type: "boolean",
        },
        {
            name: "logBase",
            baseName: "LogBase",
            type: "number",
        },
        {
            name: "majorGridLines",
            baseName: "MajorGridLines",
            type: "Line",
        },
        {
            name: "majorTickMark",
            baseName: "MajorTickMark",
            type: "string",
        },
        {
            name: "majorUnit",
            baseName: "MajorUnit",
            type: "number",
        },
        {
            name: "majorUnitScale",
            baseName: "MajorUnitScale",
            type: "string",
        },
        {
            name: "maxValue",
            baseName: "MaxValue",
            type: "number",
        },
        {
            name: "minorGridLines",
            baseName: "MinorGridLines",
            type: "Line",
        },
        {
            name: "minorTickMark",
            baseName: "MinorTickMark",
            type: "string",
        },
        {
            name: "minorUnit",
            baseName: "MinorUnit",
            type: "number",
        },
        {
            name: "minorUnitScale",
            baseName: "MinorUnitScale",
            type: "string",
        },
        {
            name: "minValue",
            baseName: "MinValue",
            type: "number",
        },
        {
            name: "tickLabelPosition",
            baseName: "TickLabelPosition",
            type: "string",
        },
        {
            name: "tickLabels",
            baseName: "TickLabels",
            type: "TickLabels",
        },
        {
            name: "tickLabelSpacing",
            baseName: "TickLabelSpacing",
            type: "number",
        },
        {
            name: "tickMarkSpacing",
            baseName: "TickMarkSpacing",
            type: "number",
        },
        {
            name: "title",
            baseName: "Title",
            type: "Title",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Axis.attributeTypeMap) ;

    }

    public area: Area;
    public axisBetweenCategories: boolean;
    public axisLine: Line;
    public baseUnitScale: string;
    public categoryType: string;
    public crossAt: number;
    public crossType: string;
    public displayUnit: string;
    public displayUnitLabel: LinkElement;
    public hasMultiLevelLabels: boolean;
    public isAutomaticMajorUnit: boolean;
    public isAutomaticMaxValue: boolean;
    public isAutomaticMinorUnit: boolean;
    public isAutomaticMinValue: boolean;
    public isDisplayUnitLabelShown: boolean;
    public isLogarithmic: boolean;
    public isPlotOrderReversed: boolean;
    public isVisible: boolean;
    public logBase: number;
    public majorGridLines: Line;
    public majorTickMark: string;
    public majorUnit: number;
    public majorUnitScale: string;
    public maxValue: number;
    public minorGridLines: Line;
    public minorTickMark: string;
    public minorUnit: number;
    public minorUnitScale: string;
    public minValue: number;
    public tickLabelPosition: string;
    public tickLabels: TickLabels;
    public tickLabelSpacing: number;
    public tickMarkSpacing: number;
    public title: Title;

    public constructor(init?: Partial< Axis >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class AxisResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "axis",
            baseName: "Axis",
            type: "Axis",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(AxisResponse.attributeTypeMap) ;

    }

    public axis: Axis;

    public constructor(init?: Partial< AxisResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class BarcodeResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "barcodeValue",
            baseName: "BarcodeValue",
            type: "string",
        },
        {
            name: "barcodeType",
            baseName: "BarcodeType",
            type: "string",
        },
        {
            name: "region",
            baseName: "Region",
            type: "Array<Point>",
        },
        {
            name: "checksum",
            baseName: "Checksum",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  BarcodeResponse.attributeTypeMap;

    }

    public barcodeValue: string;
    public barcodeType: string;
    public region: Array<Point>;
    public checksum: string;

    public constructor(init?: Partial< BarcodeResponse >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class BarcodeResponseList  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  BarcodeResponseList.attributeTypeMap;

    }


    public constructor(init?: Partial< BarcodeResponseList >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class BorderResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "border",
            baseName: "Border",
            type: "Border",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(BorderResponse.attributeTypeMap) ;

    }

    public border: Border;

    public constructor(init?: Partial< BorderResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class Button  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Button.attributeTypeMap) ;

    }


    public constructor(init?: Partial< Button >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ButtonResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "Button",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ButtonResponse.attributeTypeMap) ;

    }

    public shape: Button;

    public constructor(init?: Partial< ButtonResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class CalculateFormulaResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "result",
            baseName: "Result",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CalculateFormulaResponse.attributeTypeMap) ;

    }

    public result: string;

    public constructor(init?: Partial< CalculateFormulaResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class CellResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "cell",
            baseName: "Cell",
            type: "Cell",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CellResponse.attributeTypeMap) ;

    }

    public cell: Cell;

    public constructor(init?: Partial< CellResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class CellsCloudFileInfoResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "fileInfo",
            baseName: "FileInfo",
            type: "CellsCloudFileInfo",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CellsCloudFileInfoResponse.attributeTypeMap) ;

    }

    public fileInfo: CellsCloudFileInfo;

    public constructor(init?: Partial< CellsCloudFileInfoResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class CellsDocumentPropertiesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "documentProperties",
            baseName: "DocumentProperties",
            type: "CellsDocumentProperties",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CellsDocumentPropertiesResponse.attributeTypeMap) ;

    }

    public documentProperties: CellsDocumentProperties;

    public constructor(init?: Partial< CellsDocumentPropertiesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class CellsDocumentPropertyResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "documentProperty",
            baseName: "DocumentProperty",
            type: "CellsDocumentProperty",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CellsDocumentPropertyResponse.attributeTypeMap) ;

    }

    public documentProperty: CellsDocumentProperty;

    public constructor(init?: Partial< CellsDocumentPropertyResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class CellsDrawing  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CellsDrawing.attributeTypeMap) ;

    }


    public constructor(init?: Partial< CellsDrawing >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class CellsDrawingResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "CellsDrawing",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CellsDrawingResponse.attributeTypeMap) ;

    }

    public shape: CellsDrawing;

    public constructor(init?: Partial< CellsDrawingResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class CellsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "cells",
            baseName: "Cells",
            type: "Cells",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CellsResponse.attributeTypeMap) ;

    }

    public cells: Cells;

    public constructor(init?: Partial< CellsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class ChartFrame  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "area",
            baseName: "Area",
            type: "Area",
        },
        {
            name: "autoScaleFont",
            baseName: "AutoScaleFont",
            type: "boolean",
        },
        {
            name: "backgroundMode",
            baseName: "BackgroundMode",
            type: "string",
        },
        {
            name: "border",
            baseName: "Border",
            type: "Line",
        },
        {
            name: "font",
            baseName: "Font",
            type: "Font",
        },
        {
            name: "isAutomaticSize",
            baseName: "IsAutomaticSize",
            type: "boolean",
        },
        {
            name: "isInnerMode",
            baseName: "IsInnerMode",
            type: "boolean",
        },
        {
            name: "shadow",
            baseName: "Shadow",
            type: "boolean",
        },
        {
            name: "shapeProperties",
            baseName: "ShapeProperties",
            type: "Array<LinkElement>",
        },
        {
            name: "width",
            baseName: "Width",
            type: "number",
        },
        {
            name: "height",
            baseName: "Height",
            type: "number",
        },
        {
            name: "x",
            baseName: "X",
            type: "number",
        },
        {
            name: "y",
            baseName: "Y",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ChartFrame.attributeTypeMap;

    }

    public area: Area;
    public autoScaleFont: boolean;
    public backgroundMode: string;
    public border: Line;
    public font: Font;
    public isAutomaticSize: boolean;
    public isInnerMode: boolean;
    public shadow: boolean;
    public shapeProperties: Array<LinkElement>;
    public width: number;
    public height: number;
    public x: number;
    public y: number;

    public constructor(init?: Partial< ChartFrame >) {  
    
        Object.assign(this, init);
    } 
}
   
export class ChartArea  extends ChartFrame  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartArea.attributeTypeMap) ;

    }


    public constructor(init?: Partial< ChartArea >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class ChartAreaResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "chartArea",
            baseName: "ChartArea",
            type: "ChartArea",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartAreaResponse.attributeTypeMap) ;

    }

    public chartArea: ChartArea;

    public constructor(init?: Partial< ChartAreaResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ChartDataTable  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoScaleFont",
            baseName: "AutoScaleFont",
            type: "boolean",
        },
        {
            name: "backgroundMode",
            baseName: "BackgroundMode",
            type: "string",
        },
        {
            name: "border",
            baseName: "Border",
            type: "Line",
        },
        {
            name: "font",
            baseName: "Font",
            type: "Font",
        },
        {
            name: "hasBorderHorizontal",
            baseName: "HasBorderHorizontal",
            type: "boolean",
        },
        {
            name: "hasBorderOutline",
            baseName: "HasBorderOutline",
            type: "boolean",
        },
        {
            name: "hasBorderVertical",
            baseName: "HasBorderVertical",
            type: "boolean",
        },
        {
            name: "showLegendKey",
            baseName: "ShowLegendKey",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartDataTable.attributeTypeMap) ;

    }

    public autoScaleFont: boolean;
    public backgroundMode: string;
    public border: Line;
    public font: Font;
    public hasBorderHorizontal: boolean;
    public hasBorderOutline: boolean;
    public hasBorderVertical: boolean;
    public showLegendKey: boolean;

    public constructor(init?: Partial< ChartDataTable >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ChartDataTableResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "chartDataTable",
            baseName: "ChartDataTable",
            type: "ChartDataTable",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartDataTableResponse.attributeTypeMap) ;

    }

    public chartDataTable: ChartDataTable;

    public constructor(init?: Partial< ChartDataTableResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ChartPoint  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "area",
            baseName: "Area",
            type: "Area",
        },
        {
            name: "border",
            baseName: "Border",
            type: "Line",
        },
        {
            name: "dataLabels",
            baseName: "DataLabels",
            type: "DataLabels",
        },
        {
            name: "explosion",
            baseName: "Explosion",
            type: "number",
        },
        {
            name: "marker",
            baseName: "Marker",
            type: "Marker",
        },
        {
            name: "shadow",
            baseName: "Shadow",
            type: "boolean",
        },
        {
            name: "xValue",
            baseName: "XValue",
            type: "string",
        },
        {
            name: "yValue",
            baseName: "YValue",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartPoint.attributeTypeMap) ;

    }

    public area: Area;
    public border: Line;
    public dataLabels: DataLabels;
    public explosion: number;
    public marker: Marker;
    public shadow: boolean;
    public xValue: string;
    public yValue: string;

    public constructor(init?: Partial< ChartPoint >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ChartPointResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "chartPoint",
            baseName: "ChartPoint",
            type: "ChartPoint",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartPointResponse.attributeTypeMap) ;

    }

    public chartPoint: ChartPoint;

    public constructor(init?: Partial< ChartPointResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ChartPoints  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "chartPointList",
            baseName: "ChartPointList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartPoints.attributeTypeMap) ;

    }

    public chartPointList: Array<LinkElement>;

    public constructor(init?: Partial< ChartPoints >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ChartPointsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "chartPoints",
            baseName: "ChartPoints",
            type: "ChartPoints",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartPointsResponse.attributeTypeMap) ;

    }

    public chartPoints: ChartPoints;

    public constructor(init?: Partial< ChartPointsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class Chart  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoScaling",
            baseName: "AutoScaling",
            type: "boolean",
        },
        {
            name: "backWall",
            baseName: "BackWall",
            type: "LinkElement",
        },
        {
            name: "categoryAxis",
            baseName: "CategoryAxis",
            type: "LinkElement",
        },
        {
            name: "chartArea",
            baseName: "ChartArea",
            type: "LinkElement",
        },
        {
            name: "chartDataTable",
            baseName: "ChartDataTable",
            type: "LinkElement",
        },
        {
            name: "chartObject",
            baseName: "ChartObject",
            type: "LinkElement",
        },
        {
            name: "depthPercent",
            baseName: "DepthPercent",
            type: "number",
        },
        {
            name: "elevation",
            baseName: "Elevation",
            type: "number",
        },
        {
            name: "firstSliceAngle",
            baseName: "FirstSliceAngle",
            type: "number",
        },
        {
            name: "floor",
            baseName: "Floor",
            type: "LinkElement",
        },
        {
            name: "gapDepth",
            baseName: "GapDepth",
            type: "number",
        },
        {
            name: "gapWidth",
            baseName: "GapWidth",
            type: "number",
        },
        {
            name: "heightPercent",
            baseName: "HeightPercent",
            type: "number",
        },
        {
            name: "hidePivotFieldButtons",
            baseName: "HidePivotFieldButtons",
            type: "boolean",
        },
        {
            name: "is3D",
            baseName: "Is3D",
            type: "boolean",
        },
        {
            name: "isRectangularCornered",
            baseName: "IsRectangularCornered",
            type: "boolean",
        },
        {
            name: "legend",
            baseName: "Legend",
            type: "LinkElement",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "nSeries",
            baseName: "NSeries",
            type: "LinkElement",
        },
        {
            name: "pageSetup",
            baseName: "PageSetup",
            type: "LinkElement",
        },
        {
            name: "perspective",
            baseName: "Perspective",
            type: "number",
        },
        {
            name: "pivotSource",
            baseName: "PivotSource",
            type: "string",
        },
        {
            name: "placement",
            baseName: "Placement",
            type: "string",
        },
        {
            name: "plotArea",
            baseName: "PlotArea",
            type: "LinkElement",
        },
        {
            name: "plotEmptyCellsType",
            baseName: "PlotEmptyCellsType",
            type: "string",
        },
        {
            name: "plotVisibleCells",
            baseName: "PlotVisibleCells",
            type: "boolean",
        },
        {
            name: "printSize",
            baseName: "PrintSize",
            type: "string",
        },
        {
            name: "rightAngleAxes",
            baseName: "RightAngleAxes",
            type: "boolean",
        },
        {
            name: "rotationAngle",
            baseName: "RotationAngle",
            type: "number",
        },
        {
            name: "secondCategoryAxis",
            baseName: "SecondCategoryAxis",
            type: "LinkElement",
        },
        {
            name: "secondValueAxis",
            baseName: "SecondValueAxis",
            type: "LinkElement",
        },
        {
            name: "seriesAxis",
            baseName: "SeriesAxis",
            type: "LinkElement",
        },
        {
            name: "shapes",
            baseName: "Shapes",
            type: "LinkElement",
        },
        {
            name: "showDataTable",
            baseName: "ShowDataTable",
            type: "boolean",
        },
        {
            name: "showLegend",
            baseName: "ShowLegend",
            type: "boolean",
        },
        {
            name: "sideWall",
            baseName: "SideWall",
            type: "LinkElement",
        },
        {
            name: "sizeWithWindow",
            baseName: "SizeWithWindow",
            type: "boolean",
        },
        {
            name: "style",
            baseName: "Style",
            type: "number",
        },
        {
            name: "title",
            baseName: "Title",
            type: "LinkElement",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "valueAxis",
            baseName: "ValueAxis",
            type: "LinkElement",
        },
        {
            name: "walls",
            baseName: "Walls",
            type: "LinkElement",
        },
        {
            name: "wallsAndGridlines2D",
            baseName: "WallsAndGridlines2D",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Chart.attributeTypeMap) ;

    }

    public autoScaling: boolean;
    public backWall: LinkElement;
    public categoryAxis: LinkElement;
    public chartArea: LinkElement;
    public chartDataTable: LinkElement;
    public chartObject: LinkElement;
    public depthPercent: number;
    public elevation: number;
    public firstSliceAngle: number;
    public floor: LinkElement;
    public gapDepth: number;
    public gapWidth: number;
    public heightPercent: number;
    public hidePivotFieldButtons: boolean;
    public is3D: boolean;
    public isRectangularCornered: boolean;
    public legend: LinkElement;
    public name: string;
    public nSeries: LinkElement;
    public pageSetup: LinkElement;
    public perspective: number;
    public pivotSource: string;
    public placement: string;
    public plotArea: LinkElement;
    public plotEmptyCellsType: string;
    public plotVisibleCells: boolean;
    public printSize: string;
    public rightAngleAxes: boolean;
    public rotationAngle: number;
    public secondCategoryAxis: LinkElement;
    public secondValueAxis: LinkElement;
    public seriesAxis: LinkElement;
    public shapes: LinkElement;
    public showDataTable: boolean;
    public showLegend: boolean;
    public sideWall: LinkElement;
    public sizeWithWindow: boolean;
    public style: number;
    public title: LinkElement;
    public type: string;
    public valueAxis: LinkElement;
    public walls: LinkElement;
    public wallsAndGridlines2D: boolean;

    public constructor(init?: Partial< Chart >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ChartResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "chart",
            baseName: "Chart",
            type: "Chart",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartResponse.attributeTypeMap) ;

    }

    public chart: Chart;

    public constructor(init?: Partial< ChartResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class Charts  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "chartList",
            baseName: "ChartList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Charts.attributeTypeMap) ;

    }

    public chartList: Array<LinkElement>;

    public constructor(init?: Partial< Charts >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class ChartsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "charts",
            baseName: "Charts",
            type: "Charts",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartsResponse.attributeTypeMap) ;

    }

    public charts: Charts;

    public constructor(init?: Partial< ChartsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class CheckBox  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "checkedValue",
            baseName: "CheckedValue",
            type: "string",
        },
        {
            name: "shadow",
            baseName: "Shadow",
            type: "boolean",
        },
        {
            name: "value",
            baseName: "Value",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CheckBox.attributeTypeMap) ;

    }

    public checkedValue: string;
    public shadow: boolean;
    public value: boolean;

    public constructor(init?: Partial< CheckBox >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class CheckBoxResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "CheckBox",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CheckBoxResponse.attributeTypeMap) ;

    }

    public shape: CheckBox;

    public constructor(init?: Partial< CheckBoxResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class ColumnResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "column",
            baseName: "Column",
            type: "Column",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ColumnResponse.attributeTypeMap) ;

    }

    public column: Column;

    public constructor(init?: Partial< ColumnResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class ColumnsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "columns",
            baseName: "Columns",
            type: "Columns",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ColumnsResponse.attributeTypeMap) ;

    }

    public columns: Columns;

    public constructor(init?: Partial< ColumnsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ComboBox  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dropDownLines",
            baseName: "DropDownLines",
            type: "number",
        },
        {
            name: "inputRange",
            baseName: "InputRange",
            type: "string",
        },
        {
            name: "selectedCell",
            baseName: "SelectedCell",
            type: "LinkElement",
        },
        {
            name: "selectedIndex",
            baseName: "SelectedIndex",
            type: "number",
        },
        {
            name: "selectedValue",
            baseName: "SelectedValue",
            type: "string",
        },
        {
            name: "shadow",
            baseName: "Shadow",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ComboBox.attributeTypeMap) ;

    }

    public dropDownLines: number;
    public inputRange: string;
    public selectedCell: LinkElement;
    public selectedIndex: number;
    public selectedValue: string;
    public shadow: boolean;

    public constructor(init?: Partial< ComboBox >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ComboBoxResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "ComboBox",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ComboBoxResponse.attributeTypeMap) ;

    }

    public shape: ComboBox;

    public constructor(init?: Partial< ComboBoxResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class CommentResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "comment",
            baseName: "Comment",
            type: "Comment",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CommentResponse.attributeTypeMap) ;

    }

    public comment: Comment;

    public constructor(init?: Partial< CommentResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class CommentShape  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "comment",
            baseName: "Comment",
            type: "LinkElement",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CommentShape.attributeTypeMap) ;

    }

    public comment: LinkElement;

    public constructor(init?: Partial< CommentShape >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class CommentShapeResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "comment",
            baseName: "Comment",
            type: "CommentShape",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CommentShapeResponse.attributeTypeMap) ;

    }

    public comment: CommentShape;

    public constructor(init?: Partial< CommentShapeResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class CommentsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "comments",
            baseName: "Comments",
            type: "Comments",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CommentsResponse.attributeTypeMap) ;

    }

    public comments: Comments;

    public constructor(init?: Partial< CommentsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class ConditionalFormattingResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "conditionalFormatting",
            baseName: "ConditionalFormatting",
            type: "ConditionalFormatting",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ConditionalFormattingResponse.attributeTypeMap) ;

    }

    public conditionalFormatting: ConditionalFormatting;

    public constructor(init?: Partial< ConditionalFormattingResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class ConditionalFormattingsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "conditionalFormattings",
            baseName: "ConditionalFormattings",
            type: "ConditionalFormattings",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ConditionalFormattingsResponse.attributeTypeMap) ;

    }

    public conditionalFormattings: ConditionalFormattings;

    public constructor(init?: Partial< ConditionalFormattingsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class DataLabels  extends ChartFrame  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "isAutoText",
            baseName: "IsAutoText",
            type: "boolean",
        },
        {
            name: "isDeleted",
            baseName: "IsDeleted",
            type: "boolean",
        },
        {
            name: "linkedSource",
            baseName: "LinkedSource",
            type: "string",
        },
        {
            name: "number",
            baseName: "Number",
            type: "number",
        },
        {
            name: "numberFormat",
            baseName: "NumberFormat",
            type: "string",
        },
        {
            name: "numberFormatLinked",
            baseName: "NumberFormatLinked",
            type: "boolean",
        },
        {
            name: "position",
            baseName: "Position",
            type: "string",
        },
        {
            name: "rotationAngle",
            baseName: "RotationAngle",
            type: "number",
        },
        {
            name: "separator",
            baseName: "Separator",
            type: "string",
        },
        {
            name: "showBubbleSize",
            baseName: "ShowBubbleSize",
            type: "boolean",
        },
        {
            name: "showCategoryName",
            baseName: "ShowCategoryName",
            type: "boolean",
        },
        {
            name: "showLegendKey",
            baseName: "ShowLegendKey",
            type: "boolean",
        },
        {
            name: "showPercentage",
            baseName: "ShowPercentage",
            type: "boolean",
        },
        {
            name: "showSeriesName",
            baseName: "ShowSeriesName",
            type: "boolean",
        },
        {
            name: "showValue",
            baseName: "ShowValue",
            type: "boolean",
        },
        {
            name: "text",
            baseName: "Text",
            type: "string",
        },
        {
            name: "textDirection",
            baseName: "TextDirection",
            type: "string",
        },
        {
            name: "textHorizontalAlignment",
            baseName: "TextHorizontalAlignment",
            type: "string",
        },
        {
            name: "textVerticalAlignment",
            baseName: "TextVerticalAlignment",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DataLabels.attributeTypeMap) ;

    }

    public isAutoText: boolean;
    public isDeleted: boolean;
    public linkedSource: string;
    public number: number;
    public numberFormat: string;
    public numberFormatLinked: boolean;
    public position: string;
    public rotationAngle: number;
    public separator: string;
    public showBubbleSize: boolean;
    public showCategoryName: boolean;
    public showLegendKey: boolean;
    public showPercentage: boolean;
    public showSeriesName: boolean;
    public showValue: boolean;
    public text: string;
    public textDirection: string;
    public textHorizontalAlignment: string;
    public textVerticalAlignment: string;

    public constructor(init?: Partial< DataLabels >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class DataLabelsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataLabels",
            baseName: "DataLabels",
            type: "DataLabels",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DataLabelsResponse.attributeTypeMap) ;

    }

    public dataLabels: DataLabels;

    public constructor(init?: Partial< DataLabelsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class DisplayUnitLabel  extends ChartFrame  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "linkedSource",
            baseName: "LinkedSource",
            type: "string",
        },
        {
            name: "rotationAngle",
            baseName: "RotationAngle",
            type: "number",
        },
        {
            name: "text",
            baseName: "Text",
            type: "string",
        },
        {
            name: "textDirection",
            baseName: "TextDirection",
            type: "string",
        },
        {
            name: "textHorizontalAlignment",
            baseName: "TextHorizontalAlignment",
            type: "string",
        },
        {
            name: "textVerticalAlignment",
            baseName: "TextVerticalAlignment",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DisplayUnitLabel.attributeTypeMap) ;

    }

    public linkedSource: string;
    public rotationAngle: number;
    public text: string;
    public textDirection: string;
    public textHorizontalAlignment: string;
    public textVerticalAlignment: string;

    public constructor(init?: Partial< DisplayUnitLabel >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class DisplayUnitLabelResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "displayUnitLabel",
            baseName: "DisplayUnitLabel",
            type: "DisplayUnitLabel",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DisplayUnitLabelResponse.attributeTypeMap) ;

    }

    public displayUnitLabel: DisplayUnitLabel;

    public constructor(init?: Partial< DisplayUnitLabelResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class DropBars  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "area",
            baseName: "Area",
            type: "Area",
        },
        {
            name: "border",
            baseName: "Border",
            type: "Line",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DropBars.attributeTypeMap) ;

    }

    public area: Area;
    public border: Line;

    public constructor(init?: Partial< DropBars >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class DropBarsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dropBars",
            baseName: "DropBars",
            type: "DropBars",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DropBarsResponse.attributeTypeMap) ;

    }

    public dropBars: DropBars;

    public constructor(init?: Partial< DropBarsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates the object that represents the line format.   
export class Line  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "beginArrowLength",
            baseName: "BeginArrowLength",
            type: "string",
        },
        {
            name: "beginArrowWidth",
            baseName: "BeginArrowWidth",
            type: "string",
        },
        {
            name: "beginType",
            baseName: "BeginType",
            type: "string",
        },
        {
            name: "capType",
            baseName: "CapType",
            type: "string",
        },
        {
            name: "color",
            baseName: "Color",
            type: "Color",
        },
        {
            name: "compoundType",
            baseName: "CompoundType",
            type: "string",
        },
        {
            name: "dashType",
            baseName: "DashType",
            type: "string",
        },
        {
            name: "endArrowLength",
            baseName: "EndArrowLength",
            type: "string",
        },
        {
            name: "endArrowWidth",
            baseName: "EndArrowWidth",
            type: "string",
        },
        {
            name: "endType",
            baseName: "EndType",
            type: "string",
        },
        {
            name: "gradientFill",
            baseName: "GradientFill",
            type: "GradientFill",
        },
        {
            name: "isAuto",
            baseName: "IsAuto",
            type: "boolean",
        },
        {
            name: "isAutomaticColor",
            baseName: "IsAutomaticColor",
            type: "boolean",
        },
        {
            name: "isVisible",
            baseName: "IsVisible",
            type: "boolean",
        },
        {
            name: "joinType",
            baseName: "JoinType",
            type: "string",
        },
        {
            name: "style",
            baseName: "Style",
            type: "string",
        },
        {
            name: "transparency",
            baseName: "Transparency",
            type: "number",
        },
        {
            name: "weight",
            baseName: "Weight",
            type: "string",
        },
        {
            name: "weightPt",
            baseName: "WeightPt",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Line.attributeTypeMap;

    }

    public beginArrowLength: string;
    public beginArrowWidth: string;
    public beginType: string;
    public capType: string;
    public color: Color;
    public compoundType: string;
    public dashType: string;
    public endArrowLength: string;
    public endArrowWidth: string;
    public endType: string;
    public gradientFill: GradientFill;
    public isAuto: boolean;
    public isAutomaticColor: boolean;
    public isVisible: boolean;
    public joinType: string;
    public style: string;
    public transparency: number;
    public weight: string;
    public weightPt: number;

    public constructor(init?: Partial< Line >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class ErrorBar  extends Line  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "link",
            baseName: "Link",
            type: "Link",
        },
        {
            name: "amount",
            baseName: "Amount",
            type: "number",
        },
        {
            name: "displayType",
            baseName: "DisplayType",
            type: "string",
        },
        {
            name: "minusValue",
            baseName: "MinusValue",
            type: "string",
        },
        {
            name: "plusValue",
            baseName: "PlusValue",
            type: "string",
        },
        {
            name: "showMarkerTTop",
            baseName: "ShowMarkerTTop",
            type: "boolean",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ErrorBar.attributeTypeMap) ;

    }

    public link: Link;
    public amount: number;
    public displayType: string;
    public minusValue: string;
    public plusValue: string;
    public showMarkerTTop: boolean;
    public type: string;

    public constructor(init?: Partial< ErrorBar >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ErrorBarResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "errorBar",
            baseName: "ErrorBar",
            type: "ErrorBar",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ErrorBarResponse.attributeTypeMap) ;

    }

    public errorBar: ErrorBar;

    public constructor(init?: Partial< ErrorBarResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class FillFormatResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "fillFormat",
            baseName: "FillFormat",
            type: "FillFormat",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FillFormatResponse.attributeTypeMap) ;

    }

    public fillFormat: FillFormat;

    public constructor(init?: Partial< FillFormatResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class FindResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "count",
            baseName: "Count",
            type: "number",
        },
        {
            name: "textItems",
            baseName: "TextItems",
            type: "TextItems",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FindResponse.attributeTypeMap) ;

    }

    public count: number;
    public textItems: TextItems;

    public constructor(init?: Partial< FindResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class Area  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "backgroundColor",
            baseName: "BackgroundColor",
            type: "Color",
        },
        {
            name: "fillFormat",
            baseName: "FillFormat",
            type: "FillFormat",
        },
        {
            name: "foregroundColor",
            baseName: "ForegroundColor",
            type: "Color",
        },
        {
            name: "format",
            baseName: "Format",
            type: "string",
        },
        {
            name: "invertIfNegative",
            baseName: "InvertIfNegative",
            type: "boolean",
        },
        {
            name: "transparency",
            baseName: "Transparency",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Area.attributeTypeMap;

    }

    public backgroundColor: Color;
    public fillFormat: FillFormat;
    public foregroundColor: Color;
    public format: string;
    public invertIfNegative: boolean;
    public transparency: number;

    public constructor(init?: Partial< Area >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class Floor  extends Area  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "border",
            baseName: "Border",
            type: "Line",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Floor.attributeTypeMap) ;

    }

    public border: Line;

    public constructor(init?: Partial< Floor >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class FloorResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "floor",
            baseName: "Floor",
            type: "Floor",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FloorResponse.attributeTypeMap) ;

    }

    public floor: Floor;

    public constructor(init?: Partial< FloorResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class Form  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "formType",
            baseName: "FormType",
            type: "string",
        },
        {
            name: "checkedValue",
            baseName: "CheckedValue",
            type: "string",
        },
        {
            name: "shadow",
            baseName: "Shadow",
            type: "boolean",
        },
        {
            name: "inputRange",
            baseName: "InputRange",
            type: "string",
        },
        {
            name: "selectedIndex",
            baseName: "SelectedIndex",
            type: "number",
        },
        {
            name: "selectedValue",
            baseName: "SelectedValue",
            type: "string",
        },
        {
            name: "selectedCell",
            baseName: "SelectedCell",
            type: "LinkElement",
        },
        {
            name: "dropDownLines",
            baseName: "DropDownLines",
            type: "number",
        },
        {
            name: "itemCount",
            baseName: "ItemCount",
            type: "number",
        },
        {
            name: "selectedCells",
            baseName: "SelectedCells",
            type: "Array<LinkElement>",
        },
        {
            name: "selectionType",
            baseName: "SelectionType",
            type: "string",
        },
        {
            name: "isChecked",
            baseName: "IsChecked",
            type: "boolean",
        },
        {
            name: "currentValue",
            baseName: "CurrentValue",
            type: "number",
        },
        {
            name: "min",
            baseName: "Min",
            type: "number",
        },
        {
            name: "max",
            baseName: "Max",
            type: "number",
        },
        {
            name: "incrementalChange",
            baseName: "IncrementalChange",
            type: "number",
        },
        {
            name: "pageChange",
            baseName: "PageChange",
            type: "number",
        },
        {
            name: "isHorizontal",
            baseName: "IsHorizontal",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Form.attributeTypeMap) ;

    }

    public formType: string;
    public checkedValue: string;
    public shadow: boolean;
    public inputRange: string;
    public selectedIndex: number;
    public selectedValue: string;
    public selectedCell: LinkElement;
    public dropDownLines: number;
    public itemCount: number;
    public selectedCells: Array<LinkElement>;
    public selectionType: string;
    public isChecked: boolean;
    public currentValue: number;
    public min: number;
    public max: number;
    public incrementalChange: number;
    public pageChange: number;
    public isHorizontal: boolean;

    public constructor(init?: Partial< Form >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class FormResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "form",
            baseName: "Form",
            type: "Form",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FormResponse.attributeTypeMap) ;

    }

    public form: Form;

    public constructor(init?: Partial< FormResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class Forms  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "formList",
            baseName: "FormList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Forms.attributeTypeMap) ;

    }

    public formList: Array<LinkElement>;

    public constructor(init?: Partial< Forms >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class FormsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "forms",
            baseName: "Forms",
            type: "Forms",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FormsResponse.attributeTypeMap) ;

    }

    public forms: Forms;

    public constructor(init?: Partial< FormsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class GroupBox  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shadow",
            baseName: "Shadow",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(GroupBox.attributeTypeMap) ;

    }

    public shadow: boolean;

    public constructor(init?: Partial< GroupBox >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class GroupBoxResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "GroupBox",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(GroupBoxResponse.attributeTypeMap) ;

    }

    public shape: GroupBox;

    public constructor(init?: Partial< GroupBoxResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class HorizontalPageBreakResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "horizontalPageBreak",
            baseName: "HorizontalPageBreak",
            type: "HorizontalPageBreak",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(HorizontalPageBreakResponse.attributeTypeMap) ;

    }

    public horizontalPageBreak: HorizontalPageBreak;

    public constructor(init?: Partial< HorizontalPageBreakResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class HorizontalPageBreaksResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "horizontalPageBreaks",
            baseName: "HorizontalPageBreaks",
            type: "HorizontalPageBreaks",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(HorizontalPageBreaksResponse.attributeTypeMap) ;

    }

    public horizontalPageBreaks: HorizontalPageBreaks;

    public constructor(init?: Partial< HorizontalPageBreaksResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class HyperlinkResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "hyperlink",
            baseName: "Hyperlink",
            type: "Hyperlink",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(HyperlinkResponse.attributeTypeMap) ;

    }

    public hyperlink: Hyperlink;

    public constructor(init?: Partial< HyperlinkResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class HyperlinksResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "hyperlinks",
            baseName: "Hyperlinks",
            type: "Hyperlinks",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(HyperlinksResponse.attributeTypeMap) ;

    }

    public hyperlinks: Hyperlinks;

    public constructor(init?: Partial< HyperlinksResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class Label  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Label.attributeTypeMap) ;

    }


    public constructor(init?: Partial< Label >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class LabelResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "Label",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LabelResponse.attributeTypeMap) ;

    }

    public shape: Label;

    public constructor(init?: Partial< LabelResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class LegendEntries  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "legendEntryList",
            baseName: "legendEntryList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LegendEntries.attributeTypeMap) ;

    }

    public legendEntryList: Array<LinkElement>;

    public constructor(init?: Partial< LegendEntries >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class LegendEntriesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "legendEntries",
            baseName: "LegendEntries",
            type: "LegendEntries",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LegendEntriesResponse.attributeTypeMap) ;

    }

    public legendEntries: LegendEntries;

    public constructor(init?: Partial< LegendEntriesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class LegendEntry  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoScaleFont",
            baseName: "AutoScaleFont",
            type: "string",
        },
        {
            name: "backgroundMode",
            baseName: "BackgroundMode",
            type: "string",
        },
        {
            name: "font",
            baseName: "Font",
            type: "Font",
        },
        {
            name: "isDeleted",
            baseName: "IsDeleted",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LegendEntry.attributeTypeMap) ;

    }

    public autoScaleFont: string;
    public backgroundMode: string;
    public font: Font;
    public isDeleted: string;

    public constructor(init?: Partial< LegendEntry >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class LegendEntryResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "legendEntry",
            baseName: "LegendEntry",
            type: "LegendEntry",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LegendEntryResponse.attributeTypeMap) ;

    }

    public legendEntry: LegendEntry;

    public constructor(init?: Partial< LegendEntryResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class Legend  extends ChartFrame  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "position",
            baseName: "Position",
            type: "string",
        },
        {
            name: "legendEntries",
            baseName: "LegendEntries",
            type: "LinkElement",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Legend.attributeTypeMap) ;

    }

    public position: string;
    public legendEntries: LinkElement;

    public constructor(init?: Partial< Legend >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class LegendResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "legend",
            baseName: "Legend",
            type: "Legend",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LegendResponse.attributeTypeMap) ;

    }

    public legend: Legend;

    public constructor(init?: Partial< LegendResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class LineResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "line",
            baseName: "Line",
            type: "Line",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LineResponse.attributeTypeMap) ;

    }

    public line: Line;

    public constructor(init?: Partial< LineResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class LineShape  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "beginArrowheadLength",
            baseName: "BeginArrowheadLength",
            type: "string",
        },
        {
            name: "beginArrowheadStyle",
            baseName: "BeginArrowheadStyle",
            type: "string",
        },
        {
            name: "beginArrowheadWidth",
            baseName: "BeginArrowheadWidth",
            type: "string",
        },
        {
            name: "endArrowheadLength",
            baseName: "EndArrowheadLength",
            type: "string",
        },
        {
            name: "endArrowheadStyle",
            baseName: "EndArrowheadStyle",
            type: "string",
        },
        {
            name: "endArrowheadWidth",
            baseName: "EndArrowheadWidth",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LineShape.attributeTypeMap) ;

    }

    public beginArrowheadLength: string;
    public beginArrowheadStyle: string;
    public beginArrowheadWidth: string;
    public endArrowheadLength: string;
    public endArrowheadStyle: string;
    public endArrowheadWidth: string;

    public constructor(init?: Partial< LineShape >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class LineShapeResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "LineShape",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LineShapeResponse.attributeTypeMap) ;

    }

    public shape: LineShape;

    public constructor(init?: Partial< LineShapeResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ListBox  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "inputRange",
            baseName: "InputRange",
            type: "string",
        },
        {
            name: "itemCount",
            baseName: "ItemCount",
            type: "number",
        },
        {
            name: "pageChange",
            baseName: "PageChange",
            type: "number",
        },
        {
            name: "selectedCells",
            baseName: "SelectedCells",
            type: "Array<LinkElement>",
        },
        {
            name: "selectedIndex",
            baseName: "SelectedIndex",
            type: "number",
        },
        {
            name: "selectionType",
            baseName: "SelectionType",
            type: "string",
        },
        {
            name: "shadow",
            baseName: "Shadow",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ListBox.attributeTypeMap) ;

    }

    public inputRange: string;
    public itemCount: number;
    public pageChange: number;
    public selectedCells: Array<LinkElement>;
    public selectedIndex: number;
    public selectionType: string;
    public shadow: boolean;

    public constructor(init?: Partial< ListBox >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ListBoxResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "ListBox",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ListBoxResponse.attributeTypeMap) ;

    }

    public shape: ListBox;

    public constructor(init?: Partial< ListBoxResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ListObjectResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "listObject",
            baseName: "ListObject",
            type: "ListObject",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ListObjectResponse.attributeTypeMap) ;

    }

    public listObject: ListObject;

    public constructor(init?: Partial< ListObjectResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class ListObjectsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "listObjects",
            baseName: "ListObjects",
            type: "ListObjects",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ListObjectsResponse.attributeTypeMap) ;

    }

    public listObjects: ListObjects;

    public constructor(init?: Partial< ListObjectsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class MergedCellResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "mergedCell",
            baseName: "MergedCell",
            type: "MergedCell",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(MergedCellResponse.attributeTypeMap) ;

    }

    public mergedCell: MergedCell;

    public constructor(init?: Partial< MergedCellResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class MergedCellsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "mergedCells",
            baseName: "MergedCells",
            type: "MergedCells",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(MergedCellsResponse.attributeTypeMap) ;

    }

    public mergedCells: MergedCells;

    public constructor(init?: Partial< MergedCellsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class NameResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "Name",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(NameResponse.attributeTypeMap) ;

    }

    public name: Name;

    public constructor(init?: Partial< NameResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class NamesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "names",
            baseName: "Names",
            type: "Names",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(NamesResponse.attributeTypeMap) ;

    }

    public names: Names;

    public constructor(init?: Partial< NamesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class OleObject  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "displayAsIcon",
            baseName: "DisplayAsIcon",
            type: "boolean",
        },
        {
            name: "fileFormatType",
            baseName: "FileFormatType",
            type: "string",
        },
        {
            name: "imageSourceFullName",
            baseName: "ImageSourceFullName",
            type: "string",
        },
        {
            name: "isAutoSize",
            baseName: "IsAutoSize",
            type: "boolean",
        },
        {
            name: "isLink",
            baseName: "IsLink",
            type: "boolean",
        },
        {
            name: "progID",
            baseName: "ProgID",
            type: "string",
        },
        {
            name: "sourceFullName",
            baseName: "SourceFullName",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(OleObject.attributeTypeMap) ;

    }

    public displayAsIcon: boolean;
    public fileFormatType: string;
    public imageSourceFullName: string;
    public isAutoSize: boolean;
    public isLink: boolean;
    public progID: string;
    public sourceFullName: string;

    public constructor(init?: Partial< OleObject >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class OleObjectResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "oleObject",
            baseName: "OleObject",
            type: "OleObject",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(OleObjectResponse.attributeTypeMap) ;

    }

    public oleObject: OleObject;

    public constructor(init?: Partial< OleObjectResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class OleObjects  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "oleObjectList",
            baseName: "OleObjectList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(OleObjects.attributeTypeMap) ;

    }

    public oleObjectList: Array<LinkElement>;

    public constructor(init?: Partial< OleObjects >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class OleObjectsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "oleObjects",
            baseName: "OleObjects",
            type: "OleObjects",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(OleObjectsResponse.attributeTypeMap) ;

    }

    public oleObjects: OleObjects;

    public constructor(init?: Partial< OleObjectsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class Oval  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Oval.attributeTypeMap) ;

    }


    public constructor(init?: Partial< Oval >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class OvalResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "Oval",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(OvalResponse.attributeTypeMap) ;

    }

    public shape: Oval;

    public constructor(init?: Partial< OvalResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class PageSectionsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pageSections",
            baseName: "PageSections",
            type: "Array<PageSection>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PageSectionsResponse.attributeTypeMap) ;

    }

    public pageSections: Array<PageSection>;

    public constructor(init?: Partial< PageSectionsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class PageSetupResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pageSetup",
            baseName: "PageSetup",
            type: "PageSetup",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PageSetupResponse.attributeTypeMap) ;

    }

    public pageSetup: PageSetup;

    public constructor(init?: Partial< PageSetupResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class Picture  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "borderLineColor",
            baseName: "BorderLineColor",
            type: "Color",
        },
        {
            name: "borderWeight",
            baseName: "BorderWeight",
            type: "number",
        },
        {
            name: "originalHeight",
            baseName: "OriginalHeight",
            type: "number",
        },
        {
            name: "originalWidth",
            baseName: "OriginalWidth",
            type: "number",
        },
        {
            name: "imageFormat",
            baseName: "ImageFormat",
            type: "string",
        },
        {
            name: "sourceFullName",
            baseName: "SourceFullName",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Picture.attributeTypeMap) ;

    }

    public borderLineColor: Color;
    public borderWeight: number;
    public originalHeight: number;
    public originalWidth: number;
    public imageFormat: string;
    public sourceFullName: string;

    public constructor(init?: Partial< Picture >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class PictureResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "picture",
            baseName: "Picture",
            type: "Picture",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PictureResponse.attributeTypeMap) ;

    }

    public picture: Picture;

    public constructor(init?: Partial< PictureResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class Pictures  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pictureList",
            baseName: "PictureList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Pictures.attributeTypeMap) ;

    }

    public pictureList: Array<LinkElement>;

    public constructor(init?: Partial< Pictures >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class PicturesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pictures",
            baseName: "Pictures",
            type: "Pictures",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PicturesResponse.attributeTypeMap) ;

    }

    public pictures: Pictures;

    public constructor(init?: Partial< PicturesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class PivotField  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoShowCount",
            baseName: "AutoShowCount",
            type: "number",
        },
        {
            name: "autoShowField",
            baseName: "AutoShowField",
            type: "number",
        },
        {
            name: "autoSortField",
            baseName: "AutoSortField",
            type: "number",
        },
        {
            name: "baseField",
            baseName: "BaseField",
            type: "number",
        },
        {
            name: "baseIndex",
            baseName: "BaseIndex",
            type: "number",
        },
        {
            name: "baseItem",
            baseName: "BaseItem",
            type: "number",
        },
        {
            name: "baseItemPosition",
            baseName: "BaseItemPosition",
            type: "string",
        },
        {
            name: "currentPageItem",
            baseName: "CurrentPageItem",
            type: "number",
        },
        {
            name: "dataDisplayFormat",
            baseName: "DataDisplayFormat",
            type: "string",
        },
        {
            name: "displayName",
            baseName: "DisplayName",
            type: "string",
        },
        {
            name: "dragToColumn",
            baseName: "DragToColumn",
            type: "boolean",
        },
        {
            name: "dragToData",
            baseName: "DragToData",
            type: "boolean",
        },
        {
            name: "dragToHide",
            baseName: "DragToHide",
            type: "boolean",
        },
        {
            name: "dragToPage",
            baseName: "DragToPage",
            type: "boolean",
        },
        {
            name: "dragToRow",
            baseName: "DragToRow",
            type: "boolean",
        },
        {
            name: "function",
            baseName: "Function",
            type: "string",
        },
        {
            name: "insertBlankRow",
            baseName: "InsertBlankRow",
            type: "boolean",
        },
        {
            name: "isAscendShow",
            baseName: "IsAscendShow",
            type: "boolean",
        },
        {
            name: "isAscendSort",
            baseName: "IsAscendSort",
            type: "boolean",
        },
        {
            name: "isAutoShow",
            baseName: "IsAutoShow",
            type: "boolean",
        },
        {
            name: "isAutoSort",
            baseName: "IsAutoSort",
            type: "boolean",
        },
        {
            name: "isAutoSubtotals",
            baseName: "IsAutoSubtotals",
            type: "boolean",
        },
        {
            name: "isCalculatedField",
            baseName: "IsCalculatedField",
            type: "boolean",
        },
        {
            name: "isIncludeNewItemsInFilter",
            baseName: "IsIncludeNewItemsInFilter",
            type: "boolean",
        },
        {
            name: "isInsertPageBreaksBetweenItems",
            baseName: "IsInsertPageBreaksBetweenItems",
            type: "boolean",
        },
        {
            name: "isMultipleItemSelectionAllowed",
            baseName: "IsMultipleItemSelectionAllowed",
            type: "boolean",
        },
        {
            name: "isRepeatItemLabels",
            baseName: "IsRepeatItemLabels",
            type: "boolean",
        },
        {
            name: "itemCount",
            baseName: "ItemCount",
            type: "number",
        },
        {
            name: "items",
            baseName: "Items",
            type: "Array<string>",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "number",
            baseName: "Number",
            type: "number",
        },
        {
            name: "numberFormat",
            baseName: "NumberFormat",
            type: "string",
        },
        {
            name: "originalItems",
            baseName: "OriginalItems",
            type: "Array<string>",
        },
        {
            name: "pivotItems",
            baseName: "PivotItems",
            type: "Array<PivotItem>",
        },
        {
            name: "position",
            baseName: "Position",
            type: "number",
        },
        {
            name: "showAllItems",
            baseName: "ShowAllItems",
            type: "boolean",
        },
        {
            name: "showCompact",
            baseName: "ShowCompact",
            type: "boolean",
        },
        {
            name: "showInOutlineForm",
            baseName: "ShowInOutlineForm",
            type: "boolean",
        },
        {
            name: "showSubtotalAtTop",
            baseName: "ShowSubtotalAtTop",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  PivotField.attributeTypeMap;

    }

    public autoShowCount: number;
    public autoShowField: number;
    public autoSortField: number;
    public baseField: number;
    public baseIndex: number;
    public baseItem: number;
    public baseItemPosition: string;
    public currentPageItem: number;
    public dataDisplayFormat: string;
    public displayName: string;
    public dragToColumn: boolean;
    public dragToData: boolean;
    public dragToHide: boolean;
    public dragToPage: boolean;
    public dragToRow: boolean;
    public function: string;
    public insertBlankRow: boolean;
    public isAscendShow: boolean;
    public isAscendSort: boolean;
    public isAutoShow: boolean;
    public isAutoSort: boolean;
    public isAutoSubtotals: boolean;
    public isCalculatedField: boolean;
    public isIncludeNewItemsInFilter: boolean;
    public isInsertPageBreaksBetweenItems: boolean;
    public isMultipleItemSelectionAllowed: boolean;
    public isRepeatItemLabels: boolean;
    public itemCount: number;
    public items: Array<string>;
    public name: string;
    public number: number;
    public numberFormat: string;
    public originalItems: Array<string>;
    public pivotItems: Array<PivotItem>;
    public position: number;
    public showAllItems: boolean;
    public showCompact: boolean;
    public showInOutlineForm: boolean;
    public showSubtotalAtTop: boolean;

    public constructor(init?: Partial< PivotField >) {  
    
        Object.assign(this, init);
    } 
}
   
export class PivotFieldResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pivotField",
            baseName: "PivotField",
            type: "PivotField",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PivotFieldResponse.attributeTypeMap) ;

    }

    public pivotField: PivotField;

    public constructor(init?: Partial< PivotFieldResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents a PivotFilter in PivotFilter Collection.   
export class PivotFilter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoFilter",
            baseName: "AutoFilter",
            type: "AutoFilter",
        },
        {
            name: "evaluationOrder",
            baseName: "EvaluationOrder",
            type: "number",
        },
        {
            name: "fieldIndex",
            baseName: "FieldIndex",
            type: "number",
        },
        {
            name: "filterType",
            baseName: "FilterType",
            type: "string",
        },
        {
            name: "measureFldIndex",
            baseName: "MeasureFldIndex",
            type: "number",
        },
        {
            name: "memberPropertyFieldIndex",
            baseName: "MemberPropertyFieldIndex",
            type: "number",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "value1",
            baseName: "Value1",
            type: "string",
        },
        {
            name: "value2",
            baseName: "Value2",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  PivotFilter.attributeTypeMap;

    }

    public autoFilter: AutoFilter;
    public evaluationOrder: number;
    public fieldIndex: number;
    public filterType: string;
    public measureFldIndex: number;
    public memberPropertyFieldIndex: number;
    public name: string;
    public value1: string;
    public value2: string;

    public constructor(init?: Partial< PivotFilter >) {  
    
        Object.assign(this, init);
    } 
}
   
export class PivotFilterResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pivotFilter",
            baseName: "PivotFilter",
            type: "PivotFilter",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PivotFilterResponse.attributeTypeMap) ;

    }

    public pivotFilter: PivotFilter;

    public constructor(init?: Partial< PivotFilterResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class PivotFiltersResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pivotFilters",
            baseName: "PivotFilters",
            type: "Array<PivotFilter>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PivotFiltersResponse.attributeTypeMap) ;

    }

    public pivotFilters: Array<PivotFilter>;

    public constructor(init?: Partial< PivotFiltersResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class PivotTable  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "altTextDescription",
            baseName: "AltTextDescription",
            type: "string",
        },
        {
            name: "altTextTitle",
            baseName: "AltTextTitle",
            type: "string",
        },
        {
            name: "autoFormatType",
            baseName: "AutoFormatType",
            type: "string",
        },
        {
            name: "baseFields",
            baseName: "BaseFields",
            type: "Array<PivotField>",
        },
        {
            name: "columnFields",
            baseName: "ColumnFields",
            type: "Array<PivotField>",
        },
        {
            name: "columnGrand",
            baseName: "ColumnGrand",
            type: "boolean",
        },
        {
            name: "columnHeaderCaption",
            baseName: "ColumnHeaderCaption",
            type: "string",
        },
        {
            name: "columnRange",
            baseName: "ColumnRange",
            type: "CellArea",
        },
        {
            name: "customListSort",
            baseName: "CustomListSort",
            type: "boolean",
        },
        {
            name: "dataBodyRange",
            baseName: "DataBodyRange",
            type: "CellArea",
        },
        {
            name: "dataField",
            baseName: "DataField",
            type: "PivotField",
        },
        {
            name: "dataFields",
            baseName: "DataFields",
            type: "Array<PivotField>",
        },
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "Array<string>",
        },
        {
            name: "displayErrorString",
            baseName: "DisplayErrorString",
            type: "boolean",
        },
        {
            name: "displayImmediateItems",
            baseName: "DisplayImmediateItems",
            type: "boolean",
        },
        {
            name: "displayNullString",
            baseName: "DisplayNullString",
            type: "boolean",
        },
        {
            name: "enableDataValueEditing",
            baseName: "EnableDataValueEditing",
            type: "boolean",
        },
        {
            name: "enableDrilldown",
            baseName: "EnableDrilldown",
            type: "boolean",
        },
        {
            name: "enableFieldDialog",
            baseName: "EnableFieldDialog",
            type: "boolean",
        },
        {
            name: "enableFieldList",
            baseName: "EnableFieldList",
            type: "boolean",
        },
        {
            name: "enableWizard",
            baseName: "EnableWizard",
            type: "boolean",
        },
        {
            name: "errorString",
            baseName: "ErrorString",
            type: "string",
        },
        {
            name: "fieldListSortAscending",
            baseName: "FieldListSortAscending",
            type: "boolean",
        },
        {
            name: "grandTotalName",
            baseName: "GrandTotalName",
            type: "string",
        },
        {
            name: "hasBlankRows",
            baseName: "HasBlankRows",
            type: "boolean",
        },
        {
            name: "indent",
            baseName: "Indent",
            type: "number",
        },
        {
            name: "isAutoFormat",
            baseName: "IsAutoFormat",
            type: "boolean",
        },
        {
            name: "isGridDropZones",
            baseName: "IsGridDropZones",
            type: "boolean",
        },
        {
            name: "isMultipleFieldFilters",
            baseName: "IsMultipleFieldFilters",
            type: "boolean",
        },
        {
            name: "isSelected",
            baseName: "IsSelected",
            type: "boolean",
        },
        {
            name: "itemPrintTitles",
            baseName: "ItemPrintTitles",
            type: "boolean",
        },
        {
            name: "manualUpdate",
            baseName: "ManualUpdate",
            type: "boolean",
        },
        {
            name: "mergeLabels",
            baseName: "MergeLabels",
            type: "boolean",
        },
        {
            name: "missingItemsLimit",
            baseName: "MissingItemsLimit",
            type: "string",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "nullString",
            baseName: "NullString",
            type: "string",
        },
        {
            name: "pageFieldOrder",
            baseName: "PageFieldOrder",
            type: "string",
        },
        {
            name: "pageFields",
            baseName: "PageFields",
            type: "Array<PivotField>",
        },
        {
            name: "pageFieldWrapCount",
            baseName: "PageFieldWrapCount",
            type: "number",
        },
        {
            name: "pivotFilters",
            baseName: "PivotFilters",
            type: "Array<PivotFilter>",
        },
        {
            name: "pivotTableStyleName",
            baseName: "PivotTableStyleName",
            type: "string",
        },
        {
            name: "pivotTableStyleType",
            baseName: "PivotTableStyleType",
            type: "string",
        },
        {
            name: "preserveFormatting",
            baseName: "PreserveFormatting",
            type: "boolean",
        },
        {
            name: "printDrill",
            baseName: "PrintDrill",
            type: "boolean",
        },
        {
            name: "printTitles",
            baseName: "PrintTitles",
            type: "boolean",
        },
        {
            name: "refreshDataFlag",
            baseName: "RefreshDataFlag",
            type: "boolean",
        },
        {
            name: "refreshDataOnOpeningFile",
            baseName: "RefreshDataOnOpeningFile",
            type: "boolean",
        },
        {
            name: "rowFields",
            baseName: "RowFields",
            type: "Array<PivotField>",
        },
        {
            name: "rowGrand",
            baseName: "RowGrand",
            type: "boolean",
        },
        {
            name: "rowHeaderCaption",
            baseName: "RowHeaderCaption",
            type: "string",
        },
        {
            name: "rowRange",
            baseName: "RowRange",
            type: "CellArea",
        },
        {
            name: "saveData",
            baseName: "SaveData",
            type: "boolean",
        },
        {
            name: "showDataTips",
            baseName: "ShowDataTips",
            type: "boolean",
        },
        {
            name: "showDrill",
            baseName: "ShowDrill",
            type: "boolean",
        },
        {
            name: "showEmptyCol",
            baseName: "ShowEmptyCol",
            type: "boolean",
        },
        {
            name: "showEmptyRow",
            baseName: "ShowEmptyRow",
            type: "boolean",
        },
        {
            name: "showMemberPropertyTips",
            baseName: "ShowMemberPropertyTips",
            type: "boolean",
        },
        {
            name: "showPivotStyleColumnHeader",
            baseName: "ShowPivotStyleColumnHeader",
            type: "boolean",
        },
        {
            name: "showPivotStyleColumnStripes",
            baseName: "ShowPivotStyleColumnStripes",
            type: "boolean",
        },
        {
            name: "showPivotStyleLastColumn",
            baseName: "ShowPivotStyleLastColumn",
            type: "boolean",
        },
        {
            name: "showPivotStyleRowHeader",
            baseName: "ShowPivotStyleRowHeader",
            type: "boolean",
        },
        {
            name: "showPivotStyleRowStripes",
            baseName: "ShowPivotStyleRowStripes",
            type: "boolean",
        },
        {
            name: "showRowHeaderCaption",
            baseName: "ShowRowHeaderCaption",
            type: "boolean",
        },
        {
            name: "showValuesRow",
            baseName: "ShowValuesRow",
            type: "boolean",
        },
        {
            name: "subtotalHiddenPageItems",
            baseName: "SubtotalHiddenPageItems",
            type: "boolean",
        },
        {
            name: "tableRange1",
            baseName: "TableRange1",
            type: "CellArea",
        },
        {
            name: "tableRange2",
            baseName: "TableRange2",
            type: "CellArea",
        },
        {
            name: "tag",
            baseName: "Tag",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PivotTable.attributeTypeMap) ;

    }

    public altTextDescription: string;
    public altTextTitle: string;
    public autoFormatType: string;
    public baseFields: Array<PivotField>;
    public columnFields: Array<PivotField>;
    public columnGrand: boolean;
    public columnHeaderCaption: string;
    public columnRange: CellArea;
    public customListSort: boolean;
    public dataBodyRange: CellArea;
    public dataField: PivotField;
    public dataFields: Array<PivotField>;
    public dataSource: Array<string>;
    public displayErrorString: boolean;
    public displayImmediateItems: boolean;
    public displayNullString: boolean;
    public enableDataValueEditing: boolean;
    public enableDrilldown: boolean;
    public enableFieldDialog: boolean;
    public enableFieldList: boolean;
    public enableWizard: boolean;
    public errorString: string;
    public fieldListSortAscending: boolean;
    public grandTotalName: string;
    public hasBlankRows: boolean;
    public indent: number;
    public isAutoFormat: boolean;
    public isGridDropZones: boolean;
    public isMultipleFieldFilters: boolean;
    public isSelected: boolean;
    public itemPrintTitles: boolean;
    public manualUpdate: boolean;
    public mergeLabels: boolean;
    public missingItemsLimit: string;
    public name: string;
    public nullString: string;
    public pageFieldOrder: string;
    public pageFields: Array<PivotField>;
    public pageFieldWrapCount: number;
    public pivotFilters: Array<PivotFilter>;
    public pivotTableStyleName: string;
    public pivotTableStyleType: string;
    public preserveFormatting: boolean;
    public printDrill: boolean;
    public printTitles: boolean;
    public refreshDataFlag: boolean;
    public refreshDataOnOpeningFile: boolean;
    public rowFields: Array<PivotField>;
    public rowGrand: boolean;
    public rowHeaderCaption: string;
    public rowRange: CellArea;
    public saveData: boolean;
    public showDataTips: boolean;
    public showDrill: boolean;
    public showEmptyCol: boolean;
    public showEmptyRow: boolean;
    public showMemberPropertyTips: boolean;
    public showPivotStyleColumnHeader: boolean;
    public showPivotStyleColumnStripes: boolean;
    public showPivotStyleLastColumn: boolean;
    public showPivotStyleRowHeader: boolean;
    public showPivotStyleRowStripes: boolean;
    public showRowHeaderCaption: boolean;
    public showValuesRow: boolean;
    public subtotalHiddenPageItems: boolean;
    public tableRange1: CellArea;
    public tableRange2: CellArea;
    public tag: string;

    public constructor(init?: Partial< PivotTable >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class PivotTableResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pivotTable",
            baseName: "PivotTable",
            type: "PivotTable",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PivotTableResponse.attributeTypeMap) ;

    }

    public pivotTable: PivotTable;

    public constructor(init?: Partial< PivotTableResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class PivotTables  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pivotTableList",
            baseName: "PivotTableList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PivotTables.attributeTypeMap) ;

    }

    public pivotTableList: Array<LinkElement>;

    public constructor(init?: Partial< PivotTables >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class PivotTablesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pivotTables",
            baseName: "PivotTables",
            type: "PivotTables",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PivotTablesResponse.attributeTypeMap) ;

    }

    public pivotTables: PivotTables;

    public constructor(init?: Partial< PivotTablesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class PlotArea  extends ChartFrame  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "innerHeight",
            baseName: "InnerHeight",
            type: "number",
        },
        {
            name: "innerWidth",
            baseName: "InnerWidth",
            type: "number",
        },
        {
            name: "innerX",
            baseName: "InnerX",
            type: "number",
        },
        {
            name: "innerY",
            baseName: "InnerY",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PlotArea.attributeTypeMap) ;

    }

    public innerHeight: number;
    public innerWidth: number;
    public innerX: number;
    public innerY: number;

    public constructor(init?: Partial< PlotArea >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class PlotAreaResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "plotArea",
            baseName: "PlotArea",
            type: "PlotArea",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PlotAreaResponse.attributeTypeMap) ;

    }

    public plotArea: PlotArea;

    public constructor(init?: Partial< PlotAreaResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class RadioButton  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "groupBox",
            baseName: "GroupBox",
            type: "GroupBox",
        },
        {
            name: "isChecked",
            baseName: "IsChecked",
            type: "boolean",
        },
        {
            name: "shadow",
            baseName: "Shadow",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(RadioButton.attributeTypeMap) ;

    }

    public groupBox: GroupBox;
    public isChecked: boolean;
    public shadow: boolean;

    public constructor(init?: Partial< RadioButton >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class RadioButtonResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "RadioButton",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(RadioButtonResponse.attributeTypeMap) ;

    }

    public shape: RadioButton;

    public constructor(init?: Partial< RadioButtonResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class RangeResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "range",
            baseName: "Range",
            type: "Range",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(RangeResponse.attributeTypeMap) ;

    }

    public range: Range;

    public constructor(init?: Partial< RangeResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class RangesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "ranges",
            baseName: "Ranges",
            type: "Ranges",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(RangesResponse.attributeTypeMap) ;

    }

    public ranges: Ranges;

    public constructor(init?: Partial< RangesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class RangeValueResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "cellsList",
            baseName: "CellsList",
            type: "Array<Cell>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(RangeValueResponse.attributeTypeMap) ;

    }

    public cellsList: Array<Cell>;

    public constructor(init?: Partial< RangeValueResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class RectangleShape  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(RectangleShape.attributeTypeMap) ;

    }


    public constructor(init?: Partial< RectangleShape >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class RectangleShapeResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "RectangleShape",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(RectangleShapeResponse.attributeTypeMap) ;

    }

    public shape: RectangleShape;

    public constructor(init?: Partial< RectangleShapeResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class RowResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "row",
            baseName: "Row",
            type: "Row",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(RowResponse.attributeTypeMap) ;

    }

    public row: Row;

    public constructor(init?: Partial< RowResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class RowsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "rows",
            baseName: "Rows",
            type: "Rows",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(RowsResponse.attributeTypeMap) ;

    }

    public rows: Rows;

    public constructor(init?: Partial< RowsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class SaveFilesToCloudResultResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "saveFilesToCloudResult",
            baseName: "SaveFilesToCloudResult",
            type: "SaveFilesToCloudResult",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SaveFilesToCloudResultResponse.attributeTypeMap) ;

    }

    public saveFilesToCloudResult: SaveFilesToCloudResult;

    public constructor(init?: Partial< SaveFilesToCloudResultResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class SaveResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "saveResult",
            baseName: "SaveResult",
            type: "SaveResult",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SaveResponse.attributeTypeMap) ;

    }

    public saveResult: SaveResult;

    public constructor(init?: Partial< SaveResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ScrollBar  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "currentValue",
            baseName: "CurrentValue",
            type: "number",
        },
        {
            name: "incrementalChange",
            baseName: "IncrementalChange",
            type: "number",
        },
        {
            name: "isHorizontal",
            baseName: "IsHorizontal",
            type: "boolean",
        },
        {
            name: "max",
            baseName: "Max",
            type: "number",
        },
        {
            name: "min",
            baseName: "Min",
            type: "number",
        },
        {
            name: "pageChange",
            baseName: "PageChange",
            type: "number",
        },
        {
            name: "shadow",
            baseName: "Shadow",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ScrollBar.attributeTypeMap) ;

    }

    public currentValue: number;
    public incrementalChange: number;
    public isHorizontal: boolean;
    public max: number;
    public min: number;
    public pageChange: number;
    public shadow: boolean;

    public constructor(init?: Partial< ScrollBar >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ScrollBarResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "ScrollBar",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ScrollBarResponse.attributeTypeMap) ;

    }

    public shape: ScrollBar;

    public constructor(init?: Partial< ScrollBarResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class SeriesItems  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "categoryData",
            baseName: "CategoryData",
            type: "string",
        },
        {
            name: "isColorVaried",
            baseName: "IsColorVaried",
            type: "boolean",
        },
        {
            name: "secondCatergoryData",
            baseName: "SecondCatergoryData",
            type: "string",
        },
        {
            name: "seriesList",
            baseName: "SeriesList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SeriesItems.attributeTypeMap) ;

    }

    public categoryData: string;
    public isColorVaried: boolean;
    public secondCatergoryData: string;
    public seriesList: Array<LinkElement>;

    public constructor(init?: Partial< SeriesItems >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class SeriesesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "serieses",
            baseName: "Serieses",
            type: "SeriesItems",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SeriesesResponse.attributeTypeMap) ;

    }

    public serieses: SeriesItems;

    public constructor(init?: Partial< SeriesesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class Series  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "area",
            baseName: "Area",
            type: "Area",
        },
        {
            name: "bar3DShapeType",
            baseName: "Bar3DShapeType",
            type: "string",
        },
        {
            name: "border",
            baseName: "Border",
            type: "Line",
        },
        {
            name: "bubbleScale",
            baseName: "BubbleScale",
            type: "number",
        },
        {
            name: "bubbleSizes",
            baseName: "BubbleSizes",
            type: "string",
        },
        {
            name: "countOfDataValues",
            baseName: "CountOfDataValues",
            type: "number",
        },
        {
            name: "dataLabels",
            baseName: "DataLabels",
            type: "LinkElement",
        },
        {
            name: "displayName",
            baseName: "DisplayName",
            type: "string",
        },
        {
            name: "doughnutHoleSize",
            baseName: "DoughnutHoleSize",
            type: "number",
        },
        {
            name: "downBars",
            baseName: "DownBars",
            type: "LinkElement",
        },
        {
            name: "dropLines",
            baseName: "DropLines",
            type: "Line",
        },
        {
            name: "explosion",
            baseName: "Explosion",
            type: "number",
        },
        {
            name: "firstSliceAngle",
            baseName: "FirstSliceAngle",
            type: "number",
        },
        {
            name: "gapWidth",
            baseName: "GapWidth",
            type: "number",
        },
        {
            name: "has3DEffect",
            baseName: "Has3DEffect",
            type: "boolean",
        },
        {
            name: "hasDropLines",
            baseName: "HasDropLines",
            type: "boolean",
        },
        {
            name: "hasHiLoLines",
            baseName: "HasHiLoLines",
            type: "boolean",
        },
        {
            name: "hasLeaderLines",
            baseName: "HasLeaderLines",
            type: "boolean",
        },
        {
            name: "hasRadarAxisLabels",
            baseName: "HasRadarAxisLabels",
            type: "boolean",
        },
        {
            name: "hasSeriesLines",
            baseName: "HasSeriesLines",
            type: "boolean",
        },
        {
            name: "hasUpDownBars",
            baseName: "HasUpDownBars",
            type: "boolean",
        },
        {
            name: "hiLoLines",
            baseName: "HiLoLines",
            type: "Line",
        },
        {
            name: "isAutoSplit",
            baseName: "IsAutoSplit",
            type: "boolean",
        },
        {
            name: "isColorVaried",
            baseName: "IsColorVaried",
            type: "boolean",
        },
        {
            name: "leaderLines",
            baseName: "LeaderLines",
            type: "Line",
        },
        {
            name: "legendEntry",
            baseName: "LegendEntry",
            type: "LinkElement",
        },
        {
            name: "line",
            baseName: "Line",
            type: "Line",
        },
        {
            name: "marker",
            baseName: "Marker",
            type: "Marker",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "overlap",
            baseName: "Overlap",
            type: "number",
        },
        {
            name: "plotOnSecondAxis",
            baseName: "PlotOnSecondAxis",
            type: "boolean",
        },
        {
            name: "points",
            baseName: "Points",
            type: "LinkElement",
        },
        {
            name: "secondPlotSize",
            baseName: "SecondPlotSize",
            type: "number",
        },
        {
            name: "seriesLines",
            baseName: "SeriesLines",
            type: "Line",
        },
        {
            name: "shadow",
            baseName: "Shadow",
            type: "boolean",
        },
        {
            name: "shapeProperties",
            baseName: "ShapeProperties",
            type: "LinkElement",
        },
        {
            name: "showNegativeBubbles",
            baseName: "ShowNegativeBubbles",
            type: "boolean",
        },
        {
            name: "sizeRepresents",
            baseName: "SizeRepresents",
            type: "string",
        },
        {
            name: "smooth",
            baseName: "Smooth",
            type: "boolean",
        },
        {
            name: "splitType",
            baseName: "SplitType",
            type: "string",
        },
        {
            name: "splitValue",
            baseName: "SplitValue",
            type: "number",
        },
        {
            name: "trendLines",
            baseName: "TrendLines",
            type: "LinkElement",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "upBars",
            baseName: "UpBars",
            type: "LinkElement",
        },
        {
            name: "values",
            baseName: "Values",
            type: "string",
        },
        {
            name: "xErrorBar",
            baseName: "XErrorBar",
            type: "LinkElement",
        },
        {
            name: "xValues",
            baseName: "XValues",
            type: "string",
        },
        {
            name: "yErrorBar",
            baseName: "YErrorBar",
            type: "LinkElement",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Series.attributeTypeMap) ;

    }

    public area: Area;
    public bar3DShapeType: string;
    public border: Line;
    public bubbleScale: number;
    public bubbleSizes: string;
    public countOfDataValues: number;
    public dataLabels: LinkElement;
    public displayName: string;
    public doughnutHoleSize: number;
    public downBars: LinkElement;
    public dropLines: Line;
    public explosion: number;
    public firstSliceAngle: number;
    public gapWidth: number;
    public has3DEffect: boolean;
    public hasDropLines: boolean;
    public hasHiLoLines: boolean;
    public hasLeaderLines: boolean;
    public hasRadarAxisLabels: boolean;
    public hasSeriesLines: boolean;
    public hasUpDownBars: boolean;
    public hiLoLines: Line;
    public isAutoSplit: boolean;
    public isColorVaried: boolean;
    public leaderLines: Line;
    public legendEntry: LinkElement;
    public line: Line;
    public marker: Marker;
    public name: string;
    public overlap: number;
    public plotOnSecondAxis: boolean;
    public points: LinkElement;
    public secondPlotSize: number;
    public seriesLines: Line;
    public shadow: boolean;
    public shapeProperties: LinkElement;
    public showNegativeBubbles: boolean;
    public sizeRepresents: string;
    public smooth: boolean;
    public splitType: string;
    public splitValue: number;
    public trendLines: LinkElement;
    public type: string;
    public upBars: LinkElement;
    public values: string;
    public xErrorBar: LinkElement;
    public xValues: string;
    public yErrorBar: LinkElement;

    public constructor(init?: Partial< Series >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class SeriesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "series",
            baseName: "Series",
            type: "Series",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SeriesResponse.attributeTypeMap) ;

    }

    public series: Series;

    public constructor(init?: Partial< SeriesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class ShapeResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "Shape",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ShapeResponse.attributeTypeMap) ;

    }

    public shape: Shape;

    public constructor(init?: Partial< ShapeResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class Shapes  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shapeList",
            baseName: "ShapeList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Shapes.attributeTypeMap) ;

    }

    public shapeList: Array<LinkElement>;

    public constructor(init?: Partial< Shapes >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class ShapesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shapes",
            baseName: "Shapes",
            type: "Shapes",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ShapesResponse.attributeTypeMap) ;

    }

    public shapes: Shapes;

    public constructor(init?: Partial< ShapesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class SingleValueResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "value",
            baseName: "Value",
            type: "SingleValue",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SingleValueResponse.attributeTypeMap) ;

    }

    public value: SingleValue;

    public constructor(init?: Partial< SingleValueResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class SparklineGroup  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "displayHidden",
            baseName: "DisplayHidden",
            type: "boolean",
        },
        {
            name: "firstPointColor",
            baseName: "FirstPointColor",
            type: "CellsColor",
        },
        {
            name: "highPointColor",
            baseName: "HighPointColor",
            type: "CellsColor",
        },
        {
            name: "horizontalAxisColor",
            baseName: "HorizontalAxisColor",
            type: "CellsColor",
        },
        {
            name: "horizontalAxisDateRange",
            baseName: "HorizontalAxisDateRange",
            type: "string",
        },
        {
            name: "lastPointColor",
            baseName: "LastPointColor",
            type: "CellsColor",
        },
        {
            name: "lineWeight",
            baseName: "LineWeight",
            type: "number",
        },
        {
            name: "lowPointColor",
            baseName: "LowPointColor",
            type: "CellsColor",
        },
        {
            name: "markersColor",
            baseName: "MarkersColor",
            type: "CellsColor",
        },
        {
            name: "negativePointsColor",
            baseName: "NegativePointsColor",
            type: "CellsColor",
        },
        {
            name: "plotEmptyCellsType",
            baseName: "PlotEmptyCellsType",
            type: "string",
        },
        {
            name: "plotRightToLeft",
            baseName: "PlotRightToLeft",
            type: "boolean",
        },
        {
            name: "presetStyle",
            baseName: "PresetStyle",
            type: "string",
        },
        {
            name: "seriesColor",
            baseName: "SeriesColor",
            type: "CellsColor",
        },
        {
            name: "showFirstPoint",
            baseName: "ShowFirstPoint",
            type: "boolean",
        },
        {
            name: "showHighPoint",
            baseName: "ShowHighPoint",
            type: "boolean",
        },
        {
            name: "showHorizontalAxis",
            baseName: "ShowHorizontalAxis",
            type: "boolean",
        },
        {
            name: "showLastPoint",
            baseName: "ShowLastPoint",
            type: "boolean",
        },
        {
            name: "showLowPoint",
            baseName: "ShowLowPoint",
            type: "boolean",
        },
        {
            name: "showMarkers",
            baseName: "ShowMarkers",
            type: "boolean",
        },
        {
            name: "showNegativePoints",
            baseName: "ShowNegativePoints",
            type: "boolean",
        },
        {
            name: "sparklineCollection",
            baseName: "SparklineCollection",
            type: "Array<Sparkline>",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "verticalAxisMaxValue",
            baseName: "VerticalAxisMaxValue",
            type: "number",
        },
        {
            name: "verticalAxisMaxValueType",
            baseName: "VerticalAxisMaxValueType",
            type: "string",
        },
        {
            name: "verticalAxisMinValue",
            baseName: "VerticalAxisMinValue",
            type: "number",
        },
        {
            name: "verticalAxisMinValueType",
            baseName: "VerticalAxisMinValueType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  SparklineGroup.attributeTypeMap;

    }

    public displayHidden: boolean;
    public firstPointColor: CellsColor;
    public highPointColor: CellsColor;
    public horizontalAxisColor: CellsColor;
    public horizontalAxisDateRange: string;
    public lastPointColor: CellsColor;
    public lineWeight: number;
    public lowPointColor: CellsColor;
    public markersColor: CellsColor;
    public negativePointsColor: CellsColor;
    public plotEmptyCellsType: string;
    public plotRightToLeft: boolean;
    public presetStyle: string;
    public seriesColor: CellsColor;
    public showFirstPoint: boolean;
    public showHighPoint: boolean;
    public showHorizontalAxis: boolean;
    public showLastPoint: boolean;
    public showLowPoint: boolean;
    public showMarkers: boolean;
    public showNegativePoints: boolean;
    public sparklineCollection: Array<Sparkline>;
    public type: string;
    public verticalAxisMaxValue: number;
    public verticalAxisMaxValueType: string;
    public verticalAxisMinValue: number;
    public verticalAxisMinValueType: string;

    public constructor(init?: Partial< SparklineGroup >) {  
    
        Object.assign(this, init);
    } 
}
   
export class SparklineGroupResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sparklineGroup",
            baseName: "SparklineGroup",
            type: "SparklineGroup",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SparklineGroupResponse.attributeTypeMap) ;

    }

    public sparklineGroup: SparklineGroup;

    public constructor(init?: Partial< SparklineGroupResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates a collection of Aspose.Cells.Charts.SparklineGroup objects.
///                
export class SparklineGroups  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sparklineGroupList",
            baseName: "SparklineGroupList",
            type: "Array<SparklineGroup>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  SparklineGroups.attributeTypeMap;

    }

    public sparklineGroupList: Array<SparklineGroup>;

    public constructor(init?: Partial< SparklineGroups >) {  
    
        Object.assign(this, init);
    } 
}
   
export class SparklineGroupsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sparklineGroups",
            baseName: "SparklineGroups",
            type: "SparklineGroups",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SparklineGroupsResponse.attributeTypeMap) ;

    }

    public sparklineGroups: SparklineGroups;

    public constructor(init?: Partial< SparklineGroupsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class Spinner  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "currentValue",
            baseName: "CurrentValue",
            type: "number",
        },
        {
            name: "incrementalChange",
            baseName: "IncrementalChange",
            type: "number",
        },
        {
            name: "max",
            baseName: "Max",
            type: "number",
        },
        {
            name: "min",
            baseName: "Min",
            type: "number",
        },
        {
            name: "shadow",
            baseName: "Shadow",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Spinner.attributeTypeMap) ;

    }

    public currentValue: number;
    public incrementalChange: number;
    public max: number;
    public min: number;
    public shadow: boolean;

    public constructor(init?: Partial< Spinner >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class SpinnerResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "Spinner",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SpinnerResponse.attributeTypeMap) ;

    }

    public shape: Spinner;

    public constructor(init?: Partial< SpinnerResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class SplitResultResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "result",
            baseName: "Result",
            type: "SplitResult",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SplitResultResponse.attributeTypeMap) ;

    }

    public result: SplitResult;

    public constructor(init?: Partial< SplitResultResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class StyleResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "style",
            baseName: "Style",
            type: "Style",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(StyleResponse.attributeTypeMap) ;

    }

    public style: Style;

    public constructor(init?: Partial< StyleResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class TaskRunResultResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "taskRunResult",
            baseName: "TaskRunResult",
            type: "TaskRunResult",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TaskRunResultResponse.attributeTypeMap) ;

    }

    public taskRunResult: TaskRunResult;

    public constructor(init?: Partial< TaskRunResultResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class TextBox  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TextBox.attributeTypeMap) ;

    }


    public constructor(init?: Partial< TextBox >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class TextBoxResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "TextBox",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TextBoxResponse.attributeTypeMap) ;

    }

    public shape: TextBox;

    public constructor(init?: Partial< TextBoxResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class TextItemResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "textItem",
            baseName: "TextItem",
            type: "TextItem",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TextItemResponse.attributeTypeMap) ;

    }

    public textItem: TextItem;

    public constructor(init?: Partial< TextItemResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class TextItemsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "textItems",
            baseName: "TextItems",
            type: "TextItems",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TextItemsResponse.attributeTypeMap) ;

    }

    public textItems: TextItems;

    public constructor(init?: Partial< TextItemsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class TickLabels  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoScaleFont",
            baseName: "AutoScaleFont",
            type: "boolean",
        },
        {
            name: "backgroundMode",
            baseName: "BackgroundMode",
            type: "string",
        },
        {
            name: "font",
            baseName: "Font",
            type: "Font",
        },
        {
            name: "number",
            baseName: "Number",
            type: "number",
        },
        {
            name: "numberFormat",
            baseName: "NumberFormat",
            type: "string",
        },
        {
            name: "numberFormatLinked",
            baseName: "NumberFormatLinked",
            type: "boolean",
        },
        {
            name: "offset",
            baseName: "Offset",
            type: "number",
        },
        {
            name: "rotationAngle",
            baseName: "RotationAngle",
            type: "number",
        },
        {
            name: "textDirection",
            baseName: "TextDirection",
            type: "string",
        },
        {
            name: "readingOrder",
            baseName: "ReadingOrder",
            type: "string",
        },
        {
            name: "directionType",
            baseName: "DirectionType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TickLabels.attributeTypeMap) ;

    }

    public autoScaleFont: boolean;
    public backgroundMode: string;
    public font: Font;
    public number: number;
    public numberFormat: string;
    public numberFormatLinked: boolean;
    public offset: number;
    public rotationAngle: number;
    public textDirection: string;
    public readingOrder: string;
    public directionType: string;

    public constructor(init?: Partial< TickLabels >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class TickLabelsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "tickLabels",
            baseName: "TickLabels",
            type: "TickLabels",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TickLabelsResponse.attributeTypeMap) ;

    }

    public tickLabels: TickLabels;

    public constructor(init?: Partial< TickLabelsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class Title  extends ChartFrame  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "isVisible",
            baseName: "IsVisible",
            type: "boolean",
        },
        {
            name: "linkedSource",
            baseName: "LinkedSource",
            type: "string",
        },
        {
            name: "rotationAngle",
            baseName: "RotationAngle",
            type: "number",
        },
        {
            name: "text",
            baseName: "Text",
            type: "string",
        },
        {
            name: "textDirection",
            baseName: "TextDirection",
            type: "string",
        },
        {
            name: "textHorizontalAlignment",
            baseName: "TextHorizontalAlignment",
            type: "string",
        },
        {
            name: "textVerticalAlignment",
            baseName: "TextVerticalAlignment",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Title.attributeTypeMap) ;

    }

    public isVisible: boolean;
    public linkedSource: string;
    public rotationAngle: number;
    public text: string;
    public textDirection: string;
    public textHorizontalAlignment: string;
    public textVerticalAlignment: string;

    public constructor(init?: Partial< Title >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class TitleResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "title",
            baseName: "Title",
            type: "Title",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TitleResponse.attributeTypeMap) ;

    }

    public title: Title;

    public constructor(init?: Partial< TitleResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class Trendline  extends Line  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "link",
            baseName: "link",
            type: "Link",
        },
        {
            name: "backward",
            baseName: "Backward",
            type: "number",
        },
        {
            name: "dataLabels",
            baseName: "DataLabels",
            type: "LinkElement",
        },
        {
            name: "displayEquation",
            baseName: "DisplayEquation",
            type: "boolean",
        },
        {
            name: "displayRSquared",
            baseName: "DisplayRSquared",
            type: "boolean",
        },
        {
            name: "forward",
            baseName: "Forward",
            type: "number",
        },
        {
            name: "intercept",
            baseName: "Intercept",
            type: "number",
        },
        {
            name: "isNameAuto",
            baseName: "IsNameAuto",
            type: "boolean",
        },
        {
            name: "legendEntry",
            baseName: "LegendEntry",
            type: "LinkElement",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "order",
            baseName: "Order",
            type: "number",
        },
        {
            name: "period",
            baseName: "Period",
            type: "number",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Trendline.attributeTypeMap) ;

    }

    public link: Link;
    public backward: number;
    public dataLabels: LinkElement;
    public displayEquation: boolean;
    public displayRSquared: boolean;
    public forward: number;
    public intercept: number;
    public isNameAuto: boolean;
    public legendEntry: LinkElement;
    public name: string;
    public order: number;
    public period: number;
    public type: string;

    public constructor(init?: Partial< Trendline >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class TrendlineResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "trendline",
            baseName: "Trendline",
            type: "Trendline",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TrendlineResponse.attributeTypeMap) ;

    }

    public trendline: Trendline;

    public constructor(init?: Partial< TrendlineResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class Trendlines  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "trendlineList",
            baseName: "TrendlineList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Trendlines.attributeTypeMap) ;

    }

    public trendlineList: Array<LinkElement>;

    public constructor(init?: Partial< Trendlines >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class TrendlinesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "trendlines",
            baseName: "Trendlines",
            type: "Trendlines",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TrendlinesResponse.attributeTypeMap) ;

    }

    public trendlines: Trendlines;

    public constructor(init?: Partial< TrendlinesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class ValidationResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "validation",
            baseName: "Validation",
            type: "Validation",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ValidationResponse.attributeTypeMap) ;

    }

    public validation: Validation;

    public constructor(init?: Partial< ValidationResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class ValidationsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "validations",
            baseName: "Validations",
            type: "Validations",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ValidationsResponse.attributeTypeMap) ;

    }

    public validations: Validations;

    public constructor(init?: Partial< ValidationsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class VerticalPageBreakResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "verticalPageBreak",
            baseName: "VerticalPageBreak",
            type: "VerticalPageBreak",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(VerticalPageBreakResponse.attributeTypeMap) ;

    }

    public verticalPageBreak: VerticalPageBreak;

    public constructor(init?: Partial< VerticalPageBreakResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class VerticalPageBreaksResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "verticalPageBreaks",
            baseName: "VerticalPageBreaks",
            type: "VerticalPageBreaks",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(VerticalPageBreaksResponse.attributeTypeMap) ;

    }

    public verticalPageBreaks: VerticalPageBreaks;

    public constructor(init?: Partial< VerticalPageBreaksResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class Walls  extends Floor  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "centerX",
            baseName: "CenterX",
            type: "number",
        },
        {
            name: "centerY",
            baseName: "CenterY",
            type: "number",
        },
        {
            name: "depth",
            baseName: "Depth",
            type: "number",
        },
        {
            name: "height",
            baseName: "Height",
            type: "number",
        },
        {
            name: "width",
            baseName: "Width",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Walls.attributeTypeMap) ;

    }

    public centerX: number;
    public centerY: number;
    public depth: number;
    public height: number;
    public width: number;

    public constructor(init?: Partial< Walls >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class WallsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "walls",
            baseName: "Walls",
            type: "Walls",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WallsResponse.attributeTypeMap) ;

    }

    public walls: Walls;

    public constructor(init?: Partial< WallsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class WorkbookReplaceResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "matches",
            baseName: "Matches",
            type: "number",
        },
        {
            name: "workbook",
            baseName: "Workbook",
            type: "LinkElement",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WorkbookReplaceResponse.attributeTypeMap) ;

    }

    public matches: number;
    public workbook: LinkElement;

    public constructor(init?: Partial< WorkbookReplaceResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class WorkbookResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "workbook",
            baseName: "Workbook",
            type: "Workbook",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WorkbookResponse.attributeTypeMap) ;

    }

    public workbook: Workbook;

    public constructor(init?: Partial< WorkbookResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class WorkbookSettingsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "settings",
            baseName: "settings",
            type: "WorkbookSettings",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WorkbookSettingsResponse.attributeTypeMap) ;

    }

    public settings: WorkbookSettings;

    public constructor(init?: Partial< WorkbookSettingsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class WorkbooksResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "workbooks",
            baseName: "Workbooks",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WorkbooksResponse.attributeTypeMap) ;

    }

    public workbooks: Array<LinkElement>;

    public constructor(init?: Partial< WorkbooksResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class WorksheetReplaceResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "matches",
            baseName: "Matches",
            type: "number",
        },
        {
            name: "worksheet",
            baseName: "Worksheet",
            type: "LinkElement",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WorksheetReplaceResponse.attributeTypeMap) ;

    }

    public matches: number;
    public worksheet: LinkElement;

    public constructor(init?: Partial< WorksheetReplaceResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class WorksheetResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "worksheet",
            baseName: "Worksheet",
            type: "Worksheet",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WorksheetResponse.attributeTypeMap) ;

    }

    public worksheet: Worksheet;

    public constructor(init?: Partial< WorksheetResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class WorksheetsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "worksheets",
            baseName: "Worksheets",
            type: "Worksheets",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WorksheetsResponse.attributeTypeMap) ;

    }

    public worksheets: Worksheets;

    public constructor(init?: Partial< WorksheetsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Indicates the match condition that needs to be processed for the file name.   
export class MatchConditionRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "regexPattern",
            baseName: "RegexPattern",
            type: "string",
        },
        {
            name: "fullMatchConditions",
            baseName: "FullMatchConditions",
            type: "Array<string>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  MatchConditionRequest.attributeTypeMap;

    }

    public regexPattern: string;
    public fullMatchConditions: Array<string>;

    public constructor(init?: Partial< MatchConditionRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates batch convert file request   
export class BatchConvertRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sourceFolder",
            baseName: "SourceFolder",
            type: "string",
        },
        {
            name: "sourceStorage",
            baseName: "SourceStorage",
            type: "string",
        },
        {
            name: "matchCondition",
            baseName: "MatchCondition",
            type: "MatchConditionRequest",
        },
        {
            name: "format",
            baseName: "Format",
            type: "string",
        },
        {
            name: "outFolder",
            baseName: "OutFolder",
            type: "string",
        },
        {
            name: "outStorage",
            baseName: "OutStorage",
            type: "string",
        },
        {
            name: "saveOptions",
            baseName: "SaveOptions",
            type: "SaveOptions",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  BatchConvertRequest.attributeTypeMap;

    }

    public sourceFolder: string;
    public sourceStorage: string;
    public matchCondition: MatchConditionRequest;
    public format: string;
    public outFolder: string;
    public outStorage: string;
    public saveOptions: SaveOptions;

    public constructor(init?: Partial< BatchConvertRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates batch lock file request   
export class BatchLockRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sourceFolder",
            baseName: "SourceFolder",
            type: "string",
        },
        {
            name: "sourceStorage",
            baseName: "SourceStorage",
            type: "string",
        },
        {
            name: "matchCondition",
            baseName: "MatchCondition",
            type: "MatchConditionRequest",
        },
        {
            name: "password",
            baseName: "Password",
            type: "string",
        },
        {
            name: "outFolder",
            baseName: "OutFolder",
            type: "string",
        },
        {
            name: "outStorage",
            baseName: "OutStorage",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  BatchLockRequest.attributeTypeMap;

    }

    public sourceFolder: string;
    public sourceStorage: string;
    public matchCondition: MatchConditionRequest;
    public password: string;
    public outFolder: string;
    public outStorage: string;

    public constructor(init?: Partial< BatchLockRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates batch protect file request   
export class BatchProtectRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sourceFolder",
            baseName: "SourceFolder",
            type: "string",
        },
        {
            name: "sourceStorage",
            baseName: "SourceStorage",
            type: "string",
        },
        {
            name: "matchCondition",
            baseName: "MatchCondition",
            type: "MatchConditionRequest",
        },
        {
            name: "protectionType",
            baseName: "ProtectionType",
            type: "string",
        },
        {
            name: "password",
            baseName: "Password",
            type: "string",
        },
        {
            name: "outFolder",
            baseName: "OutFolder",
            type: "string",
        },
        {
            name: "outStorage",
            baseName: "OutStorage",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  BatchProtectRequest.attributeTypeMap;

    }

    public sourceFolder: string;
    public sourceStorage: string;
    public matchCondition: MatchConditionRequest;
    public protectionType: string;
    public password: string;
    public outFolder: string;
    public outStorage: string;

    public constructor(init?: Partial< BatchProtectRequest >) {  
    
        Object.assign(this, init);
    } 
}
   
export class BatchSplitRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sourceFolder",
            baseName: "SourceFolder",
            type: "string",
        },
        {
            name: "sourceStorage",
            baseName: "SourceStorage",
            type: "string",
        },
        {
            name: "matchCondition",
            baseName: "MatchCondition",
            type: "MatchConditionRequest",
        },
        {
            name: "format",
            baseName: "Format",
            type: "string",
        },
        {
            name: "fromIndex",
            baseName: "FromIndex",
            type: "number",
        },
        {
            name: "toIndex",
            baseName: "ToIndex",
            type: "number",
        },
        {
            name: "outFolder",
            baseName: "OutFolder",
            type: "string",
        },
        {
            name: "outStorage",
            baseName: "OutStorage",
            type: "string",
        },
        {
            name: "saveOptions",
            baseName: "SaveOptions",
            type: "SaveOptions",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  BatchSplitRequest.attributeTypeMap;

    }

    public sourceFolder: string;
    public sourceStorage: string;
    public matchCondition: MatchConditionRequest;
    public format: string;
    public fromIndex: number;
    public toIndex: number;
    public outFolder: string;
    public outStorage: string;
    public saveOptions: SaveOptions;

    public constructor(init?: Partial< BatchSplitRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates color filter request   
export class ColorFilterRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pattern",
            baseName: "Pattern",
            type: "string",
        },
        {
            name: "foregroundColor",
            baseName: "ForegroundColor",
            type: "CellsColor",
        },
        {
            name: "backgroundColor",
            baseName: "BackgroundColor",
            type: "CellsColor",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ColorFilterRequest.attributeTypeMap;

    }

    public pattern: string;
    public foregroundColor: CellsColor;
    public backgroundColor: CellsColor;

    public constructor(init?: Partial< ColorFilterRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates convert parameter   
export class ConvertParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "value",
            baseName: "Value",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ConvertParameter.attributeTypeMap;

    }

    public name: string;
    public value: string;

    public constructor(init?: Partial< ConvertParameter >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates create pivot table request   
export class CreatePivotTableRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "sourceData",
            baseName: "SourceData",
            type: "string",
        },
        {
            name: "destCellName",
            baseName: "DestCellName",
            type: "string",
        },
        {
            name: "useSameSource",
            baseName: "UseSameSource",
            type: "boolean",
        },
        {
            name: "pivotFieldRows",
            baseName: "PivotFieldRows",
            type: "Array<number>",
        },
        {
            name: "pivotFieldColumns",
            baseName: "PivotFieldColumns",
            type: "Array<number>",
        },
        {
            name: "pivotFieldData",
            baseName: "PivotFieldData",
            type: "Array<number>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CreatePivotTableRequest.attributeTypeMap;

    }

    public name: string;
    public sourceData: string;
    public destCellName: string;
    public useSameSource: boolean;
    public pivotFieldRows: Array<number>;
    public pivotFieldColumns: Array<number>;
    public pivotFieldData: Array<number>;

    public constructor(init?: Partial< CreatePivotTableRequest >) {  
    
        Object.assign(this, init);
    } 
}
   
export class ImportPosition  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sheetName",
            baseName: "SheetName",
            type: "string",
        },
        {
            name: "rowIndex",
            baseName: "RowIndex",
            type: "number",
        },
        {
            name: "columnIndex",
            baseName: "ColumnIndex",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ImportPosition.attributeTypeMap;

    }

    public sheetName: string;
    public rowIndex: number;
    public columnIndex: number;

    public constructor(init?: Partial< ImportPosition >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates import xml data request   
export class ImportJsonRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "jsonFileSource",
            baseName: "JsonFileSource",
            type: "FileSource",
        },
        {
            name: "importPosition",
            baseName: "ImportPosition",
            type: "ImportPosition",
        },
        {
            name: "jsonContent",
            baseName: "JsonContent",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ImportJsonRequest.attributeTypeMap;

    }

    public jsonFileSource: FileSource;
    public importPosition: ImportPosition;
    public jsonContent: string;

    public constructor(init?: Partial< ImportJsonRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates import xml data request   
export class ImportXMLRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "xMLFileSource",
            baseName: "XMLFileSource",
            type: "FileSource",
        },
        {
            name: "importPosition",
            baseName: "ImportPosition",
            type: "ImportPosition",
        },
        {
            name: "xMLContent",
            baseName: "XMLContent",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ImportXMLRequest.attributeTypeMap;

    }

    public xMLFileSource: FileSource;
    public importPosition: ImportPosition;
    public xMLContent: string;

    public constructor(init?: Partial< ImportXMLRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Used for password data transfer.   
export class PasswordRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "password",
            baseName: "Password",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  PasswordRequest.attributeTypeMap;

    }

    public password: string;

    public constructor(init?: Partial< PasswordRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates pivot table field request   
export class PivotTableFieldRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "data",
            baseName: "Data",
            type: "Array<number>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  PivotTableFieldRequest.attributeTypeMap;

    }

    public data: Array<number>;

    public constructor(init?: Partial< PivotTableFieldRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Signature in file.
///                
export class DigitalSignature  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "comments",
            baseName: "Comments",
            type: "string",
        },
        {
            name: "signTime",
            baseName: "SignTime",
            type: "string",
        },
        {
            name: "id",
            baseName: "Id",
            type: "string",
        },
        {
            name: "password",
            baseName: "Password",
            type: "string",
        },
        {
            name: "image",
            baseName: "Image",
            type: "Array<number>",
        },
        {
            name: "providerId",
            baseName: "ProviderId",
            type: "string",
        },
        {
            name: "isValid",
            baseName: "IsValid",
            type: "boolean",
        },
        {
            name: "xAdESType",
            baseName: "XAdESType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DigitalSignature.attributeTypeMap;

    }

    public comments: string;
    public signTime: string;
    public id: string;
    public password: string;
    public image: Array<number>;
    public providerId: string;
    public isValid: boolean;
    public xAdESType: string;

    public constructor(init?: Partial< DigitalSignature >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates protect workbook request   
export class ProtectWorkbookRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "awaysOpenReadOnly",
            baseName: "AwaysOpenReadOnly",
            type: "boolean",
        },
        {
            name: "encryptWithPassword",
            baseName: "EncryptWithPassword",
            type: "string",
        },
        {
            name: "protectCurrentSheet",
            baseName: "ProtectCurrentSheet",
            type: "Protection",
        },
        {
            name: "protectWorkbookStructure",
            baseName: "ProtectWorkbookStructure",
            type: "string",
        },
        {
            name: "digitalSignature",
            baseName: "DigitalSignature",
            type: "DigitalSignature",
        },
        {
            name: "markAsFinal",
            baseName: "MarkAsFinal",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ProtectWorkbookRequest.attributeTypeMap;

    }

    public awaysOpenReadOnly: boolean;
    public encryptWithPassword: string;
    public protectCurrentSheet: Protection;
    public protectWorkbookStructure: string;
    public digitalSignature: DigitalSignature;
    public markAsFinal: boolean;

    public constructor(init?: Partial< ProtectWorkbookRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates range copy request   
export class RangeCopyRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "operate",
            baseName: "Operate",
            type: "string",
        },
        {
            name: "source",
            baseName: "Source",
            type: "Range",
        },
        {
            name: "target",
            baseName: "Target",
            type: "Range",
        },
        {
            name: "pasteOptions",
            baseName: "PasteOptions",
            type: "PasteOptions",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  RangeCopyRequest.attributeTypeMap;

    }

    public operate: string;
    public source: Range;
    public target: Range;
    public pasteOptions: PasteOptions;

    public constructor(init?: Partial< RangeCopyRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates range set outline border request.   
export class RangeSetOutlineBorderRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "range",
            baseName: "Range",
            type: "Range",
        },
        {
            name: "borderEdge",
            baseName: "borderEdge",
            type: "string",
        },
        {
            name: "borderStyle",
            baseName: "borderStyle",
            type: "string",
        },
        {
            name: "borderColor",
            baseName: "borderColor",
            type: "Color",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  RangeSetOutlineBorderRequest.attributeTypeMap;

    }

    public range: Range;
    public borderEdge: string;
    public borderStyle: string;
    public borderColor: Color;

    public constructor(init?: Partial< RangeSetOutlineBorderRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates range set style request.   
export class RangeSetStyleRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "range",
            baseName: "Range",
            type: "Range",
        },
        {
            name: "style",
            baseName: "Style",
            type: "Style",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  RangeSetStyleRequest.attributeTypeMap;

    }

    public range: Range;
    public style: Style;

    public constructor(init?: Partial< RangeSetStyleRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates range sort request   
export class RangeSortRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSorter",
            baseName: "DataSorter",
            type: "DataSorter",
        },
        {
            name: "cellArea",
            baseName: "CellArea",
            type: "Range",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  RangeSortRequest.attributeTypeMap;

    }

    public dataSorter: DataSorter;
    public cellArea: Range;

    public constructor(init?: Partial< RangeSortRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates table total request   
export class TableTotalRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "listColumnIndex",
            baseName: "ListColumnIndex",
            type: "number",
        },
        {
            name: "totalsCalculation",
            baseName: "TotalsCalculation",
            type: "string",
        },
        {
            name: "customFormula",
            baseName: "CustomFormula",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  TableTotalRequest.attributeTypeMap;

    }

    public listColumnIndex: number;
    public totalsCalculation: string;
    public customFormula: string;

    public constructor(init?: Partial< TableTotalRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates text water marker request.   
export class TextWaterMarkerRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "text",
            baseName: "Text",
            type: "string",
        },
        {
            name: "fontName",
            baseName: "FontName",
            type: "string",
        },
        {
            name: "fontSize",
            baseName: "FontSize",
            type: "number",
        },
        {
            name: "height",
            baseName: "Height",
            type: "number",
        },
        {
            name: "width",
            baseName: "Width",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  TextWaterMarkerRequest.attributeTypeMap;

    }

    public text: string;
    public fontName: string;
    public fontSize: number;
    public height: number;
    public width: number;

    public constructor(init?: Partial< TextWaterMarkerRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Used by workbook encryption/decryption requests.   
export class WorkbookEncryptionRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "encryptionType",
            baseName: "EncryptionType",
            type: "string",
        },
        {
            name: "keyLength",
            baseName: "KeyLength",
            type: "number",
        },
        {
            name: "password",
            baseName: "Password",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  WorkbookEncryptionRequest.attributeTypeMap;

    }

    public encryptionType: string;
    public keyLength: number;
    public password: string;

    public constructor(init?: Partial< WorkbookEncryptionRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Used by workbook protection requests.   
export class WorkbookProtectionRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "protectionType",
            baseName: "ProtectionType",
            type: "string",
        },
        {
            name: "password",
            baseName: "Password",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  WorkbookProtectionRequest.attributeTypeMap;

    }

    public protectionType: string;
    public password: string;

    public constructor(init?: Partial< WorkbookProtectionRequest >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class RenderingFont  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "size",
            baseName: "Size",
            type: "number",
        },
        {
            name: "bold",
            baseName: "Bold",
            type: "boolean",
        },
        {
            name: "italic",
            baseName: "Italic",
            type: "boolean",
        },
        {
            name: "color",
            baseName: "Color",
            type: "Color",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  RenderingFont.attributeTypeMap;

    }

    public name: string;
    public size: number;
    public bold: boolean;
    public italic: boolean;
    public color: Color;

    public constructor(init?: Partial< RenderingFont >) {  
    
        Object.assign(this, init);
    } 
}
   
export class PivotItem  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "index",
            baseName: "Index",
            type: "number",
        },
        {
            name: "isHidden",
            baseName: "IsHidden",
            type: "boolean",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "value",
            baseName: "Value",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  PivotItem.attributeTypeMap;

    }

    public index: number;
    public isHidden: boolean;
    public name: string;
    public value: string;

    public constructor(init?: Partial< PivotItem >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class CustomParserConfig  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "columnIndex",
            baseName: "ColumnIndex",
            type: "number",
        },
        {
            name: "parseMethod",
            baseName: "ParseMethod",
            type: "string",
        },
        {
            name: "customStyle",
            baseName: "CustomStyle",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CustomParserConfig.attributeTypeMap;

    }

    public columnIndex: number;
    public parseMethod: string;
    public customStyle: string;

    public constructor(init?: Partial< CustomParserConfig >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class Import2DimensionDoubleArrayOption  extends ImportOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "firstRow",
            baseName: "FirstRow",
            type: "number",
        },
        {
            name: "firstColumn",
            baseName: "FirstColumn",
            type: "number",
        },
        {
            name: "data",
            baseName: "Data",
            type: "Array<number>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Import2DimensionDoubleArrayOption.attributeTypeMap) ;

    }

    public firstRow: number;
    public firstColumn: number;
    public data: Array<number>;

    public constructor(init?: Partial< Import2DimensionDoubleArrayOption >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class Import2DimensionIntArrayOption  extends ImportOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "firstRow",
            baseName: "FirstRow",
            type: "number",
        },
        {
            name: "firstColumn",
            baseName: "FirstColumn",
            type: "number",
        },
        {
            name: "data",
            baseName: "Data",
            type: "Array<number>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Import2DimensionIntArrayOption.attributeTypeMap) ;

    }

    public firstRow: number;
    public firstColumn: number;
    public data: Array<number>;

    public constructor(init?: Partial< Import2DimensionIntArrayOption >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class Import2DimensionStringArrayOption  extends ImportOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "firstRow",
            baseName: "FirstRow",
            type: "number",
        },
        {
            name: "firstColumn",
            baseName: "FirstColumn",
            type: "number",
        },
        {
            name: "data",
            baseName: "Data",
            type: "Array<string>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Import2DimensionStringArrayOption.attributeTypeMap) ;

    }

    public firstRow: number;
    public firstColumn: number;
    public data: Array<string>;

    public constructor(init?: Partial< Import2DimensionStringArrayOption >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class CellValue  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "rowIndex",
            baseName: "rowIndex",
            type: "number",
        },
        {
            name: "columnIndex",
            baseName: "columnIndex",
            type: "number",
        },
        {
            name: "type",
            baseName: "type",
            type: "string",
        },
        {
            name: "value",
            baseName: "value",
            type: "string",
        },
        {
            name: "formula",
            baseName: "formula",
            type: "string",
        },
        {
            name: "style",
            baseName: "style",
            type: "Style",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CellValue.attributeTypeMap;

    }

    public rowIndex: number;
    public columnIndex: number;
    public type: string;
    public value: string;
    public formula: string;
    public style: Style;

    public constructor(init?: Partial< CellValue >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class ImportBatchDataOption  extends ImportOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "batchData",
            baseName: "BatchData",
            type: "Array<CellValue>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImportBatchDataOption.attributeTypeMap) ;

    }

    public batchData: Array<CellValue>;

    public constructor(init?: Partial< ImportBatchDataOption >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ImportCSVDataOption  extends ImportOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "separatorString",
            baseName: "SeparatorString",
            type: "string",
        },
        {
            name: "convertNumericData",
            baseName: "ConvertNumericData",
            type: "boolean",
        },
        {
            name: "firstRow",
            baseName: "FirstRow",
            type: "number",
        },
        {
            name: "firstColumn",
            baseName: "FirstColumn",
            type: "number",
        },
        {
            name: "sourceFile",
            baseName: "SourceFile",
            type: "string",
        },
        {
            name: "customParsers",
            baseName: "CustomParsers",
            type: "Array<CustomParserConfig>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImportCSVDataOption.attributeTypeMap) ;

    }

    public separatorString: string;
    public convertNumericData: boolean;
    public firstRow: number;
    public firstColumn: number;
    public sourceFile: string;
    public customParsers: Array<CustomParserConfig>;

    public constructor(init?: Partial< ImportCSVDataOption >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ImportDoubleArrayOption  extends ImportOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "firstRow",
            baseName: "FirstRow",
            type: "number",
        },
        {
            name: "firstColumn",
            baseName: "FirstColumn",
            type: "number",
        },
        {
            name: "isVertical",
            baseName: "IsVertical",
            type: "boolean",
        },
        {
            name: "data",
            baseName: "Data",
            type: "Array<number>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImportDoubleArrayOption.attributeTypeMap) ;

    }

    public firstRow: number;
    public firstColumn: number;
    public isVertical: boolean;
    public data: Array<number>;

    public constructor(init?: Partial< ImportDoubleArrayOption >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ImportIntArrayOption  extends ImportOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "firstRow",
            baseName: "FirstRow",
            type: "number",
        },
        {
            name: "firstColumn",
            baseName: "FirstColumn",
            type: "number",
        },
        {
            name: "isVertical",
            baseName: "IsVertical",
            type: "boolean",
        },
        {
            name: "data",
            baseName: "Data",
            type: "Array<number>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImportIntArrayOption.attributeTypeMap) ;

    }

    public firstRow: number;
    public firstColumn: number;
    public isVertical: boolean;
    public data: Array<number>;

    public constructor(init?: Partial< ImportIntArrayOption >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ImportPictureOption  extends ImportOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "upperLeftRow",
            baseName: "UpperLeftRow",
            type: "number",
        },
        {
            name: "upperLeftColumn",
            baseName: "UpperLeftColumn",
            type: "number",
        },
        {
            name: "lowerRightRow",
            baseName: "LowerRightRow",
            type: "number",
        },
        {
            name: "lowerRightColumn",
            baseName: "LowerRightColumn",
            type: "number",
        },
        {
            name: "filename",
            baseName: "Filename",
            type: "string",
        },
        {
            name: "data",
            baseName: "Data",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImportPictureOption.attributeTypeMap) ;

    }

    public upperLeftRow: number;
    public upperLeftColumn: number;
    public lowerRightRow: number;
    public lowerRightColumn: number;
    public filename: string;
    public data: string;

    public constructor(init?: Partial< ImportPictureOption >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class ImportStringArrayOption  extends ImportOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "firstRow",
            baseName: "FirstRow",
            type: "number",
        },
        {
            name: "firstColumn",
            baseName: "FirstColumn",
            type: "number",
        },
        {
            name: "isVertical",
            baseName: "IsVertical",
            type: "boolean",
        },
        {
            name: "data",
            baseName: "Data",
            type: "Array<string>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImportStringArrayOption.attributeTypeMap) ;

    }

    public firstRow: number;
    public firstColumn: number;
    public isVertical: boolean;
    public data: Array<string>;

    public constructor(init?: Partial< ImportStringArrayOption >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class GradientFill  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "fillType",
            baseName: "FillType",
            type: "string",
        },
        {
            name: "directionType",
            baseName: "DirectionType",
            type: "string",
        },
        {
            name: "angle",
            baseName: "Angle",
            type: "number",
        },
        {
            name: "gradientStops",
            baseName: "GradientStops",
            type: "Array<GradientFillStop>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  GradientFill.attributeTypeMap;

    }

    public fillType: string;
    public directionType: string;
    public angle: number;
    public gradientStops: Array<GradientFillStop>;

    public constructor(init?: Partial< GradientFill >) {  
    
        Object.assign(this, init);
    } 
}
   
export class PatternFill  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pattern",
            baseName: "Pattern",
            type: "string",
        },
        {
            name: "backgroundCellsColor",
            baseName: "BackgroundCellsColor",
            type: "CellsColor",
        },
        {
            name: "foregroundCellsColor",
            baseName: "ForegroundCellsColor",
            type: "CellsColor",
        },
        {
            name: "foregroundColor",
            baseName: "ForegroundColor",
            type: "Color",
        },
        {
            name: "backgroundColor",
            baseName: "BackgroundColor",
            type: "Color",
        },
        {
            name: "backTransparency",
            baseName: "BackTransparency",
            type: "number",
        },
        {
            name: "foreTransparency",
            baseName: "ForeTransparency",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  PatternFill.attributeTypeMap;

    }

    public pattern: string;
    public backgroundCellsColor: CellsColor;
    public foregroundCellsColor: CellsColor;
    public foregroundColor: Color;
    public backgroundColor: Color;
    public backTransparency: number;
    public foreTransparency: number;

    public constructor(init?: Partial< PatternFill >) {  
    
        Object.assign(this, init);
    } 
}
   
export class SolidFill  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "color",
            baseName: "Color",
            type: "Color",
        },
        {
            name: "cellsColor",
            baseName: "CellsColor",
            type: "CellsColor",
        },
        {
            name: "transparency",
            baseName: "Transparency",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  SolidFill.attributeTypeMap;

    }

    public color: Color;
    public cellsColor: CellsColor;
    public transparency: number;

    public constructor(init?: Partial< SolidFill >) {  
    
        Object.assign(this, init);
    } 
}
   
export class TextureFill  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "transparency",
            baseName: "Transparency",
            type: "number",
        },
        {
            name: "scale",
            baseName: "Scale",
            type: "number",
        },
        {
            name: "tilePicOption",
            baseName: "TilePicOption",
            type: "TilePicOption",
        },
        {
            name: "picFormatOption",
            baseName: "PicFormatOption",
            type: "PicFormatOption",
        },
        {
            name: "image",
            baseName: "Image",
            type: "LinkElement",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  TextureFill.attributeTypeMap;

    }

    public type: string;
    public transparency: number;
    public scale: number;
    public tilePicOption: TilePicOption;
    public picFormatOption: PicFormatOption;
    public image: LinkElement;

    public constructor(init?: Partial< TextureFill >) {  
    
        Object.assign(this, init);
    } 
}
   
export class GradientFillStop  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "color",
            baseName: "Color",
            type: "Color",
        },
        {
            name: "position",
            baseName: "Position",
            type: "number",
        },
        {
            name: "transparency",
            baseName: "Transparency",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  GradientFillStop.attributeTypeMap;

    }

    public color: Color;
    public position: number;
    public transparency: number;

    public constructor(init?: Partial< GradientFillStop >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class GroupShape  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(GroupShape.attributeTypeMap) ;

    }


    public constructor(init?: Partial< GroupShape >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class PicFormatOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "scale",
            baseName: "Scale",
            type: "number",
        },
        {
            name: "left",
            baseName: "Left",
            type: "number",
        },
        {
            name: "right",
            baseName: "Right",
            type: "number",
        },
        {
            name: "top",
            baseName: "Top",
            type: "number",
        },
        {
            name: "bottom",
            baseName: "Bottom",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  PicFormatOption.attributeTypeMap;

    }

    public type: string;
    public scale: number;
    public left: number;
    public right: number;
    public top: number;
    public bottom: number;

    public constructor(init?: Partial< PicFormatOption >) {  
    
        Object.assign(this, init);
    } 
}
   
export class TilePicOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "offsetX",
            baseName: "OffsetX",
            type: "number",
        },
        {
            name: "offsetY",
            baseName: "OffsetY",
            type: "number",
        },
        {
            name: "scaleX",
            baseName: "ScaleX",
            type: "number",
        },
        {
            name: "scaleY",
            baseName: "ScaleY",
            type: "number",
        },
        {
            name: "alignmentType",
            baseName: "AlignmentType",
            type: "string",
        },
        {
            name: "mirrorType",
            baseName: "MirrorType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  TilePicOption.attributeTypeMap;

    }

    public offsetX: number;
    public offsetY: number;
    public scaleX: number;
    public scaleY: number;
    public alignmentType: string;
    public mirrorType: string;

    public constructor(init?: Partial< TilePicOption >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class Marker  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "border",
            baseName: "Border",
            type: "Line",
        },
        {
            name: "area",
            baseName: "Area",
            type: "Area",
        },
        {
            name: "markerSize",
            baseName: "MarkerSize",
            type: "number",
        },
        {
            name: "markerStyle",
            baseName: "MarkerStyle",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Marker.attributeTypeMap;

    }

    public border: Line;
    public area: Area;
    public markerSize: number;
    public markerStyle: string;

    public constructor(init?: Partial< Marker >) {  
    
        Object.assign(this, init);
    } 
}
/// Chart shape object   
export class ChartShape  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartShape.attributeTypeMap) ;

    }


    public constructor(init?: Partial< ChartShape >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// A sparkline represents a tiny chart or graphic in a worksheet cell that provides a visual representation of data.
///                
export class Sparkline  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "column",
            baseName: "Column",
            type: "number",
        },
        {
            name: "dataRange",
            baseName: "DataRange",
            type: "string",
        },
        {
            name: "row",
            baseName: "Row",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Sparkline.attributeTypeMap;

    }

    public column: number;
    public dataRange: string;
    public row: number;

    public constructor(init?: Partial< Sparkline >) {  
    
        Object.assign(this, init);
    } 
}
/// The error details   
export class ErrorDetails  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ErrorDetails.attributeTypeMap;

    }


    public constructor(init?: Partial< ErrorDetails >) {  
    
        Object.assign(this, init);
    } 
}
const enumsMap = {
};
const typeMap = {
    ValueType,
    DiscUsage,
    ObjectExist,
    ObjectExistsExtensions,
    FileVersion,
    StorageExist,
    FileVersions,
    FilesList,
    FilesUploadResult,
    StorageFile,
    GoogleDriveStorageFile,
    AboveAverage,
    AbstractCalculationEngine,
    AbstractCalculationMonitor,
    AutoFilter,
    AutoFitterOptions,
    Border,
    CalculationOptions,
    Cell,
    CellArea,
    Cells,
    CellsCloudFileInfo,
    CellsColor,
    CellsDocumentProperties,
    CellsDocumentProperty,
    Color,
    ColorFilter,
    ColorScale,
    Column,
    Columns,
    Comment,
    Comments,
    ConditionalFormatting,
    ConditionalFormattingIcon,
    ConditionalFormattings,
    ConditionalFormattingValue,
    CopyOptions,
    CriteriaMultipleFilter,
    CustomFilter,
    DataBar,
    DataBarBorder,
    DataSorter,
    DataSorterKey,
    DateTimeGroupItem,
    DynamicFilter,
    FileInfo,
    FilesResult,
    FilterColumn,
    Font,
    FontSetting,
    FormatCondition,
    FormulaFormatCondition,
    FormulaSettings,
    GlobalizationSettings,
    HorizontalPageBreak,
    HorizontalPageBreaks,
    Hyperlink,
    Hyperlinks,
    IconFilter,
    IconSet,
    Link,
    LinkElement,
    LoadOptions,
    MergedCell,
    MergedCells,
    MultipleFilter,
    MultipleFilters,
    Name,
    Names,
    NegativeBarFormat,
    PageSection,
    PageSetup,
    PasteOptions,
    PdfSecurityOptions,
    Protection,
    ProtectSheetParameter,
    QueryTable,
    Range,
    Ranges,
    Row,
    Rows,
    SaveResult,
    SingleValue,
    SortKey,
    SplitResult,
    SplitResultDocument,
    Style,
    StyleFormatCondition,
    Styles,
    TextFormatCondition,
    TextItem,
    TextItems,
    TextOptions,
    ThemeColor,
    TimePeriodFormatCondition,
    Top10,
    Top10Filter,
    Validation,
    Validations,
    VerticalPageBreak,
    VerticalPageBreaks,
    Workbook,
    WorkbookSettings,
    Worksheet,
    Worksheets,
    WriteProtection,
    XmlDataBinding,
    XmlMap,
    CellsObjectOperateTaskParameter,
    ConvertTaskParameter,
    ConvertWorksheetTaskParameter,
    FileSource,
    ImportDataTaskParameter,
    ResultDestination,
    SaveFilesToCloudResult,
    SaveResultTaskParameter,
    SmartMarkerTaskParameter,
    SplitWorkbookTaskParameter,
    TaskData,
    TaskDescription,
    TaskParameter,
    TaskResultParameter,
    TaskRunResult,
    ChartOperateParameter,
    ListObjectOperateParameter,
    OperateObject,
    OperateObjectPosition,
    OperateParameter,
    PageBreakOperateParameter,
    PageSetupOperateParameter,
    PivotTableOperateParameter,
    ShapeOperateParameter,
    WorkbookOperateParameter,
    WorkbookSettingsOperateParameter,
    WorksheetOperateParameter,
    ListColumn,
    ListObject,
    ListObjects,
    PivotGlobalizationSettings,
    DifSaveOptions,
    DocxSaveOptions,
    HtmlSaveOptions,
    ImageSaveOptions,
    JsonSaveOptions,
    MarkdownSaveOptions,
    MHtmlSaveOptions,
    OdsSaveOptions,
    OoxmlSaveOptions,
    PdfSaveOptions,
    PptxSaveOptions,
    SaveOptions,
    SpreadsheetML2003SaveOptions,
    SqlScriptSaveOptions,
    SvgSaveOptions,
    TxtSaveOptions,
    XlsbSaveOptions,
    XlsSaveOptions,
    XpsSaveOptions,
    ArcShapeResponse,
    AutoFilterResponse,
    AutoShapeResponse,
    AutoShapesResponse,
    AxisResponse,
    BarcodeResponse,
    BarcodeResponseList,
    BorderResponse,
    ButtonResponse,
    CalculateFormulaResponse,
    CellResponse,
    CellsCloudFileInfoResponse,
    CellsCloudResponse,
    CellsDocumentPropertiesResponse,
    CellsDocumentPropertyResponse,
    CellsDrawingResponse,
    CellsResponse,
    ChartAreaResponse,
    ChartDataTableResponse,
    ChartPointResponse,
    ChartPointsResponse,
    ChartResponse,
    ChartsResponse,
    CheckBoxResponse,
    ColumnResponse,
    ColumnsResponse,
    ComboBoxResponse,
    CommentResponse,
    CommentShapeResponse,
    CommentsResponse,
    ConditionalFormattingResponse,
    ConditionalFormattingsResponse,
    DataLabelsResponse,
    DisplayUnitLabelResponse,
    DropBarsResponse,
    ErrorBarResponse,
    FillFormatResponse,
    FindResponse,
    FloorResponse,
    FormResponse,
    FormsResponse,
    GroupBoxResponse,
    HorizontalPageBreakResponse,
    HorizontalPageBreaksResponse,
    HyperlinkResponse,
    HyperlinksResponse,
    LabelResponse,
    LegendEntriesResponse,
    LegendEntryResponse,
    LegendResponse,
    LineResponse,
    LineShapeResponse,
    ListBoxResponse,
    ListObjectResponse,
    ListObjectsResponse,
    MergedCellResponse,
    MergedCellsResponse,
    NameResponse,
    NamesResponse,
    OleObjectResponse,
    OleObjectsResponse,
    OvalResponse,
    PageSectionsResponse,
    PageSetupResponse,
    PictureResponse,
    PicturesResponse,
    PivotFieldResponse,
    PivotFilterResponse,
    PivotFiltersResponse,
    PivotTableResponse,
    PivotTablesResponse,
    PlotAreaResponse,
    RadioButtonResponse,
    RangeResponse,
    RangesResponse,
    RangeValueResponse,
    RectangleShapeResponse,
    RowResponse,
    RowsResponse,
    SaveFilesToCloudResultResponse,
    SaveResponse,
    ScrollBarResponse,
    SeriesesResponse,
    SeriesResponse,
    ShapeResponse,
    ShapesResponse,
    SingleValueResponse,
    SparklineGroupResponse,
    SparklineGroupsResponse,
    SpinnerResponse,
    SplitResultResponse,
    StyleResponse,
    TaskRunResultResponse,
    TextBoxResponse,
    TextItemResponse,
    TextItemsResponse,
    TickLabelsResponse,
    TitleResponse,
    TrendlineResponse,
    TrendlinesResponse,
    ValidationResponse,
    ValidationsResponse,
    VerticalPageBreakResponse,
    VerticalPageBreaksResponse,
    WallsResponse,
    WorkbookReplaceResponse,
    WorkbookResponse,
    WorkbookSettingsResponse,
    WorkbooksResponse,
    WorksheetReplaceResponse,
    WorksheetResponse,
    WorksheetsResponse,
    BatchConvertRequest,
    BatchLockRequest,
    BatchProtectRequest,
    BatchSplitRequest,
    ColorFilterRequest,
    ConvertParameter,
    CreatePivotTableRequest,
    ImportJsonRequest,
    ImportXMLRequest,
    MatchConditionRequest,
    PasswordRequest,
    PivotTableFieldRequest,
    ProtectWorkbookRequest,
    RangeCopyRequest,
    RangeSetOutlineBorderRequest,
    RangeSetStyleRequest,
    RangeSortRequest,
    TableTotalRequest,
    TextWaterMarkerRequest,
    WorkbookEncryptionRequest,
    WorkbookProtectionRequest,
    WorksheetMovingRequest,
    ImageOrPrintOptions,
    RenderingFont,
    RenderingWatermark,
    PivotField,
    PivotFilter,
    PivotItem,
    PivotTable,
    PivotTables,
    CustomParserConfig,
    Import2DimensionDoubleArrayOption,
    Import2DimensionIntArrayOption,
    Import2DimensionStringArrayOption,
    CellValue,
    ImportBatchDataOption,
    ImportCSVDataOption,
    ImportDoubleArrayOption,
    ImportIntArrayOption,
    ImportOption,
    ImportPictureOption,
    ImportPosition,
    ImportStringArrayOption,
    ArcShape,
    Area,
    AutoShape,
    AutoShapes,
    Button,
    CellsDrawing,
    CheckBox,
    ComboBox,
    CommentShape,
    FillFormat,
    Form,
    Forms,
    GradientFill,
    GradientFillStop,
    GroupBox,
    GroupShape,
    Label,
    Line,
    LineFormat,
    LineShape,
    ListBox,
    OleObject,
    OleObjects,
    Oval,
    PatternFill,
    PicFormatOption,
    Picture,
    Pictures,
    RadioButton,
    RectangleShape,
    ScrollBar,
    ShadowEffect,
    Shape,
    Shapes,
    SolidFill,
    Spinner,
    TextBox,
    TextureFill,
    TilePicOption,
    DigitalSignature,
    Axis,
    Chart,
    ChartArea,
    ChartDataTable,
    ChartFrame,
    ChartGlobalizationSettings,
    ChartPoint,
    ChartPoints,
    Charts,
    ChartShape,
    DataLabels,
    DisplayUnitLabel,
    DropBars,
    ErrorBar,
    Floor,
    Legend,
    LegendEntries,
    LegendEntry,
    Marker,
    PlotArea,
    Series,
    SeriesItems,
    Sparkline,
    SparklineGroup,
    SparklineGroups,
    TickLabels,
    Title,
    Trendline,
    Trendlines,
    Walls,
    Error,
    ErrorDetails,
};

export {enumsMap, typeMap};

/// Get auto filters description in worksheet.   
export class GetWorksheetAutoFilterRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetAutoFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/autoFilter".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds date filter in worksheet.   
export class PutWorksheetDateFilterRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the range to which the specified AutoFilter applies.  
    public range: string;
    /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0).  
    public fieldIndex: number;
    /// Specifies how to group dateTime values(Day,Hour,Minute,Month,Second,Year).  
    public dateTimeGroupingType: string;
    /// The year.  
    public year: number;
    /// The month.  
    public month: number;
    /// The day.  
    public day: number;
    /// The hour.  
    public hour: number;
    /// The minute.  
    public minute: number;
    /// The second.  
    public second: number;
    /// Match all blank or not blank cell in the list.(true/false)  
    public matchBlanks: boolean;
    /// If true, hide the filtered rows.  
    public refresh: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetDateFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/autoFilter/dateFilter".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Represents the range to which the specified AutoFilter applies. 
        // verify required parameter 'range' is not null or undefined
        if (this.range === null || this.range === undefined) {
            throw new Error('Required parameter "range" was null or undefined when calling PutWorksheetDateFilter.');
        }
        /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0). 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling PutWorksheetDateFilter.');
        }
        /// Specifies how to group dateTime values(Day,Hour,Minute,Month,Second,Year). 
        // verify required parameter 'dateTimeGroupingType' is not null or undefined
        if (this.dateTimeGroupingType === null || this.dateTimeGroupingType === undefined) {
            throw new Error('Required parameter "dateTimeGroupingType" was null or undefined when calling PutWorksheetDateFilter.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "dateTimeGroupingType", this.dateTimeGroupingType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "year", this.year);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "month", this.month);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "day", this.day);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "hour", this.hour);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "minute", this.minute);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "second", this.second);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "matchBlanks", this.matchBlanks);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "refresh", this.refresh);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds a filter for a filter column in worksheet.
///                
export class PutWorksheetFilterRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the range to which the specified AutoFilter applies.  
    public range: string;
    /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0).  
    public fieldIndex: number;
    /// The custom criteria.  
    public criteria: string;
    /// Match all blank or  not blank cell in the list.(true/false)  
    public matchBlanks: boolean;
    /// If true, hide the filtered rows.  
    public refresh: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/autoFilter/filter".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Represents the range to which the specified AutoFilter applies. 
        // verify required parameter 'range' is not null or undefined
        if (this.range === null || this.range === undefined) {
            throw new Error('Required parameter "range" was null or undefined when calling PutWorksheetFilter.');
        }
        /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0). 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling PutWorksheetFilter.');
        }
        /// The custom criteria. 
        // verify required parameter 'criteria' is not null or undefined
        if (this.criteria === null || this.criteria === undefined) {
            throw new Error('Required parameter "criteria" was null or undefined when calling PutWorksheetFilter.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "criteria", this.criteria);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "matchBlanks", this.matchBlanks);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "refresh", this.refresh);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds an icon filter in worksheet.   
export class PutWorksheetIconFilterRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the range to which the specified AutoFilter applies.  
    public range: string;
    /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0).  
    public fieldIndex: number;
    /// The icon set type.  
    public iconSetType: string;
    /// The icon id.  
    public iconId: number;
    /// Match all blank or  not blank cell in the list.(true/false)  
    public matchBlanks: boolean;
    /// If true, hide the filtered rows.  
    public refresh: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetIconFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/autoFilter/iconFilter".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Represents the range to which the specified AutoFilter applies. 
        // verify required parameter 'range' is not null or undefined
        if (this.range === null || this.range === undefined) {
            throw new Error('Required parameter "range" was null or undefined when calling PutWorksheetIconFilter.');
        }
        /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0). 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling PutWorksheetIconFilter.');
        }
        /// The icon set type. 
        // verify required parameter 'iconSetType' is not null or undefined
        if (this.iconSetType === null || this.iconSetType === undefined) {
            throw new Error('Required parameter "iconSetType" was null or undefined when calling PutWorksheetIconFilter.');
        }
        /// The icon id. 
        // verify required parameter 'iconId' is not null or undefined
        if (this.iconId === null || this.iconId === undefined) {
            throw new Error('Required parameter "iconId" was null or undefined when calling PutWorksheetIconFilter.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "iconSetType", this.iconSetType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "iconId", this.iconId);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "matchBlanks", this.matchBlanks);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "refresh", this.refresh);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Filters a list with a custom criteria in worksheet.
///                
export class PutWorksheetCustomFilterRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the range to which the specified AutoFilter applies.  
    public range: string;
    /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0).  
    public fieldIndex: number;
    /// The filter operator type  
    public operatorType1: string;
    /// The custom criteria.  
    public criteria1: string;
    /// true/false  
    public isAnd: boolean;
      
    public operatorType2: string;
    /// The custom criteria.  
    public criteria2: string;
    /// Match all blank or  not blank cell in the list.(true/false)  
    public matchBlanks: boolean;
    /// If true, hide the filtered rows.  
    public refresh: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetCustomFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/autoFilter/custom".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Represents the range to which the specified AutoFilter applies. 
        // verify required parameter 'range' is not null or undefined
        if (this.range === null || this.range === undefined) {
            throw new Error('Required parameter "range" was null or undefined when calling PutWorksheetCustomFilter.');
        }
        /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0). 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling PutWorksheetCustomFilter.');
        }
        /// The filter operator type 
        // verify required parameter 'operatorType1' is not null or undefined
        if (this.operatorType1 === null || this.operatorType1 === undefined) {
            throw new Error('Required parameter "operatorType1" was null or undefined when calling PutWorksheetCustomFilter.');
        }
        /// The custom criteria. 
        // verify required parameter 'criteria1' is not null or undefined
        if (this.criteria1 === null || this.criteria1 === undefined) {
            throw new Error('Required parameter "criteria1" was null or undefined when calling PutWorksheetCustomFilter.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "operatorType1", this.operatorType1);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "criteria1", this.criteria1);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isAnd", this.isAnd);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "operatorType2", this.operatorType2);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "criteria2", this.criteria2);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "matchBlanks", this.matchBlanks);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "refresh", this.refresh);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds a dynamic filter in worksheet.   
export class PutWorksheetDynamicFilterRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the range to which the specified AutoFilter applies.  
    public range: string;
    /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0).  
    public fieldIndex: number;
    /// Dynamic filter type.  
    public dynamicFilterType: string;
    /// Match all blank or  not blank cell in the list.(true/false)  
    public matchBlanks: boolean;
    /// If true, hide the filtered rows.  
    public refresh: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetDynamicFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/autoFilter/dynamicFilter".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Represents the range to which the specified AutoFilter applies. 
        // verify required parameter 'range' is not null or undefined
        if (this.range === null || this.range === undefined) {
            throw new Error('Required parameter "range" was null or undefined when calling PutWorksheetDynamicFilter.');
        }
        /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0). 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling PutWorksheetDynamicFilter.');
        }
        /// Dynamic filter type. 
        // verify required parameter 'dynamicFilterType' is not null or undefined
        if (this.dynamicFilterType === null || this.dynamicFilterType === undefined) {
            throw new Error('Required parameter "dynamicFilterType" was null or undefined when calling PutWorksheetDynamicFilter.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "dynamicFilterType", this.dynamicFilterType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "matchBlanks", this.matchBlanks);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "refresh", this.refresh);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Filters the top 10 item in the list in worksheet   
export class PutWorksheetFilterTop10Request  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the range to which the specified AutoFilter applies.  
    public range: string;
    /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0).  
    public fieldIndex: number;
    /// Indicates whether filter from top or bottom  
    public isTop: boolean;
    /// Indicates whether the items is percent or count  
    public isPercent: boolean;
    /// The item count  
    public itemCount: number;
    /// Match all blank or  not blank cell in the list.(true/false)  
    public matchBlanks: boolean;
    /// If true, hide the filtered rows.  
    public refresh: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetFilterTop10Request >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/autoFilter/filterTop10".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Represents the range to which the specified AutoFilter applies. 
        // verify required parameter 'range' is not null or undefined
        if (this.range === null || this.range === undefined) {
            throw new Error('Required parameter "range" was null or undefined when calling PutWorksheetFilterTop10.');
        }
        /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0). 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling PutWorksheetFilterTop10.');
        }
        /// Indicates whether filter from top or bottom 
        // verify required parameter 'isTop' is not null or undefined
        if (this.isTop === null || this.isTop === undefined) {
            throw new Error('Required parameter "isTop" was null or undefined when calling PutWorksheetFilterTop10.');
        }
        /// Indicates whether the items is percent or count 
        // verify required parameter 'isPercent' is not null or undefined
        if (this.isPercent === null || this.isPercent === undefined) {
            throw new Error('Required parameter "isPercent" was null or undefined when calling PutWorksheetFilterTop10.');
        }
        /// The item count 
        // verify required parameter 'itemCount' is not null or undefined
        if (this.itemCount === null || this.itemCount === undefined) {
            throw new Error('Required parameter "itemCount" was null or undefined when calling PutWorksheetFilterTop10.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isTop", this.isTop);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isPercent", this.isPercent);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "itemCount", this.itemCount);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "matchBlanks", this.matchBlanks);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "refresh", this.refresh);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds a color filter in worksheet.   
export class PutWorksheetColorFilterRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the range to which the specified AutoFilter applies.  
    public range: string;
    /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0).  
    public fieldIndex: number;
    /// color filter request.  
    public colorFilter: ColorFilterRequest;
    /// Match all blank or  not blank cell in the list.(true/false)  
    public matchBlanks: boolean;
    /// If true, hide the filtered rows.  
    public refresh: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetColorFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/autoFilter/colorFilter".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Represents the range to which the specified AutoFilter applies. 
        // verify required parameter 'range' is not null or undefined
        if (this.range === null || this.range === undefined) {
            throw new Error('Required parameter "range" was null or undefined when calling PutWorksheetColorFilter.');
        }
        /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0). 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling PutWorksheetColorFilter.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "matchBlanks", this.matchBlanks);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "refresh", this.refresh);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.colorFilter == null) ? null :   ObjectSerializer.serialize( this.colorFilter,this.colorFilter.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Match all blank cell in the list.   
export class PostWorksheetMatchBlanksRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0).  
    public fieldIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetMatchBlanksRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/autoFilter/matchBlanks".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0). 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling PostWorksheetMatchBlanks.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Match all not blank cell in the list.
///                
export class PostWorksheetMatchNonBlanksRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0).  
    public fieldIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetMatchNonBlanksRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/autoFilter/matchNonBlanks".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0). 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling PostWorksheetMatchNonBlanks.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Refresh auto filters in worksheet.   
export class PostWorksheetAutoFilterRefreshRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetAutoFilterRefreshRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/autoFilter/refresh".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Removes a date filter in worksheet.
///                
export class DeleteWorksheetDateFilterRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0).  
    public fieldIndex: number;
    /// Specifies how to group dateTime values.  
    public dateTimeGroupingType: string;
    /// The year.  
    public year: number;
    /// The month.  
    public month: number;
    /// The day.  
    public day: number;
    /// The hour.  
    public hour: number;
    /// The minute.  
    public minute: number;
    /// The second.  
    public second: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetDateFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/autoFilter/dateFilter".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0). 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling DeleteWorksheetDateFilter.');
        }
        /// Specifies how to group dateTime values. 
        // verify required parameter 'dateTimeGroupingType' is not null or undefined
        if (this.dateTimeGroupingType === null || this.dateTimeGroupingType === undefined) {
            throw new Error('Required parameter "dateTimeGroupingType" was null or undefined when calling DeleteWorksheetDateFilter.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "dateTimeGroupingType", this.dateTimeGroupingType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "year", this.year);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "month", this.month);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "day", this.day);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "hour", this.hour);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "minute", this.minute);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "second", this.second);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Deletes a filter for a filter column in worksheet.
///                
export class DeleteWorksheetFilterRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0).  
    public fieldIndex: number;
    /// The custom criteria.  
    public criteria: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/autoFilter/filter".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0). 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling DeleteWorksheetFilter.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "criteria", this.criteria);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get autoshapes description in worksheet.   
export class GetWorksheetAutoshapesRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Document's folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetAutoshapesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/autoshapes".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get autoshape description in some format.   
export class GetWorksheetAutoshapeWithFormatRequest  {
    /// The workbook name.  
    public name: string;
    /// Worksheet name.  
    public sheetName: string;
    /// The autoshape number.  
    public autoshapeNumber: number;
    /// Autoshape conversion format.  
    public format: string;
    /// The document folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetAutoshapeWithFormatRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/autoshapes/{autoshapeNumber}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "autoshapeNumber" + "}", String(this.autoshapeNumber));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostBatchConvertRequest  {
      
    public batchConvertRequest: BatchConvertRequest;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostBatchConvertRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/batch/convert";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.batchConvertRequest == null) ? null :   ObjectSerializer.serialize( this.batchConvertRequest,this.batchConvertRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostBatchProtectRequest  {
      
    public batchProtectRequest: BatchProtectRequest;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostBatchProtectRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/batch/protect";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.batchProtectRequest == null) ? null :   ObjectSerializer.serialize( this.batchProtectRequest,this.batchProtectRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostBatchLockRequest  {
      
    public batchLockRequest: BatchLockRequest;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostBatchLockRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/batch/lock";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.batchLockRequest == null) ? null :   ObjectSerializer.serialize( this.batchLockRequest,this.batchLockRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostBatchUnlockRequest  {
      
    public batchLockRequest: BatchLockRequest;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostBatchUnlockRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/batch/unlock";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.batchLockRequest == null) ? null :   ObjectSerializer.serialize( this.batchLockRequest,this.batchLockRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostBatchSplitRequest  {
      
    public batchSplitRequest: BatchSplitRequest;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostBatchSplitRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/batch/split";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.batchSplitRequest == null) ? null :   ObjectSerializer.serialize( this.batchSplitRequest,this.batchSplitRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Clear cells contents in worksheet.   
export class PostClearContentsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the range to which the specified cells applies.  
    public range: string;
    /// The start row.  
    public startRow: number;
    /// The start column.  
    public startColumn: number;
    /// The end row.  
    public endRow: number;
    /// The end column.  
    public endColumn: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostClearContentsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/clearcontents".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startRow", this.startRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startColumn", this.startColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endRow", this.endRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endColumn", this.endColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Clear cells formats in worksheet.   
export class PostClearFormatsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the range to which the specified cells applies.  
    public range: string;
    /// The start row.  
    public startRow: number;
    /// The start column.  
    public startColumn: number;
    /// The end row.  
    public endRow: number;
    /// The end column.  
    public endColumn: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostClearFormatsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/clearformats".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startRow", this.startRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startColumn", this.startColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endRow", this.endRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endColumn", this.endColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Updates cell's range style in worksheet.   
export class PostUpdateWorksheetRangeStyleRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the range to which the specified cells applies.  
    public range: string;
    /// Style with update style settings.  
    public style: Style;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUpdateWorksheetRangeStyleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/style".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Represents the range to which the specified cells applies. 
        // verify required parameter 'range' is not null or undefined
        if (this.range === null || this.range === undefined) {
            throw new Error('Required parameter "range" was null or undefined when calling PostUpdateWorksheetRangeStyle.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.style == null) ? null :   ObjectSerializer.serialize( this.style,this.style.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Merge cells in worksheet.   
export class PostWorksheetMergeRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The start row.  
    public startRow: number;
    /// The start column.  
    public startColumn: number;
    /// The total rows  
    public totalRows: number;
    /// The total columns.  
    public totalColumns: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetMergeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/merge".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The start row. 
        // verify required parameter 'startRow' is not null or undefined
        if (this.startRow === null || this.startRow === undefined) {
            throw new Error('Required parameter "startRow" was null or undefined when calling PostWorksheetMerge.');
        }
        /// The start column. 
        // verify required parameter 'startColumn' is not null or undefined
        if (this.startColumn === null || this.startColumn === undefined) {
            throw new Error('Required parameter "startColumn" was null or undefined when calling PostWorksheetMerge.');
        }
        /// The total rows 
        // verify required parameter 'totalRows' is not null or undefined
        if (this.totalRows === null || this.totalRows === undefined) {
            throw new Error('Required parameter "totalRows" was null or undefined when calling PostWorksheetMerge.');
        }
        /// The total columns. 
        // verify required parameter 'totalColumns' is not null or undefined
        if (this.totalColumns === null || this.totalColumns === undefined) {
            throw new Error('Required parameter "totalColumns" was null or undefined when calling PostWorksheetMerge.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startRow", this.startRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startColumn", this.startColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalRows", this.totalRows);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalColumns", this.totalColumns);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Unmerge cells in worksheet.   
export class PostWorksheetUnmergeRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The start row.  
    public startRow: number;
    /// The start column.  
    public startColumn: number;
    /// The total rows  
    public totalRows: number;
    /// The total columns.  
    public totalColumns: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetUnmergeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/unmerge".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The start row. 
        // verify required parameter 'startRow' is not null or undefined
        if (this.startRow === null || this.startRow === undefined) {
            throw new Error('Required parameter "startRow" was null or undefined when calling PostWorksheetUnmerge.');
        }
        /// The start column. 
        // verify required parameter 'startColumn' is not null or undefined
        if (this.startColumn === null || this.startColumn === undefined) {
            throw new Error('Required parameter "startColumn" was null or undefined when calling PostWorksheetUnmerge.');
        }
        /// The total rows 
        // verify required parameter 'totalRows' is not null or undefined
        if (this.totalRows === null || this.totalRows === undefined) {
            throw new Error('Required parameter "totalRows" was null or undefined when calling PostWorksheetUnmerge.');
        }
        /// The total columns. 
        // verify required parameter 'totalColumns' is not null or undefined
        if (this.totalColumns === null || this.totalColumns === undefined) {
            throw new Error('Required parameter "totalColumns" was null or undefined when calling PostWorksheetUnmerge.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startRow", this.startRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startColumn", this.startColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalRows", this.totalRows);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalColumns", this.totalColumns);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets cells description in some format.   
export class GetWorksheetCellsRequest  {
    /// Document name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Begginig offset.  
    public offest: number;
    /// Maximum amount of cells in the response.  
    public count: number;
    /// Document's folder name.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetCellsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "offest", this.offest);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "count", this.count);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets cell data by cell or method name in worksheet.   
export class GetWorksheetCellRequest  {
    /// Document name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The cell's or method name. (Method name like firstcell, endcell etc.)  
    public cellOrMethodName: string;
    /// Document's folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetCellRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/{cellOrMethodName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellOrMethodName" + "}", String(this.cellOrMethodName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets cell's style description in worksheet.   
export class GetWorksheetCellStyleRequest  {
    /// Document name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Cell's name.  
    public cellName: string;
    /// Document's folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetCellStyleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/{cellName}/style".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellName" + "}", String(this.cellName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Sets cell value by cell name in worksheet.   
export class PostWorksheetCellSetValueRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The cell name.  
    public cellName: string;
    /// The cell value.  
    public value: string;
    /// The value type.  
    public type: string;
    /// Formula for cell  
    public formula: string;
    /// The document folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellSetValueRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/{cellName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellName" + "}", String(this.cellName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "value", this.value);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "type", this.type);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "formula", this.formula);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Sets cell's style by cell name in worksheet.   
export class PostUpdateWorksheetCellStyleRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The cell name.  
    public cellName: string;
    /// Style with update style settings.  
    public style: Style;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUpdateWorksheetCellStyleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/{cellName}/style".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellName" + "}", String(this.cellName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.style == null) ? null :   ObjectSerializer.serialize( this.style,this.style.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Sets the value of the range in worksheet.   
export class PostSetCellRangeValueRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Cell area (like "A1:C2")  
    public cellarea: string;
    /// Range value  
    public value: string;
    /// Value data type (like "int")  
    public type: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostSetCellRangeValueRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Cell area (like "A1:C2") 
        // verify required parameter 'cellarea' is not null or undefined
        if (this.cellarea === null || this.cellarea === undefined) {
            throw new Error('Required parameter "cellarea" was null or undefined when calling PostSetCellRangeValue.');
        }
        /// Range value 
        // verify required parameter 'value' is not null or undefined
        if (this.value === null || this.value === undefined) {
            throw new Error('Required parameter "value" was null or undefined when calling PostSetCellRangeValue.');
        }
        /// Value data type (like "int") 
        // verify required parameter 'type' is not null or undefined
        if (this.type === null || this.type === undefined) {
            throw new Error('Required parameter "type" was null or undefined when calling PostSetCellRangeValue.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellarea", this.cellarea);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "value", this.value);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "type", this.type);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Copies data to destination cell from a source cell in worksheet.   
export class PostCopyCellIntoCellRequest  {
    /// The workbook name.  
    public name: string;
    /// Destination cell name  
    public destCellName: string;
    /// Destination worksheet name.  
    public sheetName: string;
    /// Source worksheet name.  
    public worksheet: string;
    /// Source cell name  
    public cellname: string;
    /// Source row  
    public row: number;
    /// Source column  
    public column: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostCopyCellIntoCellRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/{destCellName}/copy".replace("{" + "name" + "}", String(this.name)).replace("{" + "destCellName" + "}", String(this.destCellName)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Source worksheet name. 
        // verify required parameter 'worksheet' is not null or undefined
        if (this.worksheet === null || this.worksheet === undefined) {
            throw new Error('Required parameter "worksheet" was null or undefined when calling PostCopyCellIntoCell.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "worksheet", this.worksheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellname", this.cellname);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "row", this.row);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "column", this.column);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets the html string which contains data and some formats in this cell.   
export class GetCellHtmlStringRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The cell name.  
    public cellName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetCellHtmlStringRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/{cellName}/htmlstring".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellName" + "}", String(this.cellName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Sets the html string which contains data and some formats in this cell.   
export class PostSetCellHtmlStringRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The cell name.  
    public cellName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostSetCellHtmlStringRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/{cellName}/htmlstring".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellName" + "}", String(this.cellName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Calculates cell formula in worksheet.   
export class PostCellCalculateRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The cell name.  
    public cellName: string;
    /// Calculation Options  
    public options: CalculationOptions;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostCellCalculateRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/{cellName}/calculate".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellName" + "}", String(this.cellName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.options == null) ? null :   ObjectSerializer.serialize( this.options,this.options.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Sets cell characters in worksheet.   
export class PostCellCharactersRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The cell name.  
    public cellName: string;
      
    public options: Array<FontSetting>;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostCellCharactersRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/{cellName}/characters".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellName" + "}", String(this.cellName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.options == null) ? null :   ObjectSerializer.serialize( this.options,this.options.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get worksheet columns description.   
export class GetWorksheetColumnsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public offset: number;
    /// Storage name.  
    public count: number;
    /// The workdook folder.  
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetColumnsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/columns/".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "offset", this.offset);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "count", this.count);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Sets worksheet column width.   
export class PostSetWorksheetColumnWidthRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The column index.  
    public columnIndex: number;
    /// Gets and sets the column width in unit of characters.  
    public width: number;
      
    public count: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostSetWorksheetColumnWidthRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/columns/{columnIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "columnIndex" + "}", String(this.columnIndex));
        const queryParameters: any = {};
        /// Gets and sets the column width in unit of characters. 
        // verify required parameter 'width' is not null or undefined
        if (this.width === null || this.width === undefined) {
            throw new Error('Required parameter "width" was null or undefined when calling PostSetWorksheetColumnWidth.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "width", this.width);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "count", this.count);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets worksheet column data by column's index.   
export class GetWorksheetColumnRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The column index.  
    public columnIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetColumnRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/columns/{columnIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "columnIndex" + "}", String(this.columnIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Insert worksheet columns.   
export class PutInsertWorksheetColumnsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The column index.  
    public columnIndex: number;
    /// The number of columns.  
    public columns: number;
    /// Indicates if references in other worksheets will be updated.  
    public updateReference: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutInsertWorksheetColumnsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/columns/{columnIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "columnIndex" + "}", String(this.columnIndex));
        const queryParameters: any = {};
        /// The number of columns. 
        // verify required parameter 'columns' is not null or undefined
        if (this.columns === null || this.columns === undefined) {
            throw new Error('Required parameter "columns" was null or undefined when calling PutInsertWorksheetColumns.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "columns", this.columns);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "updateReference", this.updateReference);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete worksheet columns.   
export class DeleteWorksheetColumnsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The column index.  
    public columnIndex: number;
    /// The number of columns.  
    public columns: number;
    /// Indicates if references in other worksheets will be updated.  
    public updateReference: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetColumnsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/columns/{columnIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "columnIndex" + "}", String(this.columnIndex));
        const queryParameters: any = {};
        /// The number of columns. 
        // verify required parameter 'columns' is not null or undefined
        if (this.columns === null || this.columns === undefined) {
            throw new Error('Required parameter "columns" was null or undefined when calling DeleteWorksheetColumns.');
        }
        /// Indicates if references in other worksheets will be updated. 
        // verify required parameter 'updateReference' is not null or undefined
        if (this.updateReference === null || this.updateReference === undefined) {
            throw new Error('Required parameter "updateReference" was null or undefined when calling DeleteWorksheetColumns.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "columns", this.columns);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "updateReference", this.updateReference);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Hide worksheet columns.   
export class PostHideWorksheetColumnsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The begin column index to be operated.  
    public startColumn: number;
    /// Number of columns to be operated.  
    public totalColumns: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostHideWorksheetColumnsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/columns/hide".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The begin column index to be operated. 
        // verify required parameter 'startColumn' is not null or undefined
        if (this.startColumn === null || this.startColumn === undefined) {
            throw new Error('Required parameter "startColumn" was null or undefined when calling PostHideWorksheetColumns.');
        }
        /// Number of columns to be operated. 
        // verify required parameter 'totalColumns' is not null or undefined
        if (this.totalColumns === null || this.totalColumns === undefined) {
            throw new Error('Required parameter "totalColumns" was null or undefined when calling PostHideWorksheetColumns.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startColumn", this.startColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalColumns", this.totalColumns);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Unhide worksheet columns.   
export class PostUnhideWorksheetColumnsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The begin column index to be operated.  
    public startColumn: number;
    /// Number of columns to be operated.  
    public totalColumns: number;
    /// Gets and sets the column width in unit of characters.  
    public width: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUnhideWorksheetColumnsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/columns/unhide".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The begin column index to be operated. 
        // verify required parameter 'startColumn' is not null or undefined
        if (this.startColumn === null || this.startColumn === undefined) {
            throw new Error('Required parameter "startColumn" was null or undefined when calling PostUnhideWorksheetColumns.');
        }
        /// Number of columns to be operated. 
        // verify required parameter 'totalColumns' is not null or undefined
        if (this.totalColumns === null || this.totalColumns === undefined) {
            throw new Error('Required parameter "totalColumns" was null or undefined when calling PostUnhideWorksheetColumns.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startColumn", this.startColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalColumns", this.totalColumns);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "width", this.width);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Group worksheet columns.   
export class PostGroupWorksheetColumnsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The first column index to be operated.  
    public firstIndex: number;
    /// The last column index to be operated.  
    public lastIndex: number;
    /// columns visible state  
    public hide: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostGroupWorksheetColumnsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/columns/group".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The first column index to be operated. 
        // verify required parameter 'firstIndex' is not null or undefined
        if (this.firstIndex === null || this.firstIndex === undefined) {
            throw new Error('Required parameter "firstIndex" was null or undefined when calling PostGroupWorksheetColumns.');
        }
        /// The last column index to be operated. 
        // verify required parameter 'lastIndex' is not null or undefined
        if (this.lastIndex === null || this.lastIndex === undefined) {
            throw new Error('Required parameter "lastIndex" was null or undefined when calling PostGroupWorksheetColumns.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "firstIndex", this.firstIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "lastIndex", this.lastIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "hide", this.hide);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Ungroup worksheet columns.   
export class PostUngroupWorksheetColumnsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The first column index to be operated.  
    public firstIndex: number;
    /// The last column index to be operated.  
    public lastIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUngroupWorksheetColumnsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/columns/ungroup".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The first column index to be operated. 
        // verify required parameter 'firstIndex' is not null or undefined
        if (this.firstIndex === null || this.firstIndex === undefined) {
            throw new Error('Required parameter "firstIndex" was null or undefined when calling PostUngroupWorksheetColumns.');
        }
        /// The last column index to be operated. 
        // verify required parameter 'lastIndex' is not null or undefined
        if (this.lastIndex === null || this.lastIndex === undefined) {
            throw new Error('Required parameter "lastIndex" was null or undefined when calling PostUngroupWorksheetColumns.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "firstIndex", this.firstIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "lastIndex", this.lastIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Copy data to destination columns from source columns in worksheet.   
export class PostCopyWorksheetColumnsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Source column index  
    public sourceColumnIndex: number;
    /// Destination column index  
    public destinationColumnIndex: number;
    /// The copied column number  
    public columnNumber: number;
    /// The destination worksheet name.  
    public worksheet: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostCopyWorksheetColumnsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/columns/copy".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Source column index 
        // verify required parameter 'sourceColumnIndex' is not null or undefined
        if (this.sourceColumnIndex === null || this.sourceColumnIndex === undefined) {
            throw new Error('Required parameter "sourceColumnIndex" was null or undefined when calling PostCopyWorksheetColumns.');
        }
        /// Destination column index 
        // verify required parameter 'destinationColumnIndex' is not null or undefined
        if (this.destinationColumnIndex === null || this.destinationColumnIndex === undefined) {
            throw new Error('Required parameter "destinationColumnIndex" was null or undefined when calling PostCopyWorksheetColumns.');
        }
        /// The copied column number 
        // verify required parameter 'columnNumber' is not null or undefined
        if (this.columnNumber === null || this.columnNumber === undefined) {
            throw new Error('Required parameter "columnNumber" was null or undefined when calling PostCopyWorksheetColumns.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sourceColumnIndex", this.sourceColumnIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destinationColumnIndex", this.destinationColumnIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "columnNumber", this.columnNumber);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "worksheet", this.worksheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Sets column style in worksheet.   
export class PostColumnStyleRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The column index.  
    public columnIndex: number;
    /// Represents display style of excel document,such as font,color,alignment,border,etc.  
    public style: Style;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostColumnStyleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/columns/{columnIndex}/style".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "columnIndex" + "}", String(this.columnIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.style == null) ? null :   ObjectSerializer.serialize( this.style,this.style.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get rows description in worksheet.   
export class GetWorksheetRowsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public offset: number;
    /// Storage name.  
    public count: number;
      
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetRowsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/rows/".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "offset", this.offset);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "count", this.count);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets row data by row's index in worksheet.   
export class GetWorksheetRowRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The row index.  
    public rowIndex: number;
    /// The workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetRowRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/rows/{rowIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "rowIndex" + "}", String(this.rowIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Deletes row in worksheet.   
export class DeleteWorksheetRowRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The row index.  
    public rowIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetRowRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/rows/{rowIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "rowIndex" + "}", String(this.rowIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete several rows in worksheet.   
export class DeleteWorksheetRowsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The begin row index to be operated.  
    public startrow: number;
    /// Number of rows to be operated.  
    public totalRows: number;
    /// Indicates if update references in other worksheets.  
    public updateReference: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetRowsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/rows/".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The begin row index to be operated. 
        // verify required parameter 'startrow' is not null or undefined
        if (this.startrow === null || this.startrow === undefined) {
            throw new Error('Required parameter "startrow" was null or undefined when calling DeleteWorksheetRows.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startrow", this.startrow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalRows", this.totalRows);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "updateReference", this.updateReference);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Insert several new rows in worksheet.   
export class PutInsertWorksheetRowsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The begin row index to be operated.  
    public startrow: number;
    /// Number of rows to be operated.  
    public totalRows: number;
    /// Indicates if update references in other worksheets.  
    public updateReference: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutInsertWorksheetRowsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/rows/".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The begin row index to be operated. 
        // verify required parameter 'startrow' is not null or undefined
        if (this.startrow === null || this.startrow === undefined) {
            throw new Error('Required parameter "startrow" was null or undefined when calling PutInsertWorksheetRows.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startrow", this.startrow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalRows", this.totalRows);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "updateReference", this.updateReference);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Inserts new row in worksheet.   
export class PutInsertWorksheetRowRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The new row index.  
    public rowIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutInsertWorksheetRowRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/rows/{rowIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "rowIndex" + "}", String(this.rowIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Updates row in worksheet.   
export class PostUpdateWorksheetRowRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The row index.  
    public rowIndex: number;
    /// The new row height.  
    public height: number;
      
    public count: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUpdateWorksheetRowRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/rows/{rowIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "rowIndex" + "}", String(this.rowIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "height", this.height);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "count", this.count);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Hide rows in worksheet.   
export class PostHideWorksheetRowsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The begin row index to be operated.  
    public startrow: number;
    /// Number of rows to be operated.  
    public totalRows: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostHideWorksheetRowsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/rows/hide".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The begin row index to be operated. 
        // verify required parameter 'startrow' is not null or undefined
        if (this.startrow === null || this.startrow === undefined) {
            throw new Error('Required parameter "startrow" was null or undefined when calling PostHideWorksheetRows.');
        }
        /// Number of rows to be operated. 
        // verify required parameter 'totalRows' is not null or undefined
        if (this.totalRows === null || this.totalRows === undefined) {
            throw new Error('Required parameter "totalRows" was null or undefined when calling PostHideWorksheetRows.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startrow", this.startrow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalRows", this.totalRows);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Unhide rows in worksheet.   
export class PostUnhideWorksheetRowsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The begin row index to be operated.  
    public startrow: number;
    /// Number of rows to be operated.  
    public totalRows: number;
    /// The new row height.  
    public height: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUnhideWorksheetRowsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/rows/unhide".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The begin row index to be operated. 
        // verify required parameter 'startrow' is not null or undefined
        if (this.startrow === null || this.startrow === undefined) {
            throw new Error('Required parameter "startrow" was null or undefined when calling PostUnhideWorksheetRows.');
        }
        /// Number of rows to be operated. 
        // verify required parameter 'totalRows' is not null or undefined
        if (this.totalRows === null || this.totalRows === undefined) {
            throw new Error('Required parameter "totalRows" was null or undefined when calling PostUnhideWorksheetRows.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startrow", this.startrow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalRows", this.totalRows);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "height", this.height);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Group rows in worksheet.   
export class PostGroupWorksheetRowsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The first row index to be operated.  
    public firstIndex: number;
    /// The last row index to be operated.  
    public lastIndex: number;
    /// rows visible state  
    public hide: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostGroupWorksheetRowsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/rows/group".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The first row index to be operated. 
        // verify required parameter 'firstIndex' is not null or undefined
        if (this.firstIndex === null || this.firstIndex === undefined) {
            throw new Error('Required parameter "firstIndex" was null or undefined when calling PostGroupWorksheetRows.');
        }
        /// The last row index to be operated. 
        // verify required parameter 'lastIndex' is not null or undefined
        if (this.lastIndex === null || this.lastIndex === undefined) {
            throw new Error('Required parameter "lastIndex" was null or undefined when calling PostGroupWorksheetRows.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "firstIndex", this.firstIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "lastIndex", this.lastIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "hide", this.hide);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Ungroup rows in worksheet.   
export class PostUngroupWorksheetRowsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The first row index to be operated.  
    public firstIndex: number;
    /// The last row index to be operated.  
    public lastIndex: number;
    /// Is all row to be operated  
    public isAll: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUngroupWorksheetRowsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/rows/ungroup".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The first row index to be operated. 
        // verify required parameter 'firstIndex' is not null or undefined
        if (this.firstIndex === null || this.firstIndex === undefined) {
            throw new Error('Required parameter "firstIndex" was null or undefined when calling PostUngroupWorksheetRows.');
        }
        /// The last row index to be operated. 
        // verify required parameter 'lastIndex' is not null or undefined
        if (this.lastIndex === null || this.lastIndex === undefined) {
            throw new Error('Required parameter "lastIndex" was null or undefined when calling PostUngroupWorksheetRows.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "firstIndex", this.firstIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "lastIndex", this.lastIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isAll", this.isAll);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Copies data and formats of some whole rows in worksheet.   
export class PostCopyWorksheetRowsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Source row index  
    public sourceRowIndex: number;
    /// Destination row index  
    public destinationRowIndex: number;
    /// The copied row number  
    public rowNumber: number;
    /// The worksheet name.  
    public worksheet: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostCopyWorksheetRowsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/rows/copy".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Source row index 
        // verify required parameter 'sourceRowIndex' is not null or undefined
        if (this.sourceRowIndex === null || this.sourceRowIndex === undefined) {
            throw new Error('Required parameter "sourceRowIndex" was null or undefined when calling PostCopyWorksheetRows.');
        }
        /// Destination row index 
        // verify required parameter 'destinationRowIndex' is not null or undefined
        if (this.destinationRowIndex === null || this.destinationRowIndex === undefined) {
            throw new Error('Required parameter "destinationRowIndex" was null or undefined when calling PostCopyWorksheetRows.');
        }
        /// The copied row number 
        // verify required parameter 'rowNumber' is not null or undefined
        if (this.rowNumber === null || this.rowNumber === undefined) {
            throw new Error('Required parameter "rowNumber" was null or undefined when calling PostCopyWorksheetRows.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sourceRowIndex", this.sourceRowIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destinationRowIndex", this.destinationRowIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "rowNumber", this.rowNumber);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "worksheet", this.worksheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Applies formats for a whole row in worksheet.
///                
export class PostRowStyleRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The row index.  
    public rowIndex: number;
    /// Style description.  
    public style: Style;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostRowStyleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/cells/rows/{rowIndex}/style".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "rowIndex" + "}", String(this.rowIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.style == null) ? null :   ObjectSerializer.serialize( this.style,this.style.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets cells description in some format.   
export class GetCellsCloudServicesHealthCheckRequest  {
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetCellsCloudServicesHealthCheckRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Aspose.Cells Cloud service health status check(old).    
export class GetCellsCloudServiceStatusRequest  {
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetCellsCloudServiceStatusRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/status/check";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets chart area description in worksheet.   
export class GetChartAreaRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// Original workbook folder.  
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetChartAreaRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/chartArea".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets chart area fill format description in worksheet.   
export class GetChartAreaFillFormatRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// Original workbook folder.  
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetChartAreaFillFormatRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/chartArea/fillFormat".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets chart area border description.   
export class GetChartAreaBorderRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// Original workbook folder.  
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetChartAreaBorderRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/chartArea/border".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get worksheet charts description.   
export class GetWorksheetChartsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetChartsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets chart in some format.   
export class GetWorksheetChartRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart number.  
    public chartNumber: number;
    /// Chart conversion format.(PNG/TIFF/JPEG/GIF/EMF/BMP)  
    public format: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetChartRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartNumber}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartNumber" + "}", String(this.chartNumber));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds new chart in worksheet.   
export class PutWorksheetAddChartRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Chart type, please refer property Type in chart resource.  
    public chartType: string;
    /// New chart upper left row.  
    public upperLeftRow: number;
    /// New chart upperleft column.  
    public upperLeftColumn: number;
    /// New chart lower right row.  
    public lowerRightRow: number;
    /// New chart lower right column.  
    public lowerRightColumn: number;
    /// Specifies values from which to plot the data series.   
    public area: string;
    /// Specifies whether to plot the series from a range of cell values by row or by column.   
    public isVertical: boolean;
    /// Gets or sets the range of category Axis values. It can be a range of cells (such as, "d1:e10").   
    public categoryData: string;
    /// Specifies whether auto update serial name.   
    public isAutoGetSerialName: boolean;
    /// Specifies chart title name.  
    public title: string;
    /// Original workbook folder.  
    public folder: string;
    /// Represents a specified chart's data label values display behavior. True displays the values. False to hide.  
    public dataLabels: boolean;
    /// Represents data label position(Center/InsideBase/InsideEnd/OutsideEnd/Above/Below/Left/Right/BestFit/Moved).  
    public dataLabelsPosition: string;
    /// The source is the data of the pivotTable. If PivotSource is not empty ,the chart is PivotChart.  
    public pivotTableSheet: string;
    /// The source is the data of the pivotTable.  
    public pivotTableName: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetAddChartRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Chart type, please refer property Type in chart resource. 
        // verify required parameter 'chartType' is not null or undefined
        if (this.chartType === null || this.chartType === undefined) {
            throw new Error('Required parameter "chartType" was null or undefined when calling PutWorksheetAddChart.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "chartType", this.chartType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "upperLeftRow", this.upperLeftRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "upperLeftColumn", this.upperLeftColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "lowerRightRow", this.lowerRightRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "lowerRightColumn", this.lowerRightColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "area", this.area);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isVertical", this.isVertical);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "categoryData", this.categoryData);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isAutoGetSerialName", this.isAutoGetSerialName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "title", this.title);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "dataLabels", this.dataLabels);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "dataLabelsPosition", this.dataLabelsPosition);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pivotTableSheet", this.pivotTableSheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pivotTableName", this.pivotTableName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Deletes a chart by index in worksheet.   
export class DeleteWorksheetDeleteChartRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetDeleteChartRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update chart propreties in worksheet.   
export class PostWorksheetChartRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// Represents a specified chart.  
    public chart: Chart;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetChartRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.chart == null) ? null :   ObjectSerializer.serialize( this.chart,this.chart.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets chart legend description in worksheet.   
export class GetWorksheetChartLegendRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetChartLegendRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/legend".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Updates chart legend in worksheet.   
export class PostWorksheetChartLegendRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
      
    public legend: Legend;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetChartLegendRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/legend".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.legend == null) ? null :   ObjectSerializer.serialize( this.legend,this.legend.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Show chart legend in worksheet.   
export class PutWorksheetChartLegendRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetChartLegendRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/legend".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Hides chart legend in worksheet.   
export class DeleteWorksheetChartLegendRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetChartLegendRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/legend".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Clear the charts in worksheets.   
export class DeleteWorksheetClearChartsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetClearChartsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets chart title description in worksheet.   
export class GetWorksheetChartTitleRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetChartTitleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/title".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update chart title in worksheet.   
export class PostWorksheetChartTitleRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// Chart title  
    public title: Title;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetChartTitleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/title".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.title == null) ? null :   ObjectSerializer.serialize( this.title,this.title.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add chart title / Set chart title visible   
export class PutWorksheetChartTitleRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// Chart title.  
    public title: Title;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetChartTitleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/title".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.title == null) ? null :   ObjectSerializer.serialize( this.title,this.title.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Hides chart title in worksheet.   
export class DeleteWorksheetChartTitleRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetChartTitleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/title".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class GetChartSeriesAxisRequest  {
      
    public name: string;
      
    public sheetName: string;
      
    public chartIndex: number;
      
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetChartSeriesAxisRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/seriesaxis".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class GetChartCategoryAxisRequest  {
      
    public name: string;
      
    public sheetName: string;
      
    public chartIndex: number;
      
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetChartCategoryAxisRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/categoryaxis".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class GetChartValueAxisRequest  {
      
    public name: string;
      
    public sheetName: string;
      
    public chartIndex: number;
      
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetChartValueAxisRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/valueaxis".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class GetChartSecondCategoryAxisRequest  {
      
    public name: string;
      
    public sheetName: string;
      
    public chartIndex: number;
      
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetChartSecondCategoryAxisRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/secondcategoryaxis".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class GetChartSecondValueAxisRequest  {
      
    public name: string;
      
    public sheetName: string;
      
    public chartIndex: number;
      
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetChartSecondValueAxisRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/secondvalueaxis".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostChartSeriesAxisRequest  {
      
    public name: string;
      
    public sheetName: string;
      
    public chartIndex: number;
      
    public axis: Axis;
      
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostChartSeriesAxisRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/seriesaxis".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.axis == null) ? null :   ObjectSerializer.serialize( this.axis,this.axis.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostChartCategoryAxisRequest  {
      
    public name: string;
      
    public sheetName: string;
      
    public chartIndex: number;
      
    public axis: Axis;
      
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostChartCategoryAxisRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/categoryaxis".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.axis == null) ? null :   ObjectSerializer.serialize( this.axis,this.axis.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostChartValueAxisRequest  {
      
    public name: string;
      
    public sheetName: string;
      
    public chartIndex: number;
      
    public axis: Axis;
      
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostChartValueAxisRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/valueaxis".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.axis == null) ? null :   ObjectSerializer.serialize( this.axis,this.axis.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostChartSecondCategoryAxisRequest  {
      
    public name: string;
      
    public sheetName: string;
      
    public chartIndex: number;
      
    public axis: Axis;
      
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostChartSecondCategoryAxisRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/secondcategoryaxis".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.axis == null) ? null :   ObjectSerializer.serialize( this.axis,this.axis.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostChartSecondValueAxisRequest  {
      
    public name: string;
      
    public sheetName: string;
      
    public chartIndex: number;
      
    public axis: Axis;
      
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostChartSecondValueAxisRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/secondvalueaxis".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.axis == null) ? null :   ObjectSerializer.serialize( this.axis,this.axis.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get conditional formattings description.   
export class GetWorksheetConditionalFormattingsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetConditionalFormattingsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/conditionalFormattings".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets conditional formatting description in worksheet.   
export class GetWorksheetConditionalFormattingRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The conditional formatting index.  
    public index: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetConditionalFormattingRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/conditionalFormattings/{index}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "index" + "}", String(this.index));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds a condition formatting in worksheet.   
export class PutWorksheetConditionalFormattingRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
      
    public formatcondition: FormatCondition;
    /// Adds a conditional formatted cell range.  
    public cellArea: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetConditionalFormattingRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/conditionalFormattings".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Adds a conditional formatted cell range. 
        // verify required parameter 'cellArea' is not null or undefined
        if (this.cellArea === null || this.cellArea === undefined) {
            throw new Error('Required parameter "cellArea" was null or undefined when calling PutWorksheetConditionalFormatting.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellArea", this.cellArea);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.formatcondition == null) ? null :   ObjectSerializer.serialize( this.formatcondition,this.formatcondition.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds a format condition in worksheet.   
export class PutWorksheetFormatConditionRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the Conditional Formatting element at the specified index.  
    public index: number;
    /// Adds a conditional formatted cell range.  
    public cellArea: string;
    /// Format condition type(CellValue/Expression/ColorScale/DataBar/IconSet/Top10/UniqueValues/DuplicateValues/ContainsText/NotContainsText/BeginsWith/EndsWith/ContainsBlanks/NotContainsBlanks/ContainsErrors/NotContainsErrors/TimePeriod/AboveAverage).  
    public type: string;
    /// Represents the operator type of conditional format and data validation(Between/Equal/GreaterThan/GreaterOrEqual/LessThan/None/NotBetween/NotEqual).  
    public operatorType: string;
    /// The value or expression associated with conditional formatting.  
    public formula1: string;
    /// The value or expression associated with conditional formatting.  
    public formula2: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetFormatConditionRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/conditionalFormattings/{index}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "index" + "}", String(this.index));
        const queryParameters: any = {};
        /// Adds a conditional formatted cell range. 
        // verify required parameter 'cellArea' is not null or undefined
        if (this.cellArea === null || this.cellArea === undefined) {
            throw new Error('Required parameter "cellArea" was null or undefined when calling PutWorksheetFormatCondition.');
        }
        /// Format condition type(CellValue/Expression/ColorScale/DataBar/IconSet/Top10/UniqueValues/DuplicateValues/ContainsText/NotContainsText/BeginsWith/EndsWith/ContainsBlanks/NotContainsBlanks/ContainsErrors/NotContainsErrors/TimePeriod/AboveAverage). 
        // verify required parameter 'type' is not null or undefined
        if (this.type === null || this.type === undefined) {
            throw new Error('Required parameter "type" was null or undefined when calling PutWorksheetFormatCondition.');
        }
        /// Represents the operator type of conditional format and data validation(Between/Equal/GreaterThan/GreaterOrEqual/LessThan/None/NotBetween/NotEqual). 
        // verify required parameter 'operatorType' is not null or undefined
        if (this.operatorType === null || this.operatorType === undefined) {
            throw new Error('Required parameter "operatorType" was null or undefined when calling PutWorksheetFormatCondition.');
        }
        /// The value or expression associated with conditional formatting. 
        // verify required parameter 'formula1' is not null or undefined
        if (this.formula1 === null || this.formula1 === undefined) {
            throw new Error('Required parameter "formula1" was null or undefined when calling PutWorksheetFormatCondition.');
        }
        /// The value or expression associated with conditional formatting. 
        // verify required parameter 'formula2' is not null or undefined
        if (this.formula2 === null || this.formula2 === undefined) {
            throw new Error('Required parameter "formula2" was null or undefined when calling PutWorksheetFormatCondition.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellArea", this.cellArea);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "type", this.type);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "operatorType", this.operatorType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "formula1", this.formula1);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "formula2", this.formula2);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds a cell area for format condition.   
export class PutWorksheetFormatConditionAreaRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the Conditional Formatting element at the specified index.  
    public index: number;
    /// Adds a conditional formatted cell range.  
    public cellArea: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetFormatConditionAreaRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/conditionalFormattings/{index}/area".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "index" + "}", String(this.index));
        const queryParameters: any = {};
        /// Adds a conditional formatted cell range. 
        // verify required parameter 'cellArea' is not null or undefined
        if (this.cellArea === null || this.cellArea === undefined) {
            throw new Error('Required parameter "cellArea" was null or undefined when calling PutWorksheetFormatConditionArea.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellArea", this.cellArea);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds a condition for format condition.   
export class PutWorksheetFormatConditionConditionRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the Conditional Formatting element at the specified index.  
    public index: number;
    /// Format condition type(CellValue/Expression/ColorScale/DataBar/IconSet/Top10/UniqueValues/DuplicateValues/ContainsText/NotContainsText/BeginsWith/EndsWith/ContainsBlanks/NotContainsBlanks/ContainsErrors/NotContainsErrors/TimePeriod/AboveAverage).  
    public type: string;
    /// Represents the operator type of conditional format and data validation(Between/Equal/GreaterThan/GreaterOrEqual/LessThan/None/NotBetween/NotEqual).  
    public operatorType: string;
    /// The value or expression associated with conditional formatting.  
    public formula1: string;
    /// The value or expression associated with conditional formatting.  
    public formula2: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetFormatConditionConditionRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/conditionalFormattings/{index}/condition".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "index" + "}", String(this.index));
        const queryParameters: any = {};
        /// Format condition type(CellValue/Expression/ColorScale/DataBar/IconSet/Top10/UniqueValues/DuplicateValues/ContainsText/NotContainsText/BeginsWith/EndsWith/ContainsBlanks/NotContainsBlanks/ContainsErrors/NotContainsErrors/TimePeriod/AboveAverage). 
        // verify required parameter 'type' is not null or undefined
        if (this.type === null || this.type === undefined) {
            throw new Error('Required parameter "type" was null or undefined when calling PutWorksheetFormatConditionCondition.');
        }
        /// Represents the operator type of conditional format and data validation(Between/Equal/GreaterThan/GreaterOrEqual/LessThan/None/NotBetween/NotEqual). 
        // verify required parameter 'operatorType' is not null or undefined
        if (this.operatorType === null || this.operatorType === undefined) {
            throw new Error('Required parameter "operatorType" was null or undefined when calling PutWorksheetFormatConditionCondition.');
        }
        /// The value or expression associated with conditional formatting. 
        // verify required parameter 'formula1' is not null or undefined
        if (this.formula1 === null || this.formula1 === undefined) {
            throw new Error('Required parameter "formula1" was null or undefined when calling PutWorksheetFormatConditionCondition.');
        }
        /// The value or expression associated with conditional formatting. 
        // verify required parameter 'formula2' is not null or undefined
        if (this.formula2 === null || this.formula2 === undefined) {
            throw new Error('Required parameter "formula2" was null or undefined when calling PutWorksheetFormatConditionCondition.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "type", this.type);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "operatorType", this.operatorType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "formula1", this.formula1);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "formula2", this.formula2);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Clear all condition formattings.   
export class DeleteWorksheetConditionalFormattingsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetConditionalFormattingsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/conditionalFormattings".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Remove a conditional formatting.   
export class DeleteWorksheetConditionalFormattingRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the Conditional Formatting element at the specified index.  
    public index: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetConditionalFormattingRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/conditionalFormattings/{index}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "index" + "}", String(this.index));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Removes cell area from conditional formatting.   
export class DeleteWorksheetConditionalFormattingAreaRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The start row of the range.  
    public startRow: number;
    /// The start column of the range.  
    public startColumn: number;
    /// The number of rows of the range.  
    public totalRows: number;
    /// The number of columns of the range.  
    public totalColumns: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetConditionalFormattingAreaRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/conditionalFormattings/area".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The start row of the range. 
        // verify required parameter 'startRow' is not null or undefined
        if (this.startRow === null || this.startRow === undefined) {
            throw new Error('Required parameter "startRow" was null or undefined when calling DeleteWorksheetConditionalFormattingArea.');
        }
        /// The start column of the range. 
        // verify required parameter 'startColumn' is not null or undefined
        if (this.startColumn === null || this.startColumn === undefined) {
            throw new Error('Required parameter "startColumn" was null or undefined when calling DeleteWorksheetConditionalFormattingArea.');
        }
        /// The number of rows of the range. 
        // verify required parameter 'totalRows' is not null or undefined
        if (this.totalRows === null || this.totalRows === undefined) {
            throw new Error('Required parameter "totalRows" was null or undefined when calling DeleteWorksheetConditionalFormattingArea.');
        }
        /// The number of columns of the range. 
        // verify required parameter 'totalColumns' is not null or undefined
        if (this.totalColumns === null || this.totalColumns === undefined) {
            throw new Error('Required parameter "totalColumns" was null or undefined when calling DeleteWorksheetConditionalFormattingArea.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startRow", this.startRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startColumn", this.startColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalRows", this.totalRows);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalColumns", this.totalColumns);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Exports workbook to some format.   
export class GetWorkbookRequest  {
    /// The workbook name.  
    public name: string;
    /// The conversion format(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers).  
    public format: string;
    /// The excel password.  
    public password: string;
    /// Specifies whether set workbook rows to be autofit.  
    public isAutoFit: boolean;
    /// Specifies whether only save table data.Only use pdf to excel.  
    public onlySaveTable: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Path to save result  
    public outPath: string;
    /// Storage name.  
    public storageName: string;
    /// Storage name.  
    public outStorageName: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorkbookRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isAutoFit", this.isAutoFit);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "onlySaveTable", this.onlySaveTable);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outPath", this.outPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outStorageName", this.outStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Converts workbook from request content to some format.   
export class PutConvertWorkbookRequest  {
    /// The format to convert(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers).  
    public file: any;
    /// The format to convert(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers).  
    public format: string;
    /// The workbook password.  
    public password: string;
    /// Path to save result  
    public outPath: string;
    /// Storage name.  
    public storageName: string;
      
    public checkExcelRestriction: boolean;
      
    public streamFormat: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutConvertWorkbookRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/convert";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outPath", this.outPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "streamFormat", this.streamFormat);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Converts document and saves result to storage.   
export class PostWorkbookSaveAsRequest  {
    /// The workbook name.  
    public name: string;
    /// The new file name.  
    public newfilename: string;
      
    public saveOptions: SaveOptions;
    /// Indicates if Autofit rows in workbook.  
    public isAutoFitRows: boolean;
    /// Indicates if Autofit columns in workbook.  
    public isAutoFitColumns: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
      
    public outStorageName: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookSaveAsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/SaveAs".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        /// The new file name. 
        // verify required parameter 'newfilename' is not null or undefined
        if (this.newfilename === null || this.newfilename === undefined) {
            throw new Error('Required parameter "newfilename" was null or undefined when calling PostWorkbookSaveAs.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "newfilename", this.newfilename);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isAutoFitRows", this.isAutoFitRows);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isAutoFitColumns", this.isAutoFitColumns);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outStorageName", this.outStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.saveOptions == null) ? null :   ObjectSerializer.serialize( this.saveOptions,this.saveOptions.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostConvertWorkbookToPDFRequest  {
    /// File to upload  
    public file: any;
      
    public password: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostConvertWorkbookToPDFRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/convert/pdf";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
   
export class PostConvertWorkbookToPNGRequest  {
    /// File to upload  
    public file: any;
      
    public password: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostConvertWorkbookToPNGRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/convert/png";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
   
export class PostConvertWorkbookToDocxRequest  {
    /// File to upload  
    public file: any;
      
    public password: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostConvertWorkbookToDocxRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/convert/docx";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
   
export class PostConvertWorkbookToPptxRequest  {
    /// File to upload  
    public file: any;
      
    public password: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostConvertWorkbookToPptxRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/convert/pptx";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
   
export class PostConvertWorkbookToHtmlRequest  {
    /// File to upload  
    public file: any;
      
    public password: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostConvertWorkbookToHtmlRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/convert/html";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
   
export class PostConvertWorkbookToMarkdownRequest  {
    /// File to upload  
    public file: any;
      
    public password: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostConvertWorkbookToMarkdownRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/convert/markdown";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
   
export class PostConvertWorkbookToJsonRequest  {
    /// File to upload  
    public file: any;
      
    public password: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostConvertWorkbookToJsonRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/convert/json";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
   
export class PostConvertWorkbookToSQLRequest  {
    /// File to upload  
    public file: any;
      
    public password: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostConvertWorkbookToSQLRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/convert/sql";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
   
export class PostConvertWorkbookToCSVRequest  {
    /// File to upload  
    public file: any;
      
    public password: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostConvertWorkbookToCSVRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/convert/csv";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Export excel internal elements or itself to kinds of format files.   
export class PostExportRequest  {
    /// workbook/worksheet/chart/comment/picture/shape/listobject/oleobject  
    public file: any;
    /// workbook/worksheet/chart/comment/picture/shape/listobject/oleobject  
    public objectType: string;
    /// The format to convert(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers)  
    public format: string;
      
    public password: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostExportRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/export";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "objectType", this.objectType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Export XML data from Excel file. 
/// When there are Xml Maps in Excel file, export xml data. 
/// When there is not xml map in Excel file, convert Excel file to xml file.    
export class PostWorkbookExportXMLRequest  {
    /// The workbook(Excel/ODS/...) name.  
    public name: string;
    /// password  
    public password: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// Output file path.  
    public outPath: string;
    /// Storage name for output file.  
    public outStorageName: string;
    /// check excel restriction.  
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookExportXMLRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/exportxml".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outPath", this.outPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outStorageName", this.outStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Imports/Updates an XML data file into the workbook.
/// The XML data file can be a cloud file or HTTP URI data.   
export class PostWorkbookImportJsonRequest  {
    /// The workbook(Excel/ODS/...) name.  
    public name: string;
      
    public importJsonRequest: ImportJsonRequest;
    /// password  
    public password: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// Output file path.  
    public outPath: string;
    /// Storage name for output file.  
    public outStorageName: string;
    /// check Excel restriction.  
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookImportJsonRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/importjson".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outPath", this.outPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outStorageName", this.outStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.importJsonRequest == null) ? null :   ObjectSerializer.serialize( this.importJsonRequest,this.importJsonRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Imports/Updates an XML data file into the workbook.
/// The XML data file can be a cloud file or HTTP URI data.   
export class PostWorkbookImportXMLRequest  {
    /// The workbook(Excel/ODS/...) name.  
    public name: string;
      
    public importXMLRequest: ImportXMLRequest;
    /// password  
    public password: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// Output file path.  
    public outPath: string;
    /// Storage name for output file.  
    public outStorageName: string;
    /// check Excel restriction.  
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookImportXMLRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/importxml".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outPath", this.outPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outStorageName", this.outStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.importXMLRequest == null) ? null :   ObjectSerializer.serialize( this.importXMLRequest,this.importXMLRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Imports data into workbook.   
export class PostImportDataRequest  {
    /// The workbook name.  
    public name: string;
      
    public importOption: ImportOption;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostImportDataRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/importdata".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.importOption == null) ? null :   ObjectSerializer.serialize( this.importOption,this.importOption.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get hyperlinks description in worksheet.   
export class GetWorksheetHyperlinksRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetHyperlinksRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/hyperlinks".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets hyperlink description by index in worksheet.   
export class GetWorksheetHyperlinkRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The hyperlink's index.  
    public hyperlinkIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetHyperlinkRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/hyperlinks/{hyperlinkIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "hyperlinkIndex" + "}", String(this.hyperlinkIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Deletes hyperlink by index in worksheet.   
export class DeleteWorksheetHyperlinkRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The hyperlink's index.  
    public hyperlinkIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetHyperlinkRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/hyperlinks/{hyperlinkIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "hyperlinkIndex" + "}", String(this.hyperlinkIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Updates hyperlink by index in worksheet.   
export class PostWorksheetHyperlinkRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The hyperlink's index.  
    public hyperlinkIndex: number;
    /// Hyperlink object  
    public hyperlink: Hyperlink;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetHyperlinkRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/hyperlinks/{hyperlinkIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "hyperlinkIndex" + "}", String(this.hyperlinkIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.hyperlink == null) ? null :   ObjectSerializer.serialize( this.hyperlink,this.hyperlink.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds hyperlink in worksheet.   
export class PutWorksheetHyperlinkRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// First row of the hyperlink range.  
    public firstRow: number;
    /// First column of the hyperlink range.  
    public firstColumn: number;
    /// Number of rows in this hyperlink range.  
    public totalRows: number;
    /// Number of columns of this hyperlink range.  
    public totalColumns: number;
    /// Address of the hyperlink.  
    public address: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetHyperlinkRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/hyperlinks".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// First row of the hyperlink range. 
        // verify required parameter 'firstRow' is not null or undefined
        if (this.firstRow === null || this.firstRow === undefined) {
            throw new Error('Required parameter "firstRow" was null or undefined when calling PutWorksheetHyperlink.');
        }
        /// First column of the hyperlink range. 
        // verify required parameter 'firstColumn' is not null or undefined
        if (this.firstColumn === null || this.firstColumn === undefined) {
            throw new Error('Required parameter "firstColumn" was null or undefined when calling PutWorksheetHyperlink.');
        }
        /// Number of rows in this hyperlink range. 
        // verify required parameter 'totalRows' is not null or undefined
        if (this.totalRows === null || this.totalRows === undefined) {
            throw new Error('Required parameter "totalRows" was null or undefined when calling PutWorksheetHyperlink.');
        }
        /// Number of columns of this hyperlink range. 
        // verify required parameter 'totalColumns' is not null or undefined
        if (this.totalColumns === null || this.totalColumns === undefined) {
            throw new Error('Required parameter "totalColumns" was null or undefined when calling PutWorksheetHyperlink.');
        }
        /// Address of the hyperlink. 
        // verify required parameter 'address' is not null or undefined
        if (this.address === null || this.address === undefined) {
            throw new Error('Required parameter "address" was null or undefined when calling PutWorksheetHyperlink.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "firstRow", this.firstRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "firstColumn", this.firstColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalRows", this.totalRows);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalColumns", this.totalColumns);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "address", this.address);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete all hyperlinks in worksheet.   
export class DeleteWorksheetHyperlinksRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetHyperlinksRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/hyperlinks".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Combine data files and template files to kinds of format files.    
export class PostAssembleRequest  {
    /// The format to convert(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers)  
    public file: any;
      
    public datasource: string;
    /// The format to convert(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers)  
    public format: string;
      
    public password: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostAssembleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/assemble";
        const queryParameters: any = {};
        const formParams: any = {};
         
        // verify required parameter 'datasource' is not null or undefined
        if (this.datasource === null || this.datasource === undefined) {
            throw new Error('Required parameter "datasource" was null or undefined when calling PostAssemble.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "datasource", this.datasource);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Compress XLS, XLSX, XLSM, XLSB, ODS and more   
export class PostCompressRequest  {
    /// File to upload  
    public file: any;
      
    public compressLevel: number;
      
    public password: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostCompressRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/compress";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "compressLevel", this.compressLevel);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Merge cells in worksheet.   
export class PostMergeRequest  {
    /// The format to convert(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers)  
    public file: any;
      
    public format: string;
      
    public mergeToOneSheet: boolean;
      
    public password: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostMergeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/merge";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "mergeToOneSheet", this.mergeToOneSheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Split Excel spreadsheet files by worksheet, save as kinds of format files.   
export class PostSplitRequest  {
    /// The format to convert(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers)  
    public file: any;
    /// The format to convert(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers)  
    public format: string;
      
    public password: string;
    /// sheet index  
    public from: number;
    /// sheet index  
    public to: number;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostSplitRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/split";
        const queryParameters: any = {};
        const formParams: any = {};
        /// The format to convert(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers) 
        // verify required parameter 'format' is not null or undefined
        if (this.format === null || this.format === undefined) {
            throw new Error('Required parameter "format" was null or undefined when calling PostSplit.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "from", this.from);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "to", this.to);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Search specify the text from excel files.   
export class PostSearchRequest  {
    /// File to upload  
    public file: any;
      
    public text: string;
      
    public password: string;
      
    public sheetname: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostSearchRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/search";
        const queryParameters: any = {};
        const formParams: any = {};
         
        // verify required parameter 'text' is not null or undefined
        if (this.text === null || this.text === undefined) {
            throw new Error('Required parameter "text" was null or undefined when calling PostSearch.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "text", this.text);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sheetname", this.sheetname);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Use new text to replace specify the text from excel files.   
export class PostReplaceRequest  {
    /// File to upload  
    public file: any;
      
    public text: string;
      
    public newtext: string;
      
    public password: string;
      
    public sheetname: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostReplaceRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/replace";
        const queryParameters: any = {};
        const formParams: any = {};
         
        // verify required parameter 'text' is not null or undefined
        if (this.text === null || this.text === undefined) {
            throw new Error('Required parameter "text" was null or undefined when calling PostReplace.');
        }
         
        // verify required parameter 'newtext' is not null or undefined
        if (this.newtext === null || this.newtext === undefined) {
            throw new Error('Required parameter "newtext" was null or undefined when calling PostReplace.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "text", this.text);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "newtext", this.newtext);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sheetname", this.sheetname);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Import data into excel file.   
export class PostImportRequest  {
    /// File to upload  
    public file: any;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostImportRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/import";
        const queryParameters: any = {};
        const formParams: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Add Text Watermark to Excel files.   
export class PostWatermarkRequest  {
    /// e.g. #1032ff  
    public file: any;
      
    public text: string;
    /// e.g. #1032ff  
    public color: string;
      
    public password: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWatermarkRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/watermark";
        const queryParameters: any = {};
        const formParams: any = {};
         
        // verify required parameter 'text' is not null or undefined
        if (this.text === null || this.text === undefined) {
            throw new Error('Required parameter "text" was null or undefined when calling PostWatermark.');
        }
        /// e.g. #1032ff 
        // verify required parameter 'color' is not null or undefined
        if (this.color === null || this.color === undefined) {
            throw new Error('Required parameter "color" was null or undefined when calling PostWatermark.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "text", this.text);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "color", this.color);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Clear excel internal elements for excel files   
export class PostClearObjectsRequest  {
    /// chart/comment/picture/shape/listobject/hyperlink/oleobject/pivottable/validation/Background  
    public file: any;
    /// chart/comment/picture/shape/listobject/hyperlink/oleobject/pivottable/validation/Background  
    public objecttype: string;
      
    public sheetname: string;
      
    public outFormat: string;
      
    public password: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostClearObjectsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/clearobjects";
        const queryParameters: any = {};
        const formParams: any = {};
        /// chart/comment/picture/shape/listobject/hyperlink/oleobject/pivottable/validation/Background 
        // verify required parameter 'objecttype' is not null or undefined
        if (this.objecttype === null || this.objecttype === undefined) {
            throw new Error('Required parameter "objecttype" was null or undefined when calling PostClearObjects.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "objecttype", this.objecttype);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sheetname", this.sheetname);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outFormat", this.outFormat);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Reverse rows or columns of Excel files, save as kinds of format files.   
export class PostReverseRequest  {
    /// rows/cols/both  
    public file: any;
    /// rows/cols/both  
    public rotateType: string;
    /// CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers  
    public format: string;
      
    public password: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostReverseRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/reverse";
        const queryParameters: any = {};
        const formParams: any = {};
        /// rows/cols/both 
        // verify required parameter 'rotateType' is not null or undefined
        if (this.rotateType === null || this.rotateType === undefined) {
            throw new Error('Required parameter "rotateType" was null or undefined when calling PostReverse.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "rotateType", this.rotateType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
   
export class PostRepairRequest  {
    /// File to upload  
    public file: any;
      
    public format: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostRepairRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/repair";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Reverse rows or columns of Excel files, save as kinds of format files.   
export class PostRotateRequest  {
    /// 270/90/row/col/row2col  
    public file: any;
    /// 270/90/row/col/row2col  
    public rotateType: string;
    /// CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers  
    public format: string;
      
    public password: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostRotateRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/rotate";
        const queryParameters: any = {};
        const formParams: any = {};
        /// 270/90/row/col/row2col 
        // verify required parameter 'rotateType' is not null or undefined
        if (this.rotateType === null || this.rotateType === undefined) {
            throw new Error('Required parameter "rotateType" was null or undefined when calling PostRotate.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "rotateType", this.rotateType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
   
export class PostMetadataRequest  {
    /// File to upload  
    public file: any;
      
    public cellsDocuments: Array<CellsDocumentProperty>;
      
    public password: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostMetadataRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/metadata/update";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        const bodyParameter = (this.cellsDocuments == null) ? null :  JSON.stringify(this.cellsDocuments);
        formParams["cellsDocuments"] = bodyParameter;    
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
   
export class GetMetadataRequest  {
    /// File to upload  
    public file: any;
      
    public type: string;
      
    public password: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetMetadataRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/metadata/get";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "type", this.type);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
   
export class DeleteMetadataRequest  {
    /// File to upload  
    public file: any;
      
    public type: string;
      
    public password: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteMetadataRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/metadata/delete";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "type", this.type);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Get listobjects description in worksheet.   
export class GetWorksheetListObjectsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetListObjectsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/listobjects".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets list object description by index in worksheet.   
export class GetWorksheetListObjectRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// list object index.  
    public listobjectindex: number;
      
    public format: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetListObjectRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/listobjects/{listobjectindex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "listobjectindex" + "}", String(this.listobjectindex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds a list object in worksheet.   
export class PutWorksheetListObjectRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The start row of the list range.  
    public startRow: number;
    /// The start row of the list range.  
    public startColumn: number;
    /// The start row of the list range.  
    public endRow: number;
    /// The start row of the list range.  
    public endColumn: number;
    /// Original workbook folder.  
    public folder: string;
    /// Whether the range has headers.  
    public hasHeaders: boolean;
      
    public displayName: string;
      
    public showTotals: boolean;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetListObjectRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/listobjects".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startRow", this.startRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startColumn", this.startColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endRow", this.endRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endColumn", this.endColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "hasHeaders", this.hasHeaders);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "displayName", this.displayName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "showTotals", this.showTotals);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete worksheet list objects in worksheet.   
export class DeleteWorksheetListObjectsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetListObjectsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/listobjects".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Deletes list object by index in worksheet.   
export class DeleteWorksheetListObjectRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// List object index.  
    public listObjectIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetListObjectRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/listobjects/{listObjectIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "listObjectIndex" + "}", String(this.listObjectIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Updates list object in worksheet.   
export class PostWorksheetListObjectRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// list Object index  
    public listObjectIndex: number;
    /// listObject dto in request body.  
    public listObject: ListObject;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetListObjectRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/listobjects/{listObjectIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "listObjectIndex" + "}", String(this.listObjectIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.listObject == null) ? null :   ObjectSerializer.serialize( this.listObject,this.listObject.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Converts list object to range in worksheet.   
export class PostWorksheetListObjectConvertToRangeRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// List object index.  
    public listObjectIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetListObjectConvertToRangeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/listobjects/{listObjectIndex}/ConvertToRange".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "listObjectIndex" + "}", String(this.listObjectIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Creates pivot table with list object in worksheet.   
export class PostWorksheetListObjectSummarizeWithPivotTableRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// List object index.  
    public listObjectIndex: number;
    /// Target work sheet name.  
    public destsheetName: string;
    /// Create pivot table request.  
    public createPivotTableRequest: CreatePivotTableRequest;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetListObjectSummarizeWithPivotTableRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/listobjects/{listObjectIndex}/SummarizeWithPivotTable".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "listObjectIndex" + "}", String(this.listObjectIndex));
        const queryParameters: any = {};
        /// Target work sheet name. 
        // verify required parameter 'destsheetName' is not null or undefined
        if (this.destsheetName === null || this.destsheetName === undefined) {
            throw new Error('Required parameter "destsheetName" was null or undefined when calling PostWorksheetListObjectSummarizeWithPivotTable.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destsheetName", this.destsheetName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.createPivotTableRequest == null) ? null :   ObjectSerializer.serialize( this.createPivotTableRequest,this.createPivotTableRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Sorts list object in worksheet.   
export class PostWorksheetListObjectSortTableRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// List object index.  
    public listObjectIndex: number;
    /// Represents sort order for the data range.  
    public dataSorter: DataSorter;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetListObjectSortTableRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/listobjects/{listObjectIndex}/sort".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "listObjectIndex" + "}", String(this.listObjectIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.dataSorter == null) ? null :   ObjectSerializer.serialize( this.dataSorter,this.dataSorter.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Remove duplicates on list object.   
export class PostWorksheetListObjectRemoveDuplicatesRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// List object index.  
    public listObjectIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetListObjectRemoveDuplicatesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/listobjects/{listObjectIndex}/RemoveDuplicates".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "listObjectIndex" + "}", String(this.listObjectIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Insert slicer for list object.   
export class PostWorksheetListObjectInsertSlicerRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// List object index.  
    public listObjectIndex: number;
    /// The index of ListColumn in ListObject.ListColumns   
    public columnIndex: number;
    /// The cell in the upper-left corner of the Slicer range.   
    public destCellName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetListObjectInsertSlicerRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/listobjects/{listObjectIndex}/InsertSlicer".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "listObjectIndex" + "}", String(this.listObjectIndex));
        const queryParameters: any = {};
        /// The index of ListColumn in ListObject.ListColumns  
        // verify required parameter 'columnIndex' is not null or undefined
        if (this.columnIndex === null || this.columnIndex === undefined) {
            throw new Error('Required parameter "columnIndex" was null or undefined when calling PostWorksheetListObjectInsertSlicer.');
        }
        /// The cell in the upper-left corner of the Slicer range.  
        // verify required parameter 'destCellName' is not null or undefined
        if (this.destCellName === null || this.destCellName === undefined) {
            throw new Error('Required parameter "destCellName" was null or undefined when calling PostWorksheetListObjectInsertSlicer.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "columnIndex", this.columnIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destCellName", this.destCellName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update list column properties.   
export class PostWorksheetListColumnRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// List object index.  
    public listObjectIndex: number;
    /// Represents table column index.  
    public columnIndex: number;
    /// Represents table column description.  
    public listColumn: ListColumn;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetListColumnRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/listobjects/{listObjectIndex}/listcolumns/{columnIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "listObjectIndex" + "}", String(this.listObjectIndex)).replace("{" + "columnIndex" + "}", String(this.columnIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.listColumn == null) ? null :   ObjectSerializer.serialize( this.listColumn,this.listColumn.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update table total of list columns.   
export class PostWorksheetListColumnsTotalRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// List object index.  
    public listObjectIndex: number;
    /// Represents table column description.  
    public tableTotalRequests: Array<TableTotalRequest>;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetListColumnsTotalRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/listobjects/{listObjectIndex}/listcolumns/total".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "listObjectIndex" + "}", String(this.listObjectIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.tableTotalRequests == null) ? null :   ObjectSerializer.serialize( this.tableTotalRequests,this.tableTotalRequests.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get OLE objects description in worksheet.   
export class GetWorksheetOleObjectsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Document's folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetOleObjectsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/oleobjects".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets OLE object info or get the OLE object in some format.   
export class GetWorksheetOleObjectRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The object number.  
    public objectNumber: number;
    /// Object conversion format(PNG/TIFF/JPEG/GIF/EMF/BMP).  
    public format: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetOleObjectRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/oleobjects/{objectNumber}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "objectNumber" + "}", String(this.objectNumber));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete all OLE objects in  worksheet.   
export class DeleteWorksheetOleObjectsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worsheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetOleObjectsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/oleobjects".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Deletes an OLE object in worksheet.   
export class DeleteWorksheetOleObjectRequest  {
    /// The workbook name.  
    public name: string;
    /// The worsheet name.  
    public sheetName: string;
    /// Ole object index.  
    public oleObjectIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetOleObjectRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/oleobjects/{oleObjectIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "oleObjectIndex" + "}", String(this.oleObjectIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update an OLE object in worksheet.   
export class PostUpdateWorksheetOleObjectRequest  {
    /// The workbook name.  
    public name: string;
    /// The worsheet name.  
    public sheetName: string;
    /// Ole object index.  
    public oleObjectIndex: number;
    /// Ole Object description.  
    public ole: OleObject;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUpdateWorksheetOleObjectRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/oleobjects/{oleObjectIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "oleObjectIndex" + "}", String(this.oleObjectIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.ole == null) ? null :   ObjectSerializer.serialize( this.ole,this.ole.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add an OLE object in worksheet.   
export class PutWorksheetOleObjectRequest  {
    /// The workbook name.  
    public name: string;
    /// The worsheet name.  
    public sheetName: string;
    /// Upper left row index  
    public upperLeftRow: number;
    /// Upper left column index  
    public upperLeftColumn: number;
    /// Height of oleObject, in unit of pixel  
    public height: number;
    /// Width of oleObject, in unit of pixel  
    public width: number;
    /// OLE filename(full file name).  
    public oleFile: string;
    /// Image filename(full file name).  
    public imageFile: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetOleObjectRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/oleobjects".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "upperLeftRow", this.upperLeftRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "upperLeftColumn", this.upperLeftColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "height", this.height);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "width", this.width);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "oleFile", this.oleFile);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "imageFile", this.imageFile);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get vertical page breaks description in worksheet.   
export class GetVerticalPageBreaksRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetVerticalPageBreaksRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/verticalpagebreaks".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get horizontal page breaks descripton in worksheet.   
export class GetHorizontalPageBreaksRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetHorizontalPageBreaksRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/horizontalpagebreaks".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets a vertical page break description in worksheet.   
export class GetVerticalPageBreakRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The zero based index of the element.  
    public index: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetVerticalPageBreakRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/verticalpagebreaks/{index}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "index" + "}", String(this.index));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets a horizontal page breaks descripton in worksheet.   
export class GetHorizontalPageBreakRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The zero based index of the element.  
    public index: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetHorizontalPageBreakRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/horizontalpagebreaks/{index}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "index" + "}", String(this.index));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds a vertical page break in worksheet.   
export class PutVerticalPageBreakRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Cell name  
    public cellname: string;
    /// Column index, zero based.  
    public column: number;
    /// Row index, zero based.  
    public row: number;
    /// Start row index, zero based.  
    public startRow: number;
    /// End row index, zero based.  
    public endRow: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutVerticalPageBreakRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/verticalpagebreaks".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellname", this.cellname);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "column", this.column);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "row", this.row);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startRow", this.startRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endRow", this.endRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds a horizontal page breaks in worksheet.   
export class PutHorizontalPageBreakRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Cell name  
    public cellname: string;
    /// Row index, zero based.  
    public row: number;
    /// Column index, zero based.  
    public column: number;
    /// Start column index, zero based.  
    public startColumn: number;
    /// End column index, zero based.  
    public endColumn: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutHorizontalPageBreakRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/horizontalpagebreaks".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellname", this.cellname);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "row", this.row);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "column", this.column);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startColumn", this.startColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endColumn", this.endColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete vertical page breaks in worksheet.   
export class DeleteVerticalPageBreaksRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Column index, zero based.  
    public column: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteVerticalPageBreaksRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/verticalpagebreaks".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "column", this.column);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete horizontal page breaks in worksheet.   
export class DeleteHorizontalPageBreaksRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Row index, zero based.  
    public row: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteHorizontalPageBreaksRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/horizontalpagebreaks".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "row", this.row);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete a vertical page breaks in worksheet.   
export class DeleteVerticalPageBreakRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Removes the VPageBreak element at a specified name. Element index, zero based.  
    public index: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteVerticalPageBreakRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/verticalpagebreaks/{index}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "index" + "}", String(this.index));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete a horizontal page breaks in worksheet.   
export class DeleteHorizontalPageBreakRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Removes the HPageBreak element at a specified name. Element index, zero based.  
    public index: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteHorizontalPageBreakRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/horizontalpagebreaks/{index}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "index" + "}", String(this.index));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets page setup description in worksheet.   
export class GetPageSetupRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetPageSetupRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pagesetup".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Updates page setup in worksheet.   
export class PostPageSetupRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Page Setup description.  
    public pageSetup: PageSetup;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostPageSetupRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pagesetup".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.pageSetup == null) ? null :   ObjectSerializer.serialize( this.pageSetup,this.pageSetup.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Clears header footer in worksheet.   
export class DeleteHeaderFooterRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteHeaderFooterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pagesetup/clearheaderfooter".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets page header description in worksheet.   
export class GetHeaderRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetHeaderRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pagesetup/header".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Updates page header in worksheet.    
export class PostHeaderRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// 0:Left Section. 1:Center Section 2:Right Section  
    public section: number;
    /// Header format script.  
    public script: string;
    /// Is first page(true/false).  
    public isFirstPage: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostHeaderRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pagesetup/header".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// 0:Left Section. 1:Center Section 2:Right Section 
        // verify required parameter 'section' is not null or undefined
        if (this.section === null || this.section === undefined) {
            throw new Error('Required parameter "section" was null or undefined when calling PostHeader.');
        }
        /// Header format script. 
        // verify required parameter 'script' is not null or undefined
        if (this.script === null || this.script === undefined) {
            throw new Error('Required parameter "script" was null or undefined when calling PostHeader.');
        }
        /// Is first page(true/false). 
        // verify required parameter 'isFirstPage' is not null or undefined
        if (this.isFirstPage === null || this.isFirstPage === undefined) {
            throw new Error('Required parameter "isFirstPage" was null or undefined when calling PostHeader.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "section", this.section);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "script", this.script);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isFirstPage", this.isFirstPage);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets page footer description in worksheet.   
export class GetFooterRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetFooterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pagesetup/footer".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update  page footer description in worksheet.    
export class PostFooterRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// 0:Left Section. 1:Center Section 2:Right Section  
    public section: number;
    /// Header format script.  
    public script: string;
    /// Is first page(true/false).  
    public isFirstPage: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostFooterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pagesetup/footer".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// 0:Left Section. 1:Center Section 2:Right Section 
        // verify required parameter 'section' is not null or undefined
        if (this.section === null || this.section === undefined) {
            throw new Error('Required parameter "section" was null or undefined when calling PostFooter.');
        }
        /// Header format script. 
        // verify required parameter 'script' is not null or undefined
        if (this.script === null || this.script === undefined) {
            throw new Error('Required parameter "script" was null or undefined when calling PostFooter.');
        }
        /// Is first page(true/false). 
        // verify required parameter 'isFirstPage' is not null or undefined
        if (this.isFirstPage === null || this.isFirstPage === undefined) {
            throw new Error('Required parameter "isFirstPage" was null or undefined when calling PostFooter.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "section", this.section);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "script", this.script);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isFirstPage", this.isFirstPage);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get pictures description in worksheet.   
export class GetWorksheetPicturesRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetPicturesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pictures".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets a picture by number in worksheet.   
export class GetWorksheetPictureWithFormatRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The picture number.  
    public pictureNumber: number;
    /// Picture conversion format(PNG/TIFF/JPEG/GIF/EMF/BMP).  
    public format: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetPictureWithFormatRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pictures/{pictureNumber}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pictureNumber" + "}", String(this.pictureNumber));
        const queryParameters: any = {};
        /// Picture conversion format(PNG/TIFF/JPEG/GIF/EMF/BMP). 
        // verify required parameter 'format' is not null or undefined
        if (this.format === null || this.format === undefined) {
            throw new Error('Required parameter "format" was null or undefined when calling GetWorksheetPictureWithFormat.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds a new picture in worksheet.   
export class PutWorksheetAddPictureRequest  {
    /// The workbook name.  
    public name: string;
    /// The worsheet name.  
    public sheetName: string;
    /// Pictute object  
    public picture: Picture;
    /// The image upper left row.  
    public upperLeftRow: number;
    /// The image upper left column.  
    public upperLeftColumn: number;
    /// The image low right row.  
    public lowerRightRow: number;
    /// The image low right column.  
    public lowerRightColumn: number;
    /// The picture path, if not provided the picture data is inspected in the request body.  
    public picturePath: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetAddPictureRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pictures".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "upperLeftRow", this.upperLeftRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "upperLeftColumn", this.upperLeftColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "lowerRightRow", this.lowerRightRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "lowerRightColumn", this.lowerRightColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "picturePath", this.picturePath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.picture == null) ? null :   ObjectSerializer.serialize( this.picture,this.picture.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Updates a picture by index in worksheet.   
export class PostWorksheetPictureRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The picture's index.  
    public pictureIndex: number;
    /// Picture object description.  
    public picture: Picture;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetPictureRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pictures/{pictureIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pictureIndex" + "}", String(this.pictureIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.picture == null) ? null :   ObjectSerializer.serialize( this.picture,this.picture.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Deletes a picture object in worksheet   
export class DeleteWorksheetPictureRequest  {
    /// The workbook name.  
    public name: string;
    /// The worsheet name.  
    public sheetName: string;
    /// Picture index.  
    public pictureIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetPictureRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pictures/{pictureIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pictureIndex" + "}", String(this.pictureIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete all pictures in worksheet.   
export class DeleteWorksheetPicturesRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetPicturesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pictures".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get worksheet pivottables description.   
export class GetWorksheetPivotTablesRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetPivotTablesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pivottables".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets a pivottable info by index in worksheet.   
export class GetWorksheetPivotTableRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivottableIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetPivotTableRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pivottables/{pivottableIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivottableIndex" + "}", String(this.pivottableIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets pivot field description in pivot table.   
export class GetPivotTableFieldRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// The field index in the base fields.  
    public pivotFieldIndex: number;
    /// The fields area type(column/row).  
    public pivotFieldType: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetPivotTableFieldRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotField".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        /// The field index in the base fields. 
        // verify required parameter 'pivotFieldIndex' is not null or undefined
        if (this.pivotFieldIndex === null || this.pivotFieldIndex === undefined) {
            throw new Error('Required parameter "pivotFieldIndex" was null or undefined when calling GetPivotTableField.');
        }
        /// The fields area type(column/row). 
        // verify required parameter 'pivotFieldType' is not null or undefined
        if (this.pivotFieldType === null || this.pivotFieldType === undefined) {
            throw new Error('Required parameter "pivotFieldType" was null or undefined when calling GetPivotTableField.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pivotFieldIndex", this.pivotFieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pivotFieldType", this.pivotFieldType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets pivot table filters in worksheet.   
export class GetWorksheetPivotTableFiltersRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetPivotTableFiltersRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotFilters".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets pivot table filters in worksheet.   
export class GetWorksheetPivotTableFilterRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// Gets the pivotfilter object at the specific index.  
    public filterIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetPivotTableFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotFilters/{filterIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex)).replace("{" + "filterIndex" + "}", String(this.filterIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds a pivot table in worksheet.   
export class PutWorksheetPivotTableRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// The data for the new PivotTable cache.  
    public sourceData: string;
    /// The cell in the upper-left corner of the PivotTable report's destination range.  
    public destCellName: string;
    /// The name of the new PivotTable report.  
    public tableName: string;
    /// Indicates whether using same data source when another existing pivot table has used this data source. If the property is true, it will save memory.  
    public useSameSource: boolean;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetPivotTableRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pivottables".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sourceData", this.sourceData);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destCellName", this.destCellName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "tableName", this.tableName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "useSameSource", this.useSameSource);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds a pivot field in pivot table   
export class PutPivotTableFieldRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// The fields area type.  
    public pivotFieldType: string;
    /// Dto that conrains field indexes  
    public pivotTableFieldRequest: PivotTableFieldRequest;
    /// Whether the specific pivot table calculate(true/false).  
    public needReCalculate: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutPivotTableFieldRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotField".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        /// The fields area type. 
        // verify required parameter 'pivotFieldType' is not null or undefined
        if (this.pivotFieldType === null || this.pivotFieldType === undefined) {
            throw new Error('Required parameter "pivotFieldType" was null or undefined when calling PutPivotTableField.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pivotFieldType", this.pivotFieldType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "needReCalculate", this.needReCalculate);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.pivotTableFieldRequest == null) ? null :   ObjectSerializer.serialize( this.pivotTableFieldRequest,this.pivotTableFieldRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds a pivot filter for piovt table index   
export class PutWorksheetPivotTableFilterRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// Pivot filter description.  
    public filter: PivotFilter;
    /// Whether the specific pivot table calculate(true/false).  
    public needReCalculate: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetPivotTableFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotFilters".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "needReCalculate", this.needReCalculate);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.filter == null) ? null :   ObjectSerializer.serialize( this.filter,this.filter.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Hides pivot field item in pivot table.   
export class PostPivotTableFieldHideItemRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// Represents PivotTable field type(Undefined/Row/Column/Page/Data).  
    public pivotFieldType: string;
    /// Gets the PivotField Object at the specific index.  
    public fieldIndex: number;
    /// The index of the pivotItem in the pivotField.  
    public itemIndex: number;
    /// Whether the specific PivotItem is hidden(true/false).  
    public isHide: boolean;
    /// Whether the specific pivot table calculate(true/false).  
    public needReCalculate: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostPivotTableFieldHideItemRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotField/Hide".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        /// Represents PivotTable field type(Undefined/Row/Column/Page/Data). 
        // verify required parameter 'pivotFieldType' is not null or undefined
        if (this.pivotFieldType === null || this.pivotFieldType === undefined) {
            throw new Error('Required parameter "pivotFieldType" was null or undefined when calling PostPivotTableFieldHideItem.');
        }
        /// Gets the PivotField Object at the specific index. 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling PostPivotTableFieldHideItem.');
        }
        /// The index of the pivotItem in the pivotField. 
        // verify required parameter 'itemIndex' is not null or undefined
        if (this.itemIndex === null || this.itemIndex === undefined) {
            throw new Error('Required parameter "itemIndex" was null or undefined when calling PostPivotTableFieldHideItem.');
        }
        /// Whether the specific PivotItem is hidden(true/false). 
        // verify required parameter 'isHide' is not null or undefined
        if (this.isHide === null || this.isHide === undefined) {
            throw new Error('Required parameter "isHide" was null or undefined when calling PostPivotTableFieldHideItem.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pivotFieldType", this.pivotFieldType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "itemIndex", this.itemIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isHide", this.isHide);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "needReCalculate", this.needReCalculate);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Moves pivot field in pivot table.   
export class PostPivotTableFieldMoveToRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// Gets the PivotField Object at the specific index.  
    public fieldIndex: number;
    /// The fields area type(Column/Row/Page/Data/Undefined).  
    public from: string;
    /// The fields area type(Column/Row/Page/Data/Undefined).  
    public to: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostPivotTableFieldMoveToRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotField/Move".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        /// Gets the PivotField Object at the specific index. 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling PostPivotTableFieldMoveTo.');
        }
        /// The fields area type(Column/Row/Page/Data/Undefined). 
        // verify required parameter 'from' is not null or undefined
        if (this.from === null || this.from === undefined) {
            throw new Error('Required parameter "from" was null or undefined when calling PostPivotTableFieldMoveTo.');
        }
        /// The fields area type(Column/Row/Page/Data/Undefined). 
        // verify required parameter 'to' is not null or undefined
        if (this.to === null || this.to === undefined) {
            throw new Error('Required parameter "to" was null or undefined when calling PostPivotTableFieldMoveTo.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "from", this.from);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "to", this.to);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Updates cell style in pivot table.   
export class PostPivotTableCellStyleRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// Column index of the cell.  
    public column: number;
    /// RowIndex of the cell.  
    public row: number;
    /// Style description in request body.  
    public style: Style;
    /// Whether the specific pivot table calculate(true/false).  
    public needReCalculate: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostPivotTableCellStyleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/Format".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        /// Column index of the cell. 
        // verify required parameter 'column' is not null or undefined
        if (this.column === null || this.column === undefined) {
            throw new Error('Required parameter "column" was null or undefined when calling PostPivotTableCellStyle.');
        }
        /// RowIndex of the cell. 
        // verify required parameter 'row' is not null or undefined
        if (this.row === null || this.row === undefined) {
            throw new Error('Required parameter "row" was null or undefined when calling PostPivotTableCellStyle.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "column", this.column);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "row", this.row);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "needReCalculate", this.needReCalculate);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.style == null) ? null :   ObjectSerializer.serialize( this.style,this.style.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Updates style in pivot table.   
export class PostPivotTableStyleRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// Style description in request body.  
    public style: Style;
    /// Whether the specific pivot table calculate(true/false).  
    public needReCalculate: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostPivotTableStyleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/FormatAll".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "needReCalculate", this.needReCalculate);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.style == null) ? null :   ObjectSerializer.serialize( this.style,this.style.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostPivotTableUpdatePivotFieldsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// Represents PivotTable field type(Undefined/Row/Column/Page/Data).  
    public pivotFieldType: string;
    /// Represents pivot field.  
    public pivotField: PivotField;
    /// Whether the specific pivot table calculate(true/false).  
    public needReCalculate: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostPivotTableUpdatePivotFieldsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotFields".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        /// Represents PivotTable field type(Undefined/Row/Column/Page/Data). 
        // verify required parameter 'pivotFieldType' is not null or undefined
        if (this.pivotFieldType === null || this.pivotFieldType === undefined) {
            throw new Error('Required parameter "pivotFieldType" was null or undefined when calling PostPivotTableUpdatePivotFields.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pivotFieldType", this.pivotFieldType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "needReCalculate", this.needReCalculate);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.pivotField == null) ? null :   ObjectSerializer.serialize( this.pivotField,this.pivotField.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostPivotTableUpdatePivotFieldRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// Gets the PivotField Object at the specific index.  
    public pivotFieldIndex: number;
    /// Represents PivotTable field type(Undefined/Row/Column/Page/Data).  
    public pivotFieldType: string;
    /// Represents pivot field.  
    public pivotField: PivotField;
    /// Whether the specific pivot table calculate(true/false).  
    public needReCalculate: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostPivotTableUpdatePivotFieldRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotFields/{pivotFieldIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex)).replace("{" + "pivotFieldIndex" + "}", String(this.pivotFieldIndex));
        const queryParameters: any = {};
        /// Represents PivotTable field type(Undefined/Row/Column/Page/Data). 
        // verify required parameter 'pivotFieldType' is not null or undefined
        if (this.pivotFieldType === null || this.pivotFieldType === undefined) {
            throw new Error('Required parameter "pivotFieldType" was null or undefined when calling PostPivotTableUpdatePivotField.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pivotFieldType", this.pivotFieldType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "needReCalculate", this.needReCalculate);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.pivotField == null) ? null :   ObjectSerializer.serialize( this.pivotField,this.pivotField.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Calculates pivottable's data to cells.   
export class PostWorksheetPivotTableCalculateRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetPivotTableCalculateRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/Calculate".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Moves pivot table in worksheet.   
export class PostWorksheetPivotTableMoveRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// Row index.  
    public row: number;
    /// Column index.  
    public column: number;
    /// The dest cell name.  
    public destCellName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetPivotTableMoveRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/Move".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "row", this.row);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "column", this.column);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destCellName", this.destCellName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete pivot tables in worksheet.   
export class DeleteWorksheetPivotTablesRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetPivotTablesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pivottables".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Deletes  pivot table by index in worksheet.   
export class DeleteWorksheetPivotTableRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetPivotTableRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Deletes pivot field in pivot table.   
export class DeletePivotTableFieldRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// The fields area type.  
    public pivotFieldType: string;
    /// Pivot table field request.  
    public pivotTableFieldRequest: PivotTableFieldRequest;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeletePivotTableFieldRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotField".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        /// The fields area type. 
        // verify required parameter 'pivotFieldType' is not null or undefined
        if (this.pivotFieldType === null || this.pivotFieldType === undefined) {
            throw new Error('Required parameter "pivotFieldType" was null or undefined when calling DeletePivotTableField.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pivotFieldType", this.pivotFieldType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.pivotTableFieldRequest == null) ? null :   ObjectSerializer.serialize( this.pivotTableFieldRequest,this.pivotTableFieldRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete all pivot filters in piovt table.   
export class DeleteWorksheetPivotTableFiltersRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// Whether the specific pivot table calculate(true/false).  
    public needReCalculate: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetPivotTableFiltersRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotFilters".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "needReCalculate", this.needReCalculate);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Deletes a pivot filter in piovt table.   
export class DeleteWorksheetPivotTableFilterRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// Gets the PivotField Object at the specific index.  
    public fieldIndex: number;
    /// Whether the specific pivot table calculate(true/false).  
    public needReCalculate: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetPivotTableFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotFilters/{fieldIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex)).replace("{" + "fieldIndex" + "}", String(this.fieldIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "needReCalculate", this.needReCalculate);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get document properties description.   
export class GetDocumentPropertiesRequest  {
    /// The workbook name.  
    public name: string;
      
    public type: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetDocumentPropertiesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/documentproperties".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "type", this.type);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Sets/creates a sdocument property.   
export class PutDocumentPropertyRequest  {
    /// The workbook name.  
    public name: string;
    /// Gets or sets the value of the property.  
    public property: CellsDocumentProperty;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutDocumentPropertyRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/documentproperties".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.property == null) ? null :   ObjectSerializer.serialize( this.property,this.property.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets document property by name.   
export class GetDocumentPropertyRequest  {
    /// The workbook name.  
    public name: string;
    /// The property name.  
    public propertyName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetDocumentPropertyRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/documentproperties/{propertyName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "propertyName" + "}", String(this.propertyName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Deletes a document property.   
export class DeleteDocumentPropertyRequest  {
    /// The workbook name.  
    public name: string;
    /// The property name.  
    public propertyName: string;
      
    public type: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteDocumentPropertyRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/documentproperties/{propertyName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "propertyName" + "}", String(this.propertyName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "type", this.type);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete all custom document properties and clean built-in ones.   
export class DeleteDocumentPropertiesRequest  {
    /// The workbook name.  
    public name: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteDocumentPropertiesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/documentproperties".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Digital Signature.   
export class PostDigitalSignatureRequest  {
    /// The workbook name.  
    public name: string;
    /// Digital signature file parameters.  
    public digitalsignaturefile: string;
      
    public password: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostDigitalSignatureRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/digitalsignature".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        /// Digital signature file parameters. 
        // verify required parameter 'digitalsignaturefile' is not null or undefined
        if (this.digitalsignaturefile === null || this.digitalsignaturefile === undefined) {
            throw new Error('Required parameter "digitalsignaturefile" was null or undefined when calling PostDigitalSignature.');
        }
         
        // verify required parameter 'password' is not null or undefined
        if (this.password === null || this.password === undefined) {
            throw new Error('Required parameter "password" was null or undefined when calling PostDigitalSignature.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "digitalsignaturefile", this.digitalsignaturefile);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Encripts workbook.   
export class PostEncryptWorkbookRequest  {
    /// The workbook name.  
    public name: string;
    /// Encryption parameters.  
    public encryption: WorkbookEncryptionRequest;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostEncryptWorkbookRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/encryption".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.encryption == null) ? null :   ObjectSerializer.serialize( this.encryption,this.encryption.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Decrypts workbook.   
export class DeleteDecryptWorkbookRequest  {
    /// The workbook name.  
    public name: string;
    /// Encryption settings, only password can be specified.  
    public encryption: WorkbookEncryptionRequest;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteDecryptWorkbookRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/encryption".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.encryption == null) ? null :   ObjectSerializer.serialize( this.encryption,this.encryption.constructor.name);
        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Protects workbook.   
export class PostProtectWorkbookRequest  {
    /// The workbook name.  
    public name: string;
    /// The protection settings.  
    public protectWorkbookRequest: ProtectWorkbookRequest;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostProtectWorkbookRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/protection".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.protectWorkbookRequest == null) ? null :   ObjectSerializer.serialize( this.protectWorkbookRequest,this.protectWorkbookRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Unprotects workbook.   
export class DeleteUnProtectWorkbookRequest  {
    /// The workbook name.  
    public name: string;
    /// Protection settings, only password can be specified.  
    public password: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteUnProtectWorkbookRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/protection".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        /// Protection settings, only password can be specified. 
        // verify required parameter 'password' is not null or undefined
        if (this.password === null || this.password === undefined) {
            throw new Error('Required parameter "password" was null or undefined when calling DeleteUnProtectWorkbook.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Protects document from changes.   
export class PutDocumentProtectFromChangesRequest  {
    /// The workbook name.  
    public name: string;
    /// Modification password.  
    public password: PasswordRequest;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutDocumentProtectFromChangesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/writeProtection".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.password == null) ? null :   ObjectSerializer.serialize( this.password,this.password.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Unprotects document from changes.   
export class DeleteDocumentUnProtectFromChangesRequest  {
    /// The workbook name.  
    public name: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteDocumentUnProtectFromChangesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/writeProtection".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Unprotect password protected Excel file.   
export class PostUnlockRequest  {
    /// File to upload  
    public file: any;
      
    public password: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUnlockRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/unlock";
        const queryParameters: any = {};
        const formParams: any = {};
         
        // verify required parameter 'password' is not null or undefined
        if (this.password === null || this.password === undefined) {
            throw new Error('Required parameter "password" was null or undefined when calling PostUnlock.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Setting access password.   
export class PostLockRequest  {
    /// File to upload  
    public file: any;
      
    public password: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostLockRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/lock";
        const queryParameters: any = {};
        const formParams: any = {};
         
        // verify required parameter 'password' is not null or undefined
        if (this.password === null || this.password === undefined) {
            throw new Error('Required parameter "password" was null or undefined when calling PostLock.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Protect MS Excel and OpenDocument Spreadsheet by making them password protected.   
export class PostProtectRequest  {
    /// File to upload  
    public file: any;
      
    public protectWorkbookRequest: ProtectWorkbookRequest;
      
    public password: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostProtectRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/protect";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        const bodyParameter = (this.protectWorkbookRequest == null) ? null :  JSON.stringify(this.protectWorkbookRequest);
        formParams["protectWorkbookRequest"] = bodyParameter;    
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Copys content to destination range from source range in worksheet.   
export class PostWorksheetCellsRangesCopyRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// copydata,copystyle,copyto,copyvalue  
    public rangeOperate: RangeCopyRequest;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellsRangesCopyRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/ranges/copy".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.rangeOperate == null) ? null :   ObjectSerializer.serialize( this.rangeOperate,this.rangeOperate.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Combines a range of cells into a single cell.    
export class PostWorksheetCellsRangeMergeRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// range description.  
    public range: Range;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellsRangeMergeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/ranges/merge".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.range == null) ? null :   ObjectSerializer.serialize( this.range,this.range.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Unmerges merged cells of this range.   
export class PostWorksheetCellsRangeUnMergeRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// range description.  
    public range: Range;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellsRangeUnMergeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/ranges/unmerge".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.range == null) ? null :   ObjectSerializer.serialize( this.range,this.range.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Sets the style of the range.   
export class PostWorksheetCellsRangeStyleRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Range Set Style Request   
    public rangeOperate: RangeSetStyleRequest;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellsRangeStyleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/ranges/style".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.rangeOperate == null) ? null :   ObjectSerializer.serialize( this.rangeOperate,this.rangeOperate.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get the value of cells in range.   
export class GetWorksheetCellsRangeValueRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// range name.  
    public namerange: string;
    /// Gets the index of the first row of the range.  
    public firstRow: number;
    /// Gets the index of the first columnn of the range.  
    public firstColumn: number;
    /// Gets the count of rows in the range.  
    public rowCount: number;
    /// Gets the count of columns in the range.  
    public columnCount: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetCellsRangeValueRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/ranges/value".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "namerange", this.namerange);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "firstRow", this.firstRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "firstColumn", this.firstColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "rowCount", this.rowCount);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "columnCount", this.columnCount);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Puts a value into the range, if appropriate the value will be converted to other data type and cell's number format will be reset.
///                
export class PostWorksheetCellsRangeValueRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// range in worksheet   
    public range: Range;
    /// Input value  
    public value: string;
    /// True: converted to other data type if appropriate.  
    public isConverted: boolean;
    /// True: set the number format to cell's style when converting to other data type  
    public setStyle: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellsRangeValueRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/ranges/value".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Input value 
        // verify required parameter 'value' is not null or undefined
        if (this.value === null || this.value === undefined) {
            throw new Error('Required parameter "value" was null or undefined when calling PostWorksheetCellsRangeValue.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "value", this.value);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isConverted", this.isConverted);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "setStyle", this.setStyle);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.range == null) ? null :   ObjectSerializer.serialize( this.range,this.range.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Moves the current range to the dest range.
///                
export class PostWorksheetCellsRangeMoveToRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// range in worksheet   
    public range: Range;
    /// The start row of the dest range.  
    public destRow: number;
    /// The start column of the dest range.  
    public destColumn: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellsRangeMoveToRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/ranges/moveto".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The start row of the dest range. 
        // verify required parameter 'destRow' is not null or undefined
        if (this.destRow === null || this.destRow === undefined) {
            throw new Error('Required parameter "destRow" was null or undefined when calling PostWorksheetCellsRangeMoveTo.');
        }
        /// The start column of the dest range. 
        // verify required parameter 'destColumn' is not null or undefined
        if (this.destColumn === null || this.destColumn === undefined) {
            throw new Error('Required parameter "destColumn" was null or undefined when calling PostWorksheetCellsRangeMoveTo.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destRow", this.destRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destColumn", this.destColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.range == null) ? null :   ObjectSerializer.serialize( this.range,this.range.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Sets outline border around a range of cells.   
export class PostWorksheetCellsRangeSortRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Range Sort Request   
    public rangeSortRequest: RangeSortRequest;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellsRangeSortRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/ranges/sort".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.rangeSortRequest == null) ? null :   ObjectSerializer.serialize( this.rangeSortRequest,this.rangeSortRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Sets outline border around a range of cells.   
export class PostWorksheetCellsRangeOutlineBorderRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Range Set OutlineBorder Request.  
    public rangeOperate: RangeSetOutlineBorderRequest;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellsRangeOutlineBorderRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/ranges/outlineBorder".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.rangeOperate == null) ? null :   ObjectSerializer.serialize( this.rangeOperate,this.rangeOperate.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Sets column width of range.   
export class PostWorksheetCellsRangeColumnWidthRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The range object.  
    public range: Range;
    /// Sets the column width of this range.  
    public value: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellsRangeColumnWidthRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/ranges/columnWidth".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Sets the column width of this range. 
        // verify required parameter 'value' is not null or undefined
        if (this.value === null || this.value === undefined) {
            throw new Error('Required parameter "value" was null or undefined when calling PostWorksheetCellsRangeColumnWidth.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "value", this.value);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.range == null) ? null :   ObjectSerializer.serialize( this.range,this.range.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Sets row height of range.   
export class PostWorksheetCellsRangeRowHeightRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The range object.  
    public range: Range;
    /// Sets the column height of this range.  
    public value: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellsRangeRowHeightRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/ranges/rowHeight".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Sets the column height of this range. 
        // verify required parameter 'value' is not null or undefined
        if (this.value === null || this.value === undefined) {
            throw new Error('Required parameter "value" was null or undefined when calling PostWorksheetCellsRangeRowHeight.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "value", this.value);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.range == null) ? null :   ObjectSerializer.serialize( this.range,this.range.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Inserts a range of cells and shift cells according to the shift option.
///                
export class PutWorksheetCellsRangeRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The range object.  
    public range: string;
    /// Represent the shift options when deleting a range of cells(Down/Left/None/Right/Up).  
    public shift: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetCellsRangeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/ranges".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The range object. 
        // verify required parameter 'range' is not null or undefined
        if (this.range === null || this.range === undefined) {
            throw new Error('Required parameter "range" was null or undefined when calling PutWorksheetCellsRange.');
        }
        /// Represent the shift options when deleting a range of cells(Down/Left/None/Right/Up). 
        // verify required parameter 'shift' is not null or undefined
        if (this.shift === null || this.shift === undefined) {
            throw new Error('Required parameter "shift" was null or undefined when calling PutWorksheetCellsRange.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "shift", this.shift);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Deletes a range of cells and shift cells according to the shift option.   
export class DeleteWorksheetCellsRangeRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The range object.  
    public range: string;
    /// Represent the shift options when deleting a range of cells(Down/Left/None/Right/Up).  
    public shift: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetCellsRangeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/ranges".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The range object. 
        // verify required parameter 'range' is not null or undefined
        if (this.range === null || this.range === undefined) {
            throw new Error('Required parameter "range" was null or undefined when calling DeleteWorksheetCellsRange.');
        }
        /// Represent the shift options when deleting a range of cells(Down/Left/None/Right/Up). 
        // verify required parameter 'shift' is not null or undefined
        if (this.shift === null || this.shift === undefined) {
            throw new Error('Required parameter "shift" was null or undefined when calling DeleteWorksheetCellsRange.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "shift", this.shift);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get shapes description in worksheet.   
export class GetWorksheetShapesRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetShapesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/shapes".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets shape description in worksheet.   
export class GetWorksheetShapeRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// shape index in worksheet shapes.  
    public shapeindex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetShapeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/shapes/{shapeindex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "shapeindex" + "}", String(this.shapeindex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds shape in worksheet.   
export class PutWorksheetShapeRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
      
    public shapeDTO: Shape;
    /// shape object type  
    public drawingType: string;
    /// Upper left row index.  
    public upperLeftRow: number;
    /// Upper left column index.  
    public upperLeftColumn: number;
    /// Represents the vertical offset of Spinner from its left row, in unit of pixel.  
    public top: number;
    /// Represents the horizontal offset of Spinner from its left column, in unit of pixel.  
    public left: number;
    /// Represents the height of Spinner, in unit of pixel.  
    public width: number;
    /// Represents the width of Spinner, in unit of pixel.  
    public height: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetShapeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/shapes".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "drawingType", this.drawingType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "upperLeftRow", this.upperLeftRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "upperLeftColumn", this.upperLeftColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "top", this.top);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "left", this.left);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "width", this.width);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "height", this.height);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.shapeDTO == null) ? null :   ObjectSerializer.serialize( this.shapeDTO,this.shapeDTO.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// delete all shapes in worksheet.   
export class DeleteWorksheetShapesRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetShapesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/shapes".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Deletes a shape in worksheet.   
export class DeleteWorksheetShapeRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// shape index in worksheet shapes.  
    public shapeindex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetShapeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/shapes/{shapeindex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "shapeindex" + "}", String(this.shapeindex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Updates a shape in worksheet.   
export class PostWorksheetShapeRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// shape index in worksheet shapes.  
    public shapeindex: number;
    /// The shape description.  
    public dto: Shape;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetShapeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/shapes/{shapeindex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "shapeindex" + "}", String(this.shapeindex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.dto == null) ? null :   ObjectSerializer.serialize( this.dto,this.dto.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostWorksheetGroupShapeRequest  {
      
    public name: string;
      
    public sheetName: string;
      
    public listShape: Array<number>;
      
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetGroupShapeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/shapes/group".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.listShape == null) ? null :   ObjectSerializer.serialize( this.listShape,this.listShape.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostWorksheetUngroupShapeRequest  {
      
    public name: string;
      
    public sheetName: string;
      
    public shapeindex: number;
      
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetUngroupShapeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/shapes/{shapeindex}/ungroup".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "shapeindex" + "}", String(this.shapeindex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get worksheet sparkline groups description.   
export class GetWorksheetSparklineGroupsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetSparklineGroupsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/sparklineGroups".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get worksheet sparkline group description.   
export class GetWorksheetSparklineGroupRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The zero based index of the element.  
    public sparklineIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetSparklineGroupRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/sparklineGroups/{sparklineIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "sparklineIndex" + "}", String(this.sparklineIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete worksheet sparkline groups description.   
export class DeleteWorksheetSparklineGroupsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetSparklineGroupsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/sparklineGroups".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete worksheet sparkline group description.   
export class DeleteWorksheetSparklineGroupRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The zero based index of the element.  
    public sparklineIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetSparklineGroupRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/sparklineGroups/{sparklineIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "sparklineIndex" + "}", String(this.sparklineIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Put worksheet sparkline group description.   
export class PutWorksheetSparklineGroupRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the sparkline types(Line/Column/Stacked).  
    public type: string;
    /// Specifies the data range of the sparkline group.  
    public dataRange: string;
    /// Specifies whether to plot the sparklines from the data range by row or by column.  
    public isVertical: boolean;
    /// Specifies where the sparklines to be placed.  
    public locationRange: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetSparklineGroupRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/sparklineGroups".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Represents the sparkline types(Line/Column/Stacked). 
        // verify required parameter 'type' is not null or undefined
        if (this.type === null || this.type === undefined) {
            throw new Error('Required parameter "type" was null or undefined when calling PutWorksheetSparklineGroup.');
        }
        /// Specifies the data range of the sparkline group. 
        // verify required parameter 'dataRange' is not null or undefined
        if (this.dataRange === null || this.dataRange === undefined) {
            throw new Error('Required parameter "dataRange" was null or undefined when calling PutWorksheetSparklineGroup.');
        }
        /// Specifies whether to plot the sparklines from the data range by row or by column. 
        // verify required parameter 'isVertical' is not null or undefined
        if (this.isVertical === null || this.isVertical === undefined) {
            throw new Error('Required parameter "isVertical" was null or undefined when calling PutWorksheetSparklineGroup.');
        }
        /// Specifies where the sparklines to be placed. 
        // verify required parameter 'locationRange' is not null or undefined
        if (this.locationRange === null || this.locationRange === undefined) {
            throw new Error('Required parameter "locationRange" was null or undefined when calling PutWorksheetSparklineGroup.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "type", this.type);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "dataRange", this.dataRange);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isVertical", this.isVertical);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "locationRange", this.locationRange);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Post worksheet sparkline group description.   
export class PostWorksheetSparklineGroupRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The zero based index of the element.  
    public sparklineGroupIndex: number;
    /// Spark line group description.  
    public sparklineGroup: SparklineGroup;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetSparklineGroupRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/sparklineGroups/{sparklineGroupIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "sparklineGroupIndex" + "}", String(this.sparklineGroupIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.sparklineGroup == null) ? null :   ObjectSerializer.serialize( this.sparklineGroup,this.sparklineGroup.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Run tasks.   
export class PostRunTaskRequest  {
    /// Task Data Descrition  
    public taskData: TaskData;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostRunTaskRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/task/runtask";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.taskData == null) ? null :   ObjectSerializer.serialize( this.taskData,this.taskData.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets workbook default style description.   
export class GetWorkbookDefaultStyleRequest  {
    /// The workbook name.  
    public name: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorkbookDefaultStyleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/defaultstyle".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get workbook's text items.   
export class GetWorkbookTextItemsRequest  {
    /// The workbook name.  
    public name: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorkbookTextItemsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/textItems".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get workbook's names.   
export class GetWorkbookNamesRequest  {
    /// The workbook name.  
    public name: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorkbookNamesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/names".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Defines a new name in workbook.   
export class PutWorkbookNameRequest  {
    /// The workbook name.  
    public name: string;
      
    public newName: Name;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorkbookNameRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/names".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.newName == null) ? null :   ObjectSerializer.serialize( this.newName,this.newName.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets workbook's name description.   
export class GetWorkbookNameRequest  {
    /// The workbook name.  
    public name: string;
    /// The name.  
    public nameName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorkbookNameRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/names/{nameName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "nameName" + "}", String(this.nameName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update workbook's name.    
export class PostWorkbookNameRequest  {
    /// The workbook name.  
    public name: string;
    /// the Aspose.Cells.Name element name.  
    public nameName: string;
    /// new name.  
    public newName: Name;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookNameRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/names/{nameName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "nameName" + "}", String(this.nameName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.newName == null) ? null :   ObjectSerializer.serialize( this.newName,this.newName.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets workbook's name value.   
export class GetWorkbookNameValueRequest  {
    /// The workbook name.  
    public name: string;
    /// the Aspose.Cells.Name element name.  
    public nameName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorkbookNameValueRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/names/{nameName}/value".replace("{" + "name" + "}", String(this.name)).replace("{" + "nameName" + "}", String(this.nameName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete workbook's names.   
export class DeleteWorkbookNamesRequest  {
    /// The workbook name.  
    public name: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorkbookNamesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/names".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets workbook's name description.   
export class DeleteWorkbookNameRequest  {
    /// The workbook name.  
    public name: string;
    /// the Aspose.Cells.Name element name.  
    public nameName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorkbookNameRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/names/{nameName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "nameName" + "}", String(this.nameName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Merge workbooks.   
export class PostWorkbooksMergeRequest  {
    /// Workbook name.  
    public name: string;
    /// The workbook to merge with.  
    public mergeWith: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// Storage name.  
    public mergedStorageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbooksMergeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/merge".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        /// The workbook to merge with. 
        // verify required parameter 'mergeWith' is not null or undefined
        if (this.mergeWith === null || this.mergeWith === undefined) {
            throw new Error('Required parameter "mergeWith" was null or undefined when calling PostWorkbooksMerge.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "mergeWith", this.mergeWith);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "mergedStorageName", this.mergedStorageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Search text in workbook.   
export class PostWorkbooksTextSearchRequest  {
    /// The workbook name.  
    public name: string;
    /// Text sample.  
    public text: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbooksTextSearchRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/findText".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        /// Text sample. 
        // verify required parameter 'text' is not null or undefined
        if (this.text === null || this.text === undefined) {
            throw new Error('Required parameter "text" was null or undefined when calling PostWorkbooksTextSearch.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "text", this.text);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Replaces text in workbook.   
export class PostWorkbookTextReplaceRequest  {
    /// The workbook name.  
    public name: string;
    /// The old value.  
    public oldValue: string;
    /// The new value.  
    public newValue: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookTextReplaceRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/replaceText".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        /// The old value. 
        // verify required parameter 'oldValue' is not null or undefined
        if (this.oldValue === null || this.oldValue === undefined) {
            throw new Error('Required parameter "oldValue" was null or undefined when calling PostWorkbookTextReplace.');
        }
        /// The new value. 
        // verify required parameter 'newValue' is not null or undefined
        if (this.newValue === null || this.newValue === undefined) {
            throw new Error('Required parameter "newValue" was null or undefined when calling PostWorkbookTextReplace.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "oldValue", this.oldValue);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "newValue", this.newValue);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Smart marker processing result.   
export class PostWorkbookGetSmartMarkerResultRequest  {
    /// The workbook name.  
    public name: string;
    /// The xml file full path, if empty the data is read from request body.  
    public xmlFile: string;
    /// Original workbook folder.  
    public folder: string;
    /// Path to save result  
    public outPath: string;
    /// Storage name.  
    public storageName: string;
    /// Storage name.  
    public outStorageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookGetSmartMarkerResultRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/smartmarker".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "xmlFile", this.xmlFile);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outPath", this.outPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outStorageName", this.outStorageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Creates new workbook using deferent methods.   
export class PutWorkbookCreateRequest  {
    /// The new document name.  
    public name: string;
    /// The template file, if the data not provided default workbook is created.  
    public templateFile: string;
    /// Smart marker data file, if the data not provided the request content is checked for the data.  
    public dataFile: string;
    /// Specifies whether to write over targer file.  
    public isWriteOver: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorkbookCreateRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "templateFile", this.templateFile);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "dataFile", this.dataFile);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isWriteOver", this.isWriteOver);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Splits workbook.   
export class PostWorkbookSplitRequest  {
    /// The workbook name.  
    public name: string;
    /// Split format.  
    public format: string;
      
    public outFolder: string;
    /// Start worksheet index.  
    public from: number;
    /// End worksheet index.  
    public to: number;
    /// Image horizontal resolution.  
    public horizontalResolution: number;
    /// Image vertical resolution.  
    public verticalResolution: number;
    /// rule name : sheetname  newguid   
    public splitNameRule: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
      
    public outStorageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookSplitRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/split".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outFolder", this.outFolder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "from", this.from);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "to", this.to);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "horizontalResolution", this.horizontalResolution);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "verticalResolution", this.verticalResolution);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "splitNameRule", this.splitNameRule);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outStorageName", this.outStorageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Calculate all formulas in workbook.   
export class PostWorkbookCalculateFormulaRequest  {
    /// The workbook name.  
    public name: string;
    /// Calculation Options.  
    public options: CalculationOptions;
    /// ignore Error.  
    public ignoreError: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookCalculateFormulaRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/calculateformula".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "ignoreError", this.ignoreError);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.options == null) ? null :   ObjectSerializer.serialize( this.options,this.options.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Autofit workbook rows.   
export class PostAutofitWorkbookRowsRequest  {
    /// The workbook name.  
    public name: string;
    /// Start row.  
    public startRow: number;
    /// End row.  
    public endRow: number;
    /// Only auto.  
    public onlyAuto: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostAutofitWorkbookRowsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/autofitrows".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startRow", this.startRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endRow", this.endRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "onlyAuto", this.onlyAuto);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostAutofitWorkbookColumnsRequest  {
      
    public name: string;
      
    public startColumn: number;
      
    public endColumn: number;
      
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostAutofitWorkbookColumnsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/autofitcolumns".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startColumn", this.startColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endColumn", this.endColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets workbook settings description.   
export class GetWorkbookSettingsRequest  {
    /// The workbook name.  
    public name: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorkbookSettingsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/settings".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Updates workbook setting.   
export class PostWorkbookSettingsRequest  {
    /// The workbook name.  
    public name: string;
    /// Workbook Setting description.  
    public settings: WorkbookSettings;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookSettingsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/settings".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.settings == null) ? null :   ObjectSerializer.serialize( this.settings,this.settings.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Set workbook background.   
export class PutWorkbookBackgroundRequest  {
    /// The workbook name.  
    public name: string;
    /// picture full path.  
    public picPath: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// File to upload  
    public file: any;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorkbookBackgroundRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/background".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "picPath", this.picPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Delete workbook background.   
export class DeleteWorkbookBackgroundRequest  {
    /// The workbook name.  
    public name: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorkbookBackgroundRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/background".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Set workbook water marker.   
export class PutWorkbookWaterMarkerRequest  {
    /// The workbook name.  
    public name: string;
    /// Text water marker request  
    public textWaterMarkerRequest: TextWaterMarkerRequest;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorkbookWaterMarkerRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/watermarker".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.textWaterMarkerRequest == null) ? null :   ObjectSerializer.serialize( this.textWaterMarkerRequest,this.textWaterMarkerRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class GetPageCountRequest  {
      
    public name: string;
      
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetPageCountRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/pagecount".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get worksheets description.   
export class GetWorksheetsRequest  {
    /// The workbook name.  
    public name: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets worksheet in some format.   
export class GetWorksheetWithFormatRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Export format(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers).  
    public format: string;
    /// Image vertical resolution.  
    public verticalResolution: number;
    /// Image horizontal resolution.  
    public horizontalResolution: number;
    /// Represents the range to be printed.  
    public area: string;
    /// Represents the page to be printed  
    public pageIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetWithFormatRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "verticalResolution", this.verticalResolution);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "horizontalResolution", this.horizontalResolution);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "area", this.area);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pageIndex", this.pageIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Changes worksheet visibility.   
export class PutChangeVisibilityWorksheetRequest  {
    /// The workbook name.  
    public name: string;
    /// Worksheet name.  
    public sheetName: string;
    /// New worksheet visibility value.  
    public isVisible: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutChangeVisibilityWorksheetRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/visible".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// New worksheet visibility value. 
        // verify required parameter 'isVisible' is not null or undefined
        if (this.isVisible === null || this.isVisible === undefined) {
            throw new Error('Required parameter "isVisible" was null or undefined when calling PutChangeVisibilityWorksheet.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isVisible", this.isVisible);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Active sheet   
export class PutActiveWorksheetRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutActiveWorksheetRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/active".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Inserts new worksheet in workbook.   
export class PutInsertNewWorksheetRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
      
    public index: number;
    /// Specifies the worksheet type(VB/Worksheet/Chart/BIFF4Macro/InternationalMacro/Other/Dialog).  
    public sheettype: string;
      
    public newsheetname: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutInsertNewWorksheetRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/insert".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        /// The worksheet name. 
        // verify required parameter 'sheetName' is not null or undefined
        if (this.sheetName === null || this.sheetName === undefined) {
            throw new Error('Required parameter "sheetName" was null or undefined when calling PutInsertNewWorksheet.');
        }
         
        // verify required parameter 'index' is not null or undefined
        if (this.index === null || this.index === undefined) {
            throw new Error('Required parameter "index" was null or undefined when calling PutInsertNewWorksheet.');
        }
        /// Specifies the worksheet type(VB/Worksheet/Chart/BIFF4Macro/InternationalMacro/Other/Dialog). 
        // verify required parameter 'sheettype' is not null or undefined
        if (this.sheettype === null || this.sheettype === undefined) {
            throw new Error('Required parameter "sheettype" was null or undefined when calling PutInsertNewWorksheet.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sheetName", this.sheetName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "index", this.index);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sheettype", this.sheettype);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "newsheetname", this.newsheetname);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds new worksheet in workbook.   
export class PutAddNewWorksheetRequest  {
    /// The workbook name.  
    public name: string;
    /// The new sheet name.  
    public sheetName: string;
    /// The new sheet position.  
    public position: number;
    /// Specifies the worksheet type(VB/Worksheet/Chart/BIFF4Macro/InternationalMacro/Other/Dialog).  
    public sheettype: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutAddNewWorksheetRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "position", this.position);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sheettype", this.sheettype);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Deletes a worksheet in workbook.   
export class DeleteWorksheetRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class DeleteWorksheetsRequest  {
      
    public name: string;
      
    public matchCondition: MatchConditionRequest;
      
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.matchCondition == null) ? null :   ObjectSerializer.serialize( this.matchCondition,this.matchCondition.constructor.name);
        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Move worksheet in workbook.   
export class PostMoveWorksheetRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// WorksheetMovingRequest with moving parameters.  
    public moving: WorksheetMovingRequest;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostMoveWorksheetRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/position".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.moving == null) ? null :   ObjectSerializer.serialize( this.moving,this.moving.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Protects worksheet.   
export class PutProtectWorksheetRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// ProtectSheetParameter with protection settings.  
    public protectParameter: ProtectSheetParameter;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutProtectWorksheetRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/protection".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.protectParameter == null) ? null :   ObjectSerializer.serialize( this.protectParameter,this.protectParameter.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Unprotects worksheet.   
export class DeleteUnprotectWorksheetRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// WorksheetResponse with protection settings. Only password is used here.  
    public protectParameter: ProtectSheetParameter;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteUnprotectWorksheetRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/protection".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.protectParameter == null) ? null :   ObjectSerializer.serialize( this.protectParameter,this.protectParameter.constructor.name);
        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get text items in worksheet.   
export class GetWorksheetTextItemsRequest  {
    /// Workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The workbook's folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetTextItemsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/textItems".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get comments description in worksheet.   
export class GetWorksheetCommentsRequest  {
    /// Workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetCommentsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/comments".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets comment by cell name in worksheet.   
export class GetWorksheetCommentRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The cell name  
    public cellName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetCommentRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/comments/{cellName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellName" + "}", String(this.cellName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds cell comment in worksheet.   
export class PutWorksheetCommentRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The cell name.  
    public cellName: string;
    /// Comment object.  
    public comment: Comment;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetCommentRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/comments/{cellName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellName" + "}", String(this.cellName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.comment == null) ? null :   ObjectSerializer.serialize( this.comment,this.comment.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Updates cell comment in worksheet.   
export class PostWorksheetCommentRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The cell name.  
    public cellName: string;
    /// Comment object.  
    public comment: Comment;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCommentRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/comments/{cellName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellName" + "}", String(this.cellName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.comment == null) ? null :   ObjectSerializer.serialize( this.comment,this.comment.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Deletes cell comment in worksheet.   
export class DeleteWorksheetCommentRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The cell name.  
    public cellName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetCommentRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/comments/{cellName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellName" + "}", String(this.cellName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete all comments in worksheet.   
export class DeleteWorksheetCommentsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetCommentsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/comments".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get worksheet merged cells.   
export class GetWorksheetMergedCellsRequest  {
    /// The workbook name.  
    public name: string;
    /// The workseet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetMergedCellsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/mergedCells".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets merged cell description by its index in worksheet.   
export class GetWorksheetMergedCellRequest  {
    /// The workbook name.  
    public name: string;
    /// Worksheet name.  
    public sheetName: string;
    /// Merged cell index.  
    public mergedCellIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetMergedCellRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/mergedCells/{mergedCellIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "mergedCellIndex" + "}", String(this.mergedCellIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Calculates formula value in worksheet.   
export class GetWorksheetCalculateFormulaRequest  {
    /// The workbook name.  
    public name: string;
    /// Worksheet name.  
    public sheetName: string;
    /// The formula.  
    public formula: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetCalculateFormulaRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/formulaResult".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The formula. 
        // verify required parameter 'formula' is not null or undefined
        if (this.formula === null || this.formula === undefined) {
            throw new Error('Required parameter "formula" was null or undefined when calling GetWorksheetCalculateFormula.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "formula", this.formula);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Calculates formula value in worksheet.   
export class PostWorksheetCalculateFormulaRequest  {
    /// The workbook name.  
    public name: string;
    /// Worksheet name.  
    public sheetName: string;
    /// The formula.  
    public formula: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCalculateFormulaRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/calculateformula".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The formula. 
        // verify required parameter 'formula' is not null or undefined
        if (this.formula === null || this.formula === undefined) {
            throw new Error('Required parameter "formula" was null or undefined when calling PostWorksheetCalculateFormula.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "formula", this.formula);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Searchs text in worksheet.   
export class PostWorksheetTextSearchRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Text to search.  
    public text: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetTextSearchRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/findText".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Text to search. 
        // verify required parameter 'text' is not null or undefined
        if (this.text === null || this.text === undefined) {
            throw new Error('Required parameter "text" was null or undefined when calling PostWorksheetTextSearch.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "text", this.text);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Replaces text in worksheet.   
export class PostWorsheetTextReplaceRequest  {
    /// The workbook name.  
    public name: string;
    /// Worksheet name.  
    public sheetName: string;
    /// The old text to replace.  
    public oldValue: string;
    /// The new text to replace by.  
    public newValue: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorsheetTextReplaceRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/replaceText".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The old text to replace. 
        // verify required parameter 'oldValue' is not null or undefined
        if (this.oldValue === null || this.oldValue === undefined) {
            throw new Error('Required parameter "oldValue" was null or undefined when calling PostWorsheetTextReplace.');
        }
        /// The new text to replace by. 
        // verify required parameter 'newValue' is not null or undefined
        if (this.newValue === null || this.newValue === undefined) {
            throw new Error('Required parameter "newValue" was null or undefined when calling PostWorsheetTextReplace.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "oldValue", this.oldValue);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "newValue", this.newValue);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Sorts range in worksheet.   
export class PostWorksheetRangeSortRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The area needed to sort.  
    public cellArea: string;
    /// DataSorter with sorting settings.  
    public dataSorter: DataSorter;
    /// The workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetRangeSortRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/sort".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The area needed to sort. 
        // verify required parameter 'cellArea' is not null or undefined
        if (this.cellArea === null || this.cellArea === undefined) {
            throw new Error('Required parameter "cellArea" was null or undefined when calling PostWorksheetRangeSort.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellArea", this.cellArea);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.dataSorter == null) ? null :   ObjectSerializer.serialize( this.dataSorter,this.dataSorter.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Autofits row in worksheet.   
export class PostAutofitWorksheetRowRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Row index.  
    public rowIndex: number;
    /// First column index.  
    public firstColumn: number;
    /// Last column index.  
    public lastColumn: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostAutofitWorksheetRowRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/autofitrow".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Row index. 
        // verify required parameter 'rowIndex' is not null or undefined
        if (this.rowIndex === null || this.rowIndex === undefined) {
            throw new Error('Required parameter "rowIndex" was null or undefined when calling PostAutofitWorksheetRow.');
        }
        /// First column index. 
        // verify required parameter 'firstColumn' is not null or undefined
        if (this.firstColumn === null || this.firstColumn === undefined) {
            throw new Error('Required parameter "firstColumn" was null or undefined when calling PostAutofitWorksheetRow.');
        }
        /// Last column index. 
        // verify required parameter 'lastColumn' is not null or undefined
        if (this.lastColumn === null || this.lastColumn === undefined) {
            throw new Error('Required parameter "lastColumn" was null or undefined when calling PostAutofitWorksheetRow.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "rowIndex", this.rowIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "firstColumn", this.firstColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "lastColumn", this.lastColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Autofit rows in worksheet.   
export class PostAutofitWorksheetRowsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Start row index.  
    public startRow: number;
    /// End row index.  
    public endRow: number;
    /// Autofits all rows in this worksheet.  
    public onlyAuto: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostAutofitWorksheetRowsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/autofitrows".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startRow", this.startRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endRow", this.endRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "onlyAuto", this.onlyAuto);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostAutofitWorksheetColumnsRequest  {
      
    public name: string;
      
    public sheetName: string;
      
    public startColumn: number;
      
    public endColumn: number;
      
    public onlyAuto: boolean;
      
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostAutofitWorksheetColumnsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/autofitcolumns".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startColumn", this.startColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endColumn", this.endColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "onlyAuto", this.onlyAuto);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Sets background image in worksheet.   
export class PutWorksheetBackgroundRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// picture full filename.  
    public picPath: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// File to upload  
    public file: any;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetBackgroundRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/background".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "picPath", this.picPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            for (var key in this.file){
                formParams[key] = this.file[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Delete background image in worksheet.   
export class DeleteWorksheetBackgroundRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetBackgroundRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/background".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Sets freeze panes in worksheet.   
export class PutWorksheetFreezePanesRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Row index.  
    public row: number;
    /// Column index.  
    public column: number;
    /// Number of visible rows in top pane, no more than row index.  
    public freezedRows: number;
    /// Number of visible columns in left pane, no more than column index.  
    public freezedColumns: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetFreezePanesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/freezepanes".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Row index. 
        // verify required parameter 'row' is not null or undefined
        if (this.row === null || this.row === undefined) {
            throw new Error('Required parameter "row" was null or undefined when calling PutWorksheetFreezePanes.');
        }
        /// Column index. 
        // verify required parameter 'column' is not null or undefined
        if (this.column === null || this.column === undefined) {
            throw new Error('Required parameter "column" was null or undefined when calling PutWorksheetFreezePanes.');
        }
        /// Number of visible rows in top pane, no more than row index. 
        // verify required parameter 'freezedRows' is not null or undefined
        if (this.freezedRows === null || this.freezedRows === undefined) {
            throw new Error('Required parameter "freezedRows" was null or undefined when calling PutWorksheetFreezePanes.');
        }
        /// Number of visible columns in left pane, no more than column index. 
        // verify required parameter 'freezedColumns' is not null or undefined
        if (this.freezedColumns === null || this.freezedColumns === undefined) {
            throw new Error('Required parameter "freezedColumns" was null or undefined when calling PutWorksheetFreezePanes.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "row", this.row);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "column", this.column);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "freezedRows", this.freezedRows);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "freezedColumns", this.freezedColumns);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Unfreezes panes in worksheet.   
export class DeleteWorksheetFreezePanesRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Row index.  
    public row: number;
    /// Column index.  
    public column: number;
    /// Number of visible rows in top pane, no more than row index.  
    public freezedRows: number;
    /// Number of visible columns in left pane, no more than column index.  
    public freezedColumns: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetFreezePanesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/freezepanes".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Row index. 
        // verify required parameter 'row' is not null or undefined
        if (this.row === null || this.row === undefined) {
            throw new Error('Required parameter "row" was null or undefined when calling DeleteWorksheetFreezePanes.');
        }
        /// Column index. 
        // verify required parameter 'column' is not null or undefined
        if (this.column === null || this.column === undefined) {
            throw new Error('Required parameter "column" was null or undefined when calling DeleteWorksheetFreezePanes.');
        }
        /// Number of visible rows in top pane, no more than row index. 
        // verify required parameter 'freezedRows' is not null or undefined
        if (this.freezedRows === null || this.freezedRows === undefined) {
            throw new Error('Required parameter "freezedRows" was null or undefined when calling DeleteWorksheetFreezePanes.');
        }
        /// Number of visible columns in left pane, no more than column index. 
        // verify required parameter 'freezedColumns' is not null or undefined
        if (this.freezedColumns === null || this.freezedColumns === undefined) {
            throw new Error('Required parameter "freezedColumns" was null or undefined when calling DeleteWorksheetFreezePanes.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "row", this.row);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "column", this.column);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "freezedRows", this.freezedRows);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "freezedColumns", this.freezedColumns);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Copies contents and formats from another worksheet.   
export class PostCopyWorksheetRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Source worksheet.  
    public sourceSheet: string;
    /// Represents the copy options.  
    public options: CopyOptions;
    /// source Workbook.  
    public sourceWorkbook: string;
    /// Original workbook folder.  
    public sourceFolder: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostCopyWorksheetRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/copy".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Source worksheet. 
        // verify required parameter 'sourceSheet' is not null or undefined
        if (this.sourceSheet === null || this.sourceSheet === undefined) {
            throw new Error('Required parameter "sourceSheet" was null or undefined when calling PostCopyWorksheet.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sourceSheet", this.sourceSheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sourceWorkbook", this.sourceWorkbook);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sourceFolder", this.sourceFolder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.options == null) ? null :   ObjectSerializer.serialize( this.options,this.options.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Rename worksheet.   
export class PostRenameWorksheetRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// New worksheet name.  
    public newname: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostRenameWorksheetRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/rename".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// New worksheet name. 
        // verify required parameter 'newname' is not null or undefined
        if (this.newname === null || this.newname === undefined) {
            throw new Error('Required parameter "newname" was null or undefined when calling PostRenameWorksheet.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "newname", this.newname);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update worksheet properties.   
export class PostUpdateWorksheetPropertyRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The worksheet description.  
    public sheet: Worksheet;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUpdateWorksheetPropertyRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.sheet == null) ? null :   ObjectSerializer.serialize( this.sheet,this.sheet.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get worksheets ranges description.   
export class GetNamedRangesRequest  {
    /// The workbook name.  
    public name: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetNamedRangesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/ranges".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get range values.   
export class GetNamedRangeValueRequest  {
    /// The workbook name.  
    public name: string;
    /// Range name.  
    public namerange: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetNamedRangeValueRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/ranges/{namerange}/value".replace("{" + "name" + "}", String(this.name)).replace("{" + "namerange" + "}", String(this.namerange));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Updates worksheet zoom.   
export class PostUpdateWorksheetZoomRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the scaling factor in percentage. It should be between 10 and 400.  
    public value: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUpdateWorksheetZoomRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/zoom".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Represents the scaling factor in percentage. It should be between 10 and 400. 
        // verify required parameter 'value' is not null or undefined
        if (this.value === null || this.value === undefined) {
            throw new Error('Required parameter "value" was null or undefined when calling PostUpdateWorksheetZoom.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "value", this.value);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class GetWorksheetPageCountRequest  {
      
    public name: string;
      
    public sheetName: string;
      
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetPageCountRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/pagecount".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get validations description in worksheet.   
export class GetWorksheetValidationsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetValidationsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/validations".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets a validation by index in worksheet.   
export class GetWorksheetValidationRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The validation index.  
    public validationIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetValidationRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/validations/{validationIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "validationIndex" + "}", String(this.validationIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds a validation at index in worksheet.   
export class PutWorksheetValidationRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Specified cells area  
    public range: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetValidationRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/validations".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Updates a validation by index in worksheet.   
export class PostWorksheetValidationRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The validation index.  
    public validationIndex: number;
    /// Validation description.  
    public validation: Validation;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetValidationRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/validations/{validationIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "validationIndex" + "}", String(this.validationIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.validation == null) ? null :   ObjectSerializer.serialize( this.validation,this.validation.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Deletes a validation by index in worksheet.   
export class DeleteWorksheetValidationRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The validation index.  
    public validationIndex: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetValidationRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/validations/{validationIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "validationIndex" + "}", String(this.validationIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete all validations in worksheet.   
export class DeleteWorksheetValidationsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetValidationsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/{name}/worksheets/{sheetName}/validations".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class DownloadFileRequest  {
      
    public path: string;
      
    public storageName: string;
      
    public versionId: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DownloadFileRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/storage/file/{path}".replace("{" + "path" + "}", String(this.path));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "versionId", this.versionId);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class UploadFileRequest  {
    /// Upload files to cloud storage.  
    public uploadFiles: any;
      
    public path: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< UploadFileRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/storage/file/{path}".replace("{" + "path" + "}", String(this.path));
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.uploadFiles !== undefined) {
            for (var key in this.uploadFiles){
                formParams[key] = this.uploadFiles[key];
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
   
export class CopyFileRequest  {
      
    public srcPath: string;
      
    public destPath: string;
      
    public srcStorageName: string;
      
    public destStorageName: string;
      
    public versionId: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< CopyFileRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/storage/file/copy/{srcPath}".replace("{" + "srcPath" + "}", String(this.srcPath));
        const queryParameters: any = {};
         
        // verify required parameter 'destPath' is not null or undefined
        if (this.destPath === null || this.destPath === undefined) {
            throw new Error('Required parameter "destPath" was null or undefined when calling CopyFile.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destPath", this.destPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "srcStorageName", this.srcStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destStorageName", this.destStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "versionId", this.versionId);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class MoveFileRequest  {
      
    public srcPath: string;
      
    public destPath: string;
      
    public srcStorageName: string;
      
    public destStorageName: string;
      
    public versionId: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< MoveFileRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/storage/file/move/{srcPath}".replace("{" + "srcPath" + "}", String(this.srcPath));
        const queryParameters: any = {};
         
        // verify required parameter 'destPath' is not null or undefined
        if (this.destPath === null || this.destPath === undefined) {
            throw new Error('Required parameter "destPath" was null or undefined when calling MoveFile.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destPath", this.destPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "srcStorageName", this.srcStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destStorageName", this.destStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "versionId", this.versionId);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class DeleteFileRequest  {
      
    public path: string;
      
    public storageName: string;
      
    public versionId: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteFileRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/storage/file/{path}".replace("{" + "path" + "}", String(this.path));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "versionId", this.versionId);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class GetFilesListRequest  {
      
    public path: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetFilesListRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/storage/folder/{path}".replace("{" + "path" + "}", String(this.path));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class CreateFolderRequest  {
      
    public path: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< CreateFolderRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/storage/folder/{path}".replace("{" + "path" + "}", String(this.path));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class CopyFolderRequest  {
      
    public srcPath: string;
      
    public destPath: string;
      
    public srcStorageName: string;
      
    public destStorageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< CopyFolderRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/storage/folder/copy/{srcPath}".replace("{" + "srcPath" + "}", String(this.srcPath));
        const queryParameters: any = {};
         
        // verify required parameter 'destPath' is not null or undefined
        if (this.destPath === null || this.destPath === undefined) {
            throw new Error('Required parameter "destPath" was null or undefined when calling CopyFolder.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destPath", this.destPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "srcStorageName", this.srcStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destStorageName", this.destStorageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class MoveFolderRequest  {
      
    public srcPath: string;
      
    public destPath: string;
      
    public srcStorageName: string;
      
    public destStorageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< MoveFolderRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/storage/folder/move/{srcPath}".replace("{" + "srcPath" + "}", String(this.srcPath));
        const queryParameters: any = {};
         
        // verify required parameter 'destPath' is not null or undefined
        if (this.destPath === null || this.destPath === undefined) {
            throw new Error('Required parameter "destPath" was null or undefined when calling MoveFolder.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destPath", this.destPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "srcStorageName", this.srcStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destStorageName", this.destStorageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class DeleteFolderRequest  {
      
    public path: string;
      
    public storageName: string;
      
    public recursive: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteFolderRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/storage/folder/{path}".replace("{" + "path" + "}", String(this.path));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "recursive", this.recursive);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class StorageExistsRequest  {
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< StorageExistsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/storage/{storageName}/exist".replace("{" + "storageName" + "}", String(this.storageName));
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class ObjectExistsRequest  {
      
    public path: string;
      
    public storageName: string;
      
    public versionId: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< ObjectExistsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/storage/exist/{path}".replace("{" + "path" + "}", String(this.path));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "versionId", this.versionId);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class GetDiscUsageRequest  {
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetDiscUsageRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/storage/disc";
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class GetFileVersionsRequest  {
      
    public path: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetFileVersionsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "/cells/storage/version/{path}".replace("{" + "path" + "}", String(this.path));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
