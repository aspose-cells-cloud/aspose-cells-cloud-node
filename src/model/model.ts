import { Configuration } from "../internal/configuration";
import { addQueryParameterToUrl } from "../internal/requestHelper";
import { ObjectSerializer } from "../internal/objectSerializer";
const fs = require('fs');
const path = require('path');

export class ValueType {

    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return ValueType.attributeTypeMap;
    }

    public constructor(init?: Partial<ValueType>) {        
        Object.assign(this, init);
    }        
}

export class Point {

    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "x",
            baseName: "X",
            type: "number",
        },
        {
            name: "y",
            baseName: "Y",
            type: "number",
        } 
    ];

    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return ValueType.attributeTypeMap;
    }
    public x: number;
    public y: number;
    public constructor(init?: Partial<Point>) {        
        Object.assign(this, init);
    }        
}

/// Class for disc space information.   
export class DiscUsage  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "usedSize",
            baseName: "UsedSize",
            type: "number",
        },
        {
            name: "totalSize",
            baseName: "TotalSize",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DiscUsage.attributeTypeMap;

    }

    public usedSize: number;
    public totalSize: number;

    public constructor(init?: Partial< DiscUsage >) {  
    
        Object.assign(this, init);
    } 
}
/// Object exists   
export class ObjectExist  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "exists",
            baseName: "Exists",
            type: "boolean",
        },
        {
            name: "isFolder",
            baseName: "IsFolder",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ObjectExist.attributeTypeMap;

    }

    public exists: boolean;
    public isFolder: boolean;

    public constructor(init?: Partial< ObjectExist >) {  
    
        Object.assign(this, init);
    } 
}
   
export class ObjectExistsExtensions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ObjectExistsExtensions.attributeTypeMap;

    }


    public constructor(init?: Partial< ObjectExistsExtensions >) {  
    
        Object.assign(this, init);
    } 
}
/// File or folder information   
export class StorageFile  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "isFolder",
            baseName: "IsFolder",
            type: "boolean",
        },
        {
            name: "modifiedDate",
            baseName: "ModifiedDate",
            type: "Date",
        },
        {
            name: "size",
            baseName: "Size",
            type: "number",
        },
        {
            name: "path",
            baseName: "Path",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  StorageFile.attributeTypeMap;

    }

    public name: string;
    public isFolder: boolean;
    public modifiedDate: Date;
    public size: number;
    public path: string;

    public constructor(init?: Partial< StorageFile >) {  
    
        Object.assign(this, init);
    } 
}
   
export class FileVersion  extends StorageFile  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "versionId",
            baseName: "VersionId",
            type: "string",
        },
        {
            name: "isLatest",
            baseName: "IsLatest",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FileVersion.attributeTypeMap) ;

    }

    public versionId: string;
    public isLatest: boolean;

    public constructor(init?: Partial< FileVersion >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Storage exists   
export class StorageExist  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "exists",
            baseName: "Exists",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  StorageExist.attributeTypeMap;

    }

    public exists: boolean;

    public constructor(init?: Partial< StorageExist >) {  
    
        Object.assign(this, init);
    } 
}
/// File versions FileVersion.   
export class FileVersions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "value",
            baseName: "Value",
            type: "Array<FileVersion>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  FileVersions.attributeTypeMap;

    }

    public value: Array<FileVersion>;

    public constructor(init?: Partial< FileVersions >) {  
    
        Object.assign(this, init);
    } 
}
/// Files list   
export class FilesList  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "value",
            baseName: "Value",
            type: "Array<StorageFile>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  FilesList.attributeTypeMap;

    }

    public value: Array<StorageFile>;

    public constructor(init?: Partial< FilesList >) {  
    
        Object.assign(this, init);
    } 
}
/// Error   
export class Error  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Error.attributeTypeMap;

    }


    public constructor(init?: Partial< Error >) {  
    
        Object.assign(this, init);
    } 
}
/// File upload result   
export class FilesUploadResult  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "uploaded",
            baseName: "Uploaded",
            type: "Array<string>",
        },
        {
            name: "errors",
            baseName: "Errors",
            type: "Array<Error>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  FilesUploadResult.attributeTypeMap;

    }

    public uploaded: Array<string>;
    public errors: Array<Error>;

    public constructor(init?: Partial< FilesUploadResult >) {  
    
        Object.assign(this, init);
    } 
}
   
export class GoogleDriveStorageFile  extends StorageFile  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "mimeType",
            baseName: "MimeType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(GoogleDriveStorageFile.attributeTypeMap) ;

    }

    public mimeType: string;

    public constructor(init?: Partial< GoogleDriveStorageFile >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class BrokenLink  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "filename",
            baseName: "Filename",
            type: "string",
        },
        {
            name: "worksheet",
            baseName: "Worksheet",
            type: "string",
        },
        {
            name: "position",
            baseName: "Position",
            type: "string",
        },
        {
            name: "linkAddress",
            baseName: "LinkAddress",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  BrokenLink.attributeTypeMap;

    }

    public filename: string;
    public worksheet: string;
    public position: string;
    public linkAddress: string;

    public constructor(init?: Partial< BrokenLink >) {  
    
        Object.assign(this, init);
    } 
}
   
export class CellArea  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "endColumn",
            baseName: "EndColumn",
            type: "number",
        },
        {
            name: "endRow",
            baseName: "EndRow",
            type: "number",
        },
        {
            name: "startColumn",
            baseName: "StartColumn",
            type: "number",
        },
        {
            name: "startRow",
            baseName: "StartRow",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CellArea.attributeTypeMap;

    }

    public endColumn: number;
    public endRow: number;
    public startColumn: number;
    public startRow: number;

    public constructor(init?: Partial< CellArea >) {  
    
        Object.assign(this, init);
    } 
}
   
export class CellsCloudFileInfo  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "size",
            baseName: "Size",
            type: "number",
        },
        {
            name: "folder",
            baseName: "Folder",
            type: "string",
        },
        {
            name: "storage",
            baseName: "Storage",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CellsCloudFileInfo.attributeTypeMap;

    }

    public name: string;
    public size: number;
    public folder: string;
    public storage: string;

    public constructor(init?: Partial< CellsCloudFileInfo >) {  
    
        Object.assign(this, init);
    } 
}
   
export class CellsCloudPublicKey  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "exponent",
            baseName: "Exponent",
            type: "string",
        },
        {
            name: "modulus",
            baseName: "Modulus",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CellsCloudPublicKey.attributeTypeMap;

    }

    public exponent: string;
    public modulus: string;

    public constructor(init?: Partial< CellsCloudPublicKey >) {  
    
        Object.assign(this, init);
    } 
}
   
export class Color  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "a",
            baseName: "A",
            type: "number",
        },
        {
            name: "r",
            baseName: "R",
            type: "number",
        },
        {
            name: "g",
            baseName: "G",
            type: "number",
        },
        {
            name: "b",
            baseName: "B",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Color.attributeTypeMap;

    }

    public a: number;
    public r: number;
    public g: number;
    public b: number;

    public constructor(init?: Partial< Color >) {  
    
        Object.assign(this, init);
    } 
}
   
export class PdfSecurityOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "annotationsPermission",
            baseName: "AnnotationsPermission",
            type: "boolean",
        },
        {
            name: "assembleDocumentPermission",
            baseName: "AssembleDocumentPermission",
            type: "boolean",
        },
        {
            name: "extractContentPermission",
            baseName: "ExtractContentPermission",
            type: "boolean",
        },
        {
            name: "fillFormsPermission",
            baseName: "FillFormsPermission",
            type: "boolean",
        },
        {
            name: "fullQualityPrintPermission",
            baseName: "FullQualityPrintPermission",
            type: "boolean",
        },
        {
            name: "modifyDocumentPermission",
            baseName: "ModifyDocumentPermission",
            type: "boolean",
        },
        {
            name: "ownerPassword",
            baseName: "OwnerPassword",
            type: "string",
        },
        {
            name: "printPermission",
            baseName: "PrintPermission",
            type: "boolean",
        },
        {
            name: "userPassword",
            baseName: "UserPassword",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  PdfSecurityOptions.attributeTypeMap;

    }

    public annotationsPermission: boolean;
    public assembleDocumentPermission: boolean;
    public extractContentPermission: boolean;
    public fillFormsPermission: boolean;
    public fullQualityPrintPermission: boolean;
    public modifyDocumentPermission: boolean;
    public ownerPassword: string;
    public printPermission: boolean;
    public userPassword: string;

    public constructor(init?: Partial< PdfSecurityOptions >) {  
    
        Object.assign(this, init);
    } 
}
   
export class Range  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "columnCount",
            baseName: "ColumnCount",
            type: "number",
        },
        {
            name: "columnWidth",
            baseName: "ColumnWidth",
            type: "number",
        },
        {
            name: "firstColumn",
            baseName: "FirstColumn",
            type: "number",
        },
        {
            name: "firstRow",
            baseName: "FirstRow",
            type: "number",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "refersTo",
            baseName: "RefersTo",
            type: "string",
        },
        {
            name: "rowCount",
            baseName: "RowCount",
            type: "number",
        },
        {
            name: "rowHeight",
            baseName: "RowHeight",
            type: "number",
        },
        {
            name: "worksheet",
            baseName: "Worksheet",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Range.attributeTypeMap;

    }

    public columnCount: number;
    public columnWidth: number;
    public firstColumn: number;
    public firstRow: number;
    public name: string;
    public refersTo: string;
    public rowCount: number;
    public rowHeight: number;
    public worksheet: string;

    public constructor(init?: Partial< Range >) {  
    
        Object.assign(this, init);
    } 
}
   
export class SaveResult  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "documents",
            baseName: "Documents",
            type: "Array<CellsCloudFileInfo>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  SaveResult.attributeTypeMap;

    }

    public documents: Array<CellsCloudFileInfo>;

    public constructor(init?: Partial< SaveResult >) {  
    
        Object.assign(this, init);
    } 
}
   
export class SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "saveFormat",
            baseName: "SaveFormat",
            type: "string",
        },
        {
            name: "cachedFileFolder",
            baseName: "CachedFileFolder",
            type: "string",
        },
        {
            name: "clearData",
            baseName: "ClearData",
            type: "boolean",
        },
        {
            name: "createDirectory",
            baseName: "CreateDirectory",
            type: "boolean",
        },
        {
            name: "enableHTTPCompression",
            baseName: "EnableHTTPCompression",
            type: "boolean",
        },
        {
            name: "refreshChartCache",
            baseName: "RefreshChartCache",
            type: "boolean",
        },
        {
            name: "sortNames",
            baseName: "SortNames",
            type: "boolean",
        },
        {
            name: "validateMergedAreas",
            baseName: "ValidateMergedAreas",
            type: "boolean",
        },
        {
            name: "mergeAreas",
            baseName: "MergeAreas",
            type: "boolean",
        },
        {
            name: "sortExternalNames",
            baseName: "SortExternalNames",
            type: "boolean",
        },
        {
            name: "checkExcelRestriction",
            baseName: "CheckExcelRestriction",
            type: "boolean",
        },
        {
            name: "updateSmartArt",
            baseName: "UpdateSmartArt",
            type: "boolean",
        },
        {
            name: "encryptDocumentProperties",
            baseName: "EncryptDocumentProperties",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  SaveOptions.attributeTypeMap;

    }

    public saveFormat: string;
    public cachedFileFolder: string;
    public clearData: boolean;
    public createDirectory: boolean;
    public enableHTTPCompression: boolean;
    public refreshChartCache: boolean;
    public sortNames: boolean;
    public validateMergedAreas: boolean;
    public mergeAreas: boolean;
    public sortExternalNames: boolean;
    public checkExcelRestriction: boolean;
    public updateSmartArt: boolean;
    public encryptDocumentProperties: boolean;

    public constructor(init?: Partial< SaveOptions >) {  
    
        Object.assign(this, init);
    } 
}
   
export class PaginatedSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "defaultFont",
            baseName: "DefaultFont",
            type: "string",
        },
        {
            name: "checkWorkbookDefaultFont",
            baseName: "CheckWorkbookDefaultFont",
            type: "boolean",
        },
        {
            name: "checkFontCompatibility",
            baseName: "CheckFontCompatibility",
            type: "boolean",
        },
        {
            name: "isFontSubstitutionCharGranularity",
            baseName: "IsFontSubstitutionCharGranularity",
            type: "boolean",
        },
        {
            name: "onePagePerSheet",
            baseName: "OnePagePerSheet",
            type: "boolean",
        },
        {
            name: "allColumnsInOnePagePerSheet",
            baseName: "AllColumnsInOnePagePerSheet",
            type: "boolean",
        },
        {
            name: "ignoreError",
            baseName: "IgnoreError",
            type: "boolean",
        },
        {
            name: "outputBlankPageWhenNothingToPrint",
            baseName: "OutputBlankPageWhenNothingToPrint",
            type: "boolean",
        },
        {
            name: "pageIndex",
            baseName: "PageIndex",
            type: "number",
        },
        {
            name: "pageCount",
            baseName: "PageCount",
            type: "number",
        },
        {
            name: "printingPageType",
            baseName: "PrintingPageType",
            type: "string",
        },
        {
            name: "gridlineType",
            baseName: "GridlineType",
            type: "string",
        },
        {
            name: "textCrossType",
            baseName: "TextCrossType",
            type: "string",
        },
        {
            name: "defaultEditLanguage",
            baseName: "DefaultEditLanguage",
            type: "string",
        },
        {
            name: "emfRenderSetting",
            baseName: "EmfRenderSetting",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PaginatedSaveOptions.attributeTypeMap) ;

    }

    public defaultFont: string;
    public checkWorkbookDefaultFont: boolean;
    public checkFontCompatibility: boolean;
    public isFontSubstitutionCharGranularity: boolean;
    public onePagePerSheet: boolean;
    public allColumnsInOnePagePerSheet: boolean;
    public ignoreError: boolean;
    public outputBlankPageWhenNothingToPrint: boolean;
    public pageIndex: number;
    public pageCount: number;
    public printingPageType: string;
    public gridlineType: string;
    public textCrossType: string;
    public defaultEditLanguage: string;
    public emfRenderSetting: string;

    public constructor(init?: Partial< PaginatedSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class TextItem  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "filename",
            baseName: "Filename",
            type: "string",
        },
        {
            name: "worksheet",
            baseName: "Worksheet",
            type: "string",
        },
        {
            name: "position",
            baseName: "Position",
            type: "string",
        },
        {
            name: "content",
            baseName: "Content",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  TextItem.attributeTypeMap;

    }

    public filename: string;
    public worksheet: string;
    public position: string;
    public content: string;

    public constructor(init?: Partial< TextItem >) {  
    
        Object.assign(this, init);
    } 
}
   
export class DbfSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "exportAsString",
            baseName: "ExportAsString",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DbfSaveOptions.attributeTypeMap) ;

    }

    public exportAsString: boolean;

    public constructor(init?: Partial< DbfSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class DifSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DifSaveOptions.attributeTypeMap) ;

    }


    public constructor(init?: Partial< DifSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class DocxSaveOptions  extends PaginatedSaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DocxSaveOptions.attributeTypeMap) ;

    }


    public constructor(init?: Partial< DocxSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class ImageOrPrintOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "textCrossType",
            baseName: "TextCrossType",
            type: "string",
        },
        {
            name: "gridlineType",
            baseName: "GridlineType",
            type: "string",
        },
        {
            name: "outputBlankPageWhenNothingToPrint",
            baseName: "OutputBlankPageWhenNothingToPrint",
            type: "boolean",
        },
        {
            name: "checkWorkbookDefaultFont",
            baseName: "CheckWorkbookDefaultFont",
            type: "boolean",
        },
        {
            name: "defaultFont",
            baseName: "DefaultFont",
            type: "string",
        },
        {
            name: "isOptimized",
            baseName: "IsOptimized",
            type: "boolean",
        },
        {
            name: "pageCount",
            baseName: "PageCount",
            type: "number",
        },
        {
            name: "pageIndex",
            baseName: "PageIndex",
            type: "number",
        },
        {
            name: "isFontSubstitutionCharGranularity",
            baseName: "IsFontSubstitutionCharGranularity",
            type: "boolean",
        },
        {
            name: "transparent",
            baseName: "Transparent",
            type: "boolean",
        },
        {
            name: "onlyArea",
            baseName: "OnlyArea",
            type: "boolean",
        },
        {
            name: "sVGFitToViewPort",
            baseName: "SVGFitToViewPort",
            type: "boolean",
        },
        {
            name: "embededImageNameInSvg",
            baseName: "EmbededImageNameInSvg",
            type: "string",
        },
        {
            name: "allColumnsInOnePagePerSheet",
            baseName: "AllColumnsInOnePagePerSheet",
            type: "boolean",
        },
        {
            name: "printWithStatusDialog",
            baseName: "PrintWithStatusDialog",
            type: "boolean",
        },
        {
            name: "horizontalResolution",
            baseName: "HorizontalResolution",
            type: "number",
        },
        {
            name: "verticalResolution",
            baseName: "VerticalResolution",
            type: "number",
        },
        {
            name: "defaultEditLanguage",
            baseName: "DefaultEditLanguage",
            type: "string",
        },
        {
            name: "tiffColorDepth",
            baseName: "TiffColorDepth",
            type: "string",
        },
        {
            name: "tiffCompression",
            baseName: "TiffCompression",
            type: "string",
        },
        {
            name: "printingPage",
            baseName: "PrintingPage",
            type: "string",
        },
        {
            name: "quality",
            baseName: "Quality",
            type: "number",
        },
        {
            name: "imageType",
            baseName: "ImageType",
            type: "string",
        },
        {
            name: "onePagePerSheet",
            baseName: "OnePagePerSheet",
            type: "boolean",
        },
        {
            name: "tiffBinarizationMethod",
            baseName: "TiffBinarizationMethod",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ImageOrPrintOptions.attributeTypeMap;

    }

    public textCrossType: string;
    public gridlineType: string;
    public outputBlankPageWhenNothingToPrint: boolean;
    public checkWorkbookDefaultFont: boolean;
    public defaultFont: string;
    public isOptimized: boolean;
    public pageCount: number;
    public pageIndex: number;
    public isFontSubstitutionCharGranularity: boolean;
    public transparent: boolean;
    public onlyArea: boolean;
    public sVGFitToViewPort: boolean;
    public embededImageNameInSvg: string;
    public allColumnsInOnePagePerSheet: boolean;
    public printWithStatusDialog: boolean;
    public horizontalResolution: number;
    public verticalResolution: number;
    public defaultEditLanguage: string;
    public tiffColorDepth: string;
    public tiffCompression: string;
    public printingPage: string;
    public quality: number;
    public imageType: string;
    public onePagePerSheet: boolean;
    public tiffBinarizationMethod: string;

    public constructor(init?: Partial< ImageOrPrintOptions >) {  
    
        Object.assign(this, init);
    } 
}
   
export class HtmlSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "exportPageHeaders",
            baseName: "ExportPageHeaders",
            type: "boolean",
        },
        {
            name: "exportPageFooters",
            baseName: "ExportPageFooters",
            type: "boolean",
        },
        {
            name: "exportRowColumnHeadings",
            baseName: "ExportRowColumnHeadings",
            type: "boolean",
        },
        {
            name: "showAllSheets",
            baseName: "ShowAllSheets",
            type: "boolean",
        },
        {
            name: "imageOptions",
            baseName: "ImageOptions",
            type: "ImageOrPrintOptions",
        },
        {
            name: "saveAsSingleFile",
            baseName: "SaveAsSingleFile",
            type: "boolean",
        },
        {
            name: "exportHiddenWorksheet",
            baseName: "ExportHiddenWorksheet",
            type: "boolean",
        },
        {
            name: "exportGridLines",
            baseName: "ExportGridLines",
            type: "boolean",
        },
        {
            name: "presentationPreference",
            baseName: "PresentationPreference",
            type: "boolean",
        },
        {
            name: "cellCssPrefix",
            baseName: "CellCssPrefix",
            type: "string",
        },
        {
            name: "tableCssId",
            baseName: "TableCssId",
            type: "string",
        },
        {
            name: "isFullPathLink",
            baseName: "IsFullPathLink",
            type: "boolean",
        },
        {
            name: "exportWorksheetCSSSeparately",
            baseName: "ExportWorksheetCSSSeparately",
            type: "boolean",
        },
        {
            name: "exportSimilarBorderStyle",
            baseName: "ExportSimilarBorderStyle",
            type: "boolean",
        },
        {
            name: "mergeEmptyTdForcely",
            baseName: "MergeEmptyTdForcely",
            type: "boolean",
        },
        {
            name: "exportCellCoordinate",
            baseName: "ExportCellCoordinate",
            type: "boolean",
        },
        {
            name: "exportExtraHeadings",
            baseName: "ExportExtraHeadings",
            type: "boolean",
        },
        {
            name: "exportHeadings",
            baseName: "ExportHeadings",
            type: "boolean",
        },
        {
            name: "exportFormula",
            baseName: "ExportFormula",
            type: "boolean",
        },
        {
            name: "addTooltipText",
            baseName: "AddTooltipText",
            type: "boolean",
        },
        {
            name: "exportBogusRowData",
            baseName: "ExportBogusRowData",
            type: "boolean",
        },
        {
            name: "excludeUnusedStyles",
            baseName: "ExcludeUnusedStyles",
            type: "boolean",
        },
        {
            name: "exportDocumentProperties",
            baseName: "ExportDocumentProperties",
            type: "boolean",
        },
        {
            name: "exportWorksheetProperties",
            baseName: "ExportWorksheetProperties",
            type: "boolean",
        },
        {
            name: "exportWorkbookProperties",
            baseName: "ExportWorkbookProperties",
            type: "boolean",
        },
        {
            name: "exportFrameScriptsAndProperties",
            baseName: "ExportFrameScriptsAndProperties",
            type: "boolean",
        },
        {
            name: "attachedFilesDirectory",
            baseName: "AttachedFilesDirectory",
            type: "string",
        },
        {
            name: "attachedFilesUrlPrefix",
            baseName: "AttachedFilesUrlPrefix",
            type: "string",
        },
        {
            name: "encoding",
            baseName: "Encoding",
            type: "string",
        },
        {
            name: "exportActiveWorksheetOnly",
            baseName: "ExportActiveWorksheetOnly",
            type: "boolean",
        },
        {
            name: "exportChartImageFormat",
            baseName: "ExportChartImageFormat",
            type: "string",
        },
        {
            name: "exportImagesAsBase64",
            baseName: "ExportImagesAsBase64",
            type: "boolean",
        },
        {
            name: "hiddenColDisplayType",
            baseName: "HiddenColDisplayType",
            type: "string",
        },
        {
            name: "hiddenRowDisplayType",
            baseName: "HiddenRowDisplayType",
            type: "string",
        },
        {
            name: "htmlCrossStringType",
            baseName: "HtmlCrossStringType",
            type: "string",
        },
        {
            name: "isExpImageToTempDir",
            baseName: "IsExpImageToTempDir",
            type: "boolean",
        },
        {
            name: "pageTitle",
            baseName: "PageTitle",
            type: "string",
        },
        {
            name: "parseHtmlTagInCell",
            baseName: "ParseHtmlTagInCell",
            type: "boolean",
        },
        {
            name: "cellNameAttribute",
            baseName: "CellNameAttribute",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(HtmlSaveOptions.attributeTypeMap) ;

    }

    public exportPageHeaders: boolean;
    public exportPageFooters: boolean;
    public exportRowColumnHeadings: boolean;
    public showAllSheets: boolean;
    public imageOptions: ImageOrPrintOptions;
    public saveAsSingleFile: boolean;
    public exportHiddenWorksheet: boolean;
    public exportGridLines: boolean;
    public presentationPreference: boolean;
    public cellCssPrefix: string;
    public tableCssId: string;
    public isFullPathLink: boolean;
    public exportWorksheetCSSSeparately: boolean;
    public exportSimilarBorderStyle: boolean;
    public mergeEmptyTdForcely: boolean;
    public exportCellCoordinate: boolean;
    public exportExtraHeadings: boolean;
    public exportHeadings: boolean;
    public exportFormula: boolean;
    public addTooltipText: boolean;
    public exportBogusRowData: boolean;
    public excludeUnusedStyles: boolean;
    public exportDocumentProperties: boolean;
    public exportWorksheetProperties: boolean;
    public exportWorkbookProperties: boolean;
    public exportFrameScriptsAndProperties: boolean;
    public attachedFilesDirectory: string;
    public attachedFilesUrlPrefix: string;
    public encoding: string;
    public exportActiveWorksheetOnly: boolean;
    public exportChartImageFormat: string;
    public exportImagesAsBase64: boolean;
    public hiddenColDisplayType: string;
    public hiddenRowDisplayType: string;
    public htmlCrossStringType: string;
    public isExpImageToTempDir: boolean;
    public pageTitle: string;
    public parseHtmlTagInCell: boolean;
    public cellNameAttribute: string;

    public constructor(init?: Partial< HtmlSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class ImageSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "chartImageType",
            baseName: "ChartImageType",
            type: "string",
        },
        {
            name: "embededImageNameInSvg",
            baseName: "EmbededImageNameInSvg",
            type: "string",
        },
        {
            name: "horizontalResolution",
            baseName: "HorizontalResolution",
            type: "number",
        },
        {
            name: "imageFormat",
            baseName: "ImageFormat",
            type: "string",
        },
        {
            name: "isCellAutoFit",
            baseName: "IsCellAutoFit",
            type: "boolean",
        },
        {
            name: "onePagePerSheet",
            baseName: "OnePagePerSheet",
            type: "boolean",
        },
        {
            name: "onlyArea",
            baseName: "OnlyArea",
            type: "boolean",
        },
        {
            name: "printingPage",
            baseName: "PrintingPage",
            type: "string",
        },
        {
            name: "printWithStatusDialog",
            baseName: "PrintWithStatusDialog",
            type: "boolean",
        },
        {
            name: "quality",
            baseName: "Quality",
            type: "number",
        },
        {
            name: "tiffCompression",
            baseName: "TiffCompression",
            type: "string",
        },
        {
            name: "verticalResolution",
            baseName: "VerticalResolution",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImageSaveOptions.attributeTypeMap) ;

    }

    public chartImageType: string;
    public embededImageNameInSvg: string;
    public horizontalResolution: number;
    public imageFormat: string;
    public isCellAutoFit: boolean;
    public onePagePerSheet: boolean;
    public onlyArea: boolean;
    public printingPage: string;
    public printWithStatusDialog: boolean;
    public quality: number;
    public tiffCompression: string;
    public verticalResolution: number;

    public constructor(init?: Partial< ImageSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class JsonSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "exportArea",
            baseName: "ExportArea",
            type: "CellArea",
        },
        {
            name: "hasHeaderRow",
            baseName: "HasHeaderRow",
            type: "boolean",
        },
        {
            name: "exportAsString",
            baseName: "ExportAsString",
            type: "boolean",
        },
        {
            name: "indent",
            baseName: "Indent",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(JsonSaveOptions.attributeTypeMap) ;

    }

    public exportArea: CellArea;
    public hasHeaderRow: boolean;
    public exportAsString: boolean;
    public indent: string;

    public constructor(init?: Partial< JsonSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class MarkdownSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "encoding",
            baseName: "Encoding",
            type: "string",
        },
        {
            name: "formatStrategy",
            baseName: "FormatStrategy",
            type: "string",
        },
        {
            name: "lineSeparator",
            baseName: "LineSeparator",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(MarkdownSaveOptions.attributeTypeMap) ;

    }

    public encoding: string;
    public formatStrategy: string;
    public lineSeparator: string;

    public constructor(init?: Partial< MarkdownSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class MHtmlSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "exportPageHeaders",
            baseName: "ExportPageHeaders",
            type: "boolean",
        },
        {
            name: "exportPageFooters",
            baseName: "ExportPageFooters",
            type: "boolean",
        },
        {
            name: "exportRowColumnHeadings",
            baseName: "ExportRowColumnHeadings",
            type: "boolean",
        },
        {
            name: "showAllSheets",
            baseName: "ShowAllSheets",
            type: "boolean",
        },
        {
            name: "imageOptions",
            baseName: "ImageOptions",
            type: "ImageOrPrintOptions",
        },
        {
            name: "saveAsSingleFile",
            baseName: "SaveAsSingleFile",
            type: "boolean",
        },
        {
            name: "exportHiddenWorksheet",
            baseName: "ExportHiddenWorksheet",
            type: "boolean",
        },
        {
            name: "exportGridLines",
            baseName: "ExportGridLines",
            type: "boolean",
        },
        {
            name: "presentationPreference",
            baseName: "PresentationPreference",
            type: "boolean",
        },
        {
            name: "cellCssPrefix",
            baseName: "CellCssPrefix",
            type: "string",
        },
        {
            name: "tableCssId",
            baseName: "TableCssId",
            type: "string",
        },
        {
            name: "isFullPathLink",
            baseName: "IsFullPathLink",
            type: "boolean",
        },
        {
            name: "exportWorksheetCSSSeparately",
            baseName: "ExportWorksheetCSSSeparately",
            type: "boolean",
        },
        {
            name: "exportSimilarBorderStyle",
            baseName: "ExportSimilarBorderStyle",
            type: "boolean",
        },
        {
            name: "mergeEmptyTdForcely",
            baseName: "MergeEmptyTdForcely",
            type: "boolean",
        },
        {
            name: "exportCellCoordinate",
            baseName: "ExportCellCoordinate",
            type: "boolean",
        },
        {
            name: "exportExtraHeadings",
            baseName: "ExportExtraHeadings",
            type: "boolean",
        },
        {
            name: "exportHeadings",
            baseName: "ExportHeadings",
            type: "boolean",
        },
        {
            name: "exportFormula",
            baseName: "ExportFormula",
            type: "boolean",
        },
        {
            name: "addTooltipText",
            baseName: "AddTooltipText",
            type: "boolean",
        },
        {
            name: "exportBogusRowData",
            baseName: "ExportBogusRowData",
            type: "boolean",
        },
        {
            name: "excludeUnusedStyles",
            baseName: "ExcludeUnusedStyles",
            type: "boolean",
        },
        {
            name: "exportDocumentProperties",
            baseName: "ExportDocumentProperties",
            type: "boolean",
        },
        {
            name: "exportWorksheetProperties",
            baseName: "ExportWorksheetProperties",
            type: "boolean",
        },
        {
            name: "exportWorkbookProperties",
            baseName: "ExportWorkbookProperties",
            type: "boolean",
        },
        {
            name: "exportFrameScriptsAndProperties",
            baseName: "ExportFrameScriptsAndProperties",
            type: "boolean",
        },
        {
            name: "attachedFilesDirectory",
            baseName: "AttachedFilesDirectory",
            type: "string",
        },
        {
            name: "attachedFilesUrlPrefix",
            baseName: "AttachedFilesUrlPrefix",
            type: "string",
        },
        {
            name: "encoding",
            baseName: "Encoding",
            type: "string",
        },
        {
            name: "exportActiveWorksheetOnly",
            baseName: "ExportActiveWorksheetOnly",
            type: "boolean",
        },
        {
            name: "exportChartImageFormat",
            baseName: "ExportChartImageFormat",
            type: "string",
        },
        {
            name: "exportImagesAsBase64",
            baseName: "ExportImagesAsBase64",
            type: "boolean",
        },
        {
            name: "hiddenColDisplayType",
            baseName: "HiddenColDisplayType",
            type: "string",
        },
        {
            name: "hiddenRowDisplayType",
            baseName: "HiddenRowDisplayType",
            type: "string",
        },
        {
            name: "htmlCrossStringType",
            baseName: "HtmlCrossStringType",
            type: "string",
        },
        {
            name: "isExpImageToTempDir",
            baseName: "IsExpImageToTempDir",
            type: "boolean",
        },
        {
            name: "pageTitle",
            baseName: "PageTitle",
            type: "string",
        },
        {
            name: "parseHtmlTagInCell",
            baseName: "ParseHtmlTagInCell",
            type: "boolean",
        },
        {
            name: "cellNameAttribute",
            baseName: "CellNameAttribute",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(MHtmlSaveOptions.attributeTypeMap) ;

    }

    public exportPageHeaders: boolean;
    public exportPageFooters: boolean;
    public exportRowColumnHeadings: boolean;
    public showAllSheets: boolean;
    public imageOptions: ImageOrPrintOptions;
    public saveAsSingleFile: boolean;
    public exportHiddenWorksheet: boolean;
    public exportGridLines: boolean;
    public presentationPreference: boolean;
    public cellCssPrefix: string;
    public tableCssId: string;
    public isFullPathLink: boolean;
    public exportWorksheetCSSSeparately: boolean;
    public exportSimilarBorderStyle: boolean;
    public mergeEmptyTdForcely: boolean;
    public exportCellCoordinate: boolean;
    public exportExtraHeadings: boolean;
    public exportHeadings: boolean;
    public exportFormula: boolean;
    public addTooltipText: boolean;
    public exportBogusRowData: boolean;
    public excludeUnusedStyles: boolean;
    public exportDocumentProperties: boolean;
    public exportWorksheetProperties: boolean;
    public exportWorkbookProperties: boolean;
    public exportFrameScriptsAndProperties: boolean;
    public attachedFilesDirectory: string;
    public attachedFilesUrlPrefix: string;
    public encoding: string;
    public exportActiveWorksheetOnly: boolean;
    public exportChartImageFormat: string;
    public exportImagesAsBase64: boolean;
    public hiddenColDisplayType: string;
    public hiddenRowDisplayType: string;
    public htmlCrossStringType: string;
    public isExpImageToTempDir: boolean;
    public pageTitle: string;
    public parseHtmlTagInCell: boolean;
    public cellNameAttribute: string;

    public constructor(init?: Partial< MHtmlSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class OdsSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "generatorType",
            baseName: "GeneratorType",
            type: "string",
        },
        {
            name: "odfStrictVersion",
            baseName: "OdfStrictVersion",
            type: "string",
        },
        {
            name: "ignorePivotTables",
            baseName: "IgnorePivotTables",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(OdsSaveOptions.attributeTypeMap) ;

    }

    public generatorType: string;
    public odfStrictVersion: string;
    public ignorePivotTables: boolean;

    public constructor(init?: Partial< OdsSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class OoxmlSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "exportCellName",
            baseName: "ExportCellName",
            type: "boolean",
        },
        {
            name: "updateZoom",
            baseName: "UpdateZoom",
            type: "boolean",
        },
        {
            name: "enableZip64",
            baseName: "EnableZip64",
            type: "boolean",
        },
        {
            name: "embedOoxmlAsOleObject",
            baseName: "EmbedOoxmlAsOleObject",
            type: "boolean",
        },
        {
            name: "compressionType",
            baseName: "CompressionType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(OoxmlSaveOptions.attributeTypeMap) ;

    }

    public exportCellName: boolean;
    public updateZoom: boolean;
    public enableZip64: boolean;
    public embedOoxmlAsOleObject: boolean;
    public compressionType: string;

    public constructor(init?: Partial< OoxmlSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class PclSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "fontFullName",
            baseName: "fontFullName",
            type: "string",
        },
        {
            name: "fontPclName",
            baseName: "fontPclName",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PclSaveOptions.attributeTypeMap) ;

    }

    public fontFullName: string;
    public fontPclName: string;

    public constructor(init?: Partial< PclSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class RenderingWatermark  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "rotation",
            baseName: "Rotation",
            type: "number",
        },
        {
            name: "scaleToPagePercent",
            baseName: "ScaleToPagePercent",
            type: "number",
        },
        {
            name: "opacity",
            baseName: "Opacity",
            type: "number",
        },
        {
            name: "isBackground",
            baseName: "IsBackground",
            type: "boolean",
        },
        {
            name: "text",
            baseName: "Text",
            type: "string",
        },
        {
            name: "font",
            baseName: "Font",
            type: "RenderingFont",
        },
        {
            name: "image",
            baseName: "Image",
            type: "Array<number>",
        },
        {
            name: "hAlignment",
            baseName: "HAlignment",
            type: "string",
        },
        {
            name: "vAlignment",
            baseName: "VAlignment",
            type: "string",
        },
        {
            name: "offsetX",
            baseName: "OffsetX",
            type: "number",
        },
        {
            name: "offsetY",
            baseName: "OffsetY",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  RenderingWatermark.attributeTypeMap;

    }

    public rotation: number;
    public scaleToPagePercent: number;
    public opacity: number;
    public isBackground: boolean;
    public text: string;
    public font: RenderingFont;
    public image: Array<number>;
    public hAlignment: string;
    public vAlignment: string;
    public offsetX: number;
    public offsetY: number;

    public constructor(init?: Partial< RenderingWatermark >) {  
    
        Object.assign(this, init);
    } 
}
   
export class PdfSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "displayDocTitle",
            baseName: "DisplayDocTitle",
            type: "boolean",
        },
        {
            name: "exportDocumentStructure",
            baseName: "ExportDocumentStructure",
            type: "boolean",
        },
        {
            name: "emfRenderSetting",
            baseName: "EmfRenderSetting",
            type: "string",
        },
        {
            name: "customPropertiesExport",
            baseName: "CustomPropertiesExport",
            type: "string",
        },
        {
            name: "optimizationType",
            baseName: "OptimizationType",
            type: "string",
        },
        {
            name: "producer",
            baseName: "Producer",
            type: "string",
        },
        {
            name: "pdfCompression",
            baseName: "PdfCompression",
            type: "string",
        },
        {
            name: "fontEncoding",
            baseName: "FontEncoding",
            type: "string",
        },
        {
            name: "watermark",
            baseName: "Watermark",
            type: "RenderingWatermark",
        },
        {
            name: "calculateFormula",
            baseName: "CalculateFormula",
            type: "boolean",
        },
        {
            name: "checkFontCompatibility",
            baseName: "CheckFontCompatibility",
            type: "boolean",
        },
        {
            name: "compliance",
            baseName: "Compliance",
            type: "string",
        },
        {
            name: "defaultFont",
            baseName: "DefaultFont",
            type: "string",
        },
        {
            name: "onePagePerSheet",
            baseName: "OnePagePerSheet",
            type: "boolean",
        },
        {
            name: "printingPageType",
            baseName: "PrintingPageType",
            type: "string",
        },
        {
            name: "securityOptions",
            baseName: "SecurityOptions",
            type: "PdfSecurityOptions",
        },
        {
            name: "desiredPPI",
            baseName: "desiredPPI",
            type: "number",
        },
        {
            name: "jpegQuality",
            baseName: "jpegQuality",
            type: "number",
        },
        {
            name: "imageType",
            baseName: "ImageType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PdfSaveOptions.attributeTypeMap) ;

    }

    public displayDocTitle: boolean;
    public exportDocumentStructure: boolean;
    public emfRenderSetting: string;
    public customPropertiesExport: string;
    public optimizationType: string;
    public producer: string;
    public pdfCompression: string;
    public fontEncoding: string;
    public watermark: RenderingWatermark;
    public calculateFormula: boolean;
    public checkFontCompatibility: boolean;
    public compliance: string;
    public defaultFont: string;
    public onePagePerSheet: boolean;
    public printingPageType: string;
    public securityOptions: PdfSecurityOptions;
    public desiredPPI: number;
    public jpegQuality: number;
    public imageType: string;

    public constructor(init?: Partial< PdfSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class PptxSaveOptions  extends PaginatedSaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "ignoreHiddenRows",
            baseName: "IgnoreHiddenRows",
            type: "boolean",
        },
        {
            name: "adjustFontSizeForRowType",
            baseName: "AdjustFontSizeForRowType",
            type: "string",
        },
        {
            name: "exportViewType",
            baseName: "ExportViewType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PptxSaveOptions.attributeTypeMap) ;

    }

    public ignoreHiddenRows: boolean;
    public adjustFontSizeForRowType: string;
    public exportViewType: string;

    public constructor(init?: Partial< PptxSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class SaveOptionsData  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "saveOptions",
            baseName: "SaveOptions",
            type: "SaveOptions",
        },
        {
            name: "filename",
            baseName: "Filename",
            type: "string",
        },
        {
            name: "storageName",
            baseName: "StorageName",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  SaveOptionsData.attributeTypeMap;

    }

    public saveOptions: SaveOptions;
    public filename: string;
    public storageName: string;

    public constructor(init?: Partial< SaveOptionsData >) {  
    
        Object.assign(this, init);
    } 
}
   
export class SpreadsheetML2003SaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "exportColumnIndexOfCell",
            baseName: "ExportColumnIndexOfCell",
            type: "boolean",
        },
        {
            name: "isIndentedFormatting",
            baseName: "IsIndentedFormatting",
            type: "boolean",
        },
        {
            name: "limitAsXls",
            baseName: "LimitAsXls",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SpreadsheetML2003SaveOptions.attributeTypeMap) ;

    }

    public exportColumnIndexOfCell: boolean;
    public isIndentedFormatting: boolean;
    public limitAsXls: boolean;

    public constructor(init?: Partial< SpreadsheetML2003SaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class SqlScriptSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "checkIfTableExists",
            baseName: "CheckIfTableExists",
            type: "boolean",
        },
        {
            name: "columnTypeMap",
            baseName: "ColumnTypeMap",
            type: "string",
        },
        {
            name: "checkAllDataForColumnType",
            baseName: "CheckAllDataForColumnType",
            type: "boolean",
        },
        {
            name: "addBlankLineBetweenRows",
            baseName: "AddBlankLineBetweenRows",
            type: "boolean",
        },
        {
            name: "separator",
            baseName: "Separator",
            type: "string",
        },
        {
            name: "operatorType",
            baseName: "OperatorType",
            type: "string",
        },
        {
            name: "primaryKey",
            baseName: "PrimaryKey",
            type: "number",
        },
        {
            name: "createTable",
            baseName: "CreateTable",
            type: "boolean",
        },
        {
            name: "idName",
            baseName: "IdName",
            type: "string",
        },
        {
            name: "startId",
            baseName: "StartId",
            type: "number",
        },
        {
            name: "tableName",
            baseName: "TableName",
            type: "string",
        },
        {
            name: "exportAsString",
            baseName: "ExportAsString",
            type: "boolean",
        },
        {
            name: "exportArea",
            baseName: "ExportArea",
            type: "CellArea",
        },
        {
            name: "hasHeaderRow",
            baseName: "HasHeaderRow",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SqlScriptSaveOptions.attributeTypeMap) ;

    }

    public checkIfTableExists: boolean;
    public columnTypeMap: string;
    public checkAllDataForColumnType: boolean;
    public addBlankLineBetweenRows: boolean;
    public separator: string;
    public operatorType: string;
    public primaryKey: number;
    public createTable: boolean;
    public idName: string;
    public startId: number;
    public tableName: string;
    public exportAsString: boolean;
    public exportArea: CellArea;
    public hasHeaderRow: boolean;

    public constructor(init?: Partial< SqlScriptSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class SvgSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sheetIndex",
            baseName: "SheetIndex",
            type: "number",
        },
        {
            name: "chartImageType",
            baseName: "ChartImageType",
            type: "string",
        },
        {
            name: "embededImageNameInSvg",
            baseName: "EmbededImageNameInSvg",
            type: "string",
        },
        {
            name: "horizontalResolution",
            baseName: "HorizontalResolution",
            type: "number",
        },
        {
            name: "imageFormat",
            baseName: "ImageFormat",
            type: "string",
        },
        {
            name: "isCellAutoFit",
            baseName: "IsCellAutoFit",
            type: "boolean",
        },
        {
            name: "onePagePerSheet",
            baseName: "OnePagePerSheet",
            type: "boolean",
        },
        {
            name: "onlyArea",
            baseName: "OnlyArea",
            type: "boolean",
        },
        {
            name: "printingPage",
            baseName: "PrintingPage",
            type: "string",
        },
        {
            name: "printWithStatusDialog",
            baseName: "PrintWithStatusDialog",
            type: "boolean",
        },
        {
            name: "quality",
            baseName: "Quality",
            type: "number",
        },
        {
            name: "tiffCompression",
            baseName: "TiffCompression",
            type: "string",
        },
        {
            name: "verticalResolution",
            baseName: "VerticalResolution",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SvgSaveOptions.attributeTypeMap) ;

    }

    public sheetIndex: number;
    public chartImageType: string;
    public embededImageNameInSvg: string;
    public horizontalResolution: number;
    public imageFormat: string;
    public isCellAutoFit: boolean;
    public onePagePerSheet: boolean;
    public onlyArea: boolean;
    public printingPage: string;
    public printWithStatusDialog: boolean;
    public quality: number;
    public tiffCompression: string;
    public verticalResolution: number;

    public constructor(init?: Partial< SvgSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class TxtSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "quoteType",
            baseName: "QuoteType",
            type: "string",
        },
        {
            name: "separator",
            baseName: "Separator",
            type: "string",
        },
        {
            name: "separatorString",
            baseName: "SeparatorString",
            type: "string",
        },
        {
            name: "alwaysQuoted",
            baseName: "AlwaysQuoted",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TxtSaveOptions.attributeTypeMap) ;

    }

    public quoteType: string;
    public separator: string;
    public separatorString: string;
    public alwaysQuoted: boolean;

    public constructor(init?: Partial< TxtSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class XlsbSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "exportAllColumnIndexes",
            baseName: "ExportAllColumnIndexes",
            type: "boolean",
        },
        {
            name: "compressionType",
            baseName: "CompressionType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(XlsbSaveOptions.attributeTypeMap) ;

    }

    public exportAllColumnIndexes: boolean;
    public compressionType: string;

    public constructor(init?: Partial< XlsbSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class XlsSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "matchColor",
            baseName: "MatchColor",
            type: "boolean",
        },
        {
            name: "wpsCompatibility",
            baseName: "WpsCompatibility",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(XlsSaveOptions.attributeTypeMap) ;

    }

    public matchColor: boolean;
    public wpsCompatibility: boolean;

    public constructor(init?: Partial< XlsSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class XmlSaveOptions  extends SaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sheetIndexes",
            baseName: "SheetIndexes",
            type: "Array<number>",
        },
        {
            name: "exportArea",
            baseName: "ExportArea",
            type: "CellArea",
        },
        {
            name: "hasHeaderRow",
            baseName: "HasHeaderRow",
            type: "boolean",
        },
        {
            name: "xmlMapName",
            baseName: "XmlMapName",
            type: "string",
        },
        {
            name: "sheetNameAsElementName",
            baseName: "SheetNameAsElementName",
            type: "boolean",
        },
        {
            name: "dataAsAttribute",
            baseName: "DataAsAttribute",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(XmlSaveOptions.attributeTypeMap) ;

    }

    public sheetIndexes: Array<number>;
    public exportArea: CellArea;
    public hasHeaderRow: boolean;
    public xmlMapName: string;
    public sheetNameAsElementName: boolean;
    public dataAsAttribute: boolean;

    public constructor(init?: Partial< XmlSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class XpsSaveOptions  extends PaginatedSaveOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(XpsSaveOptions.attributeTypeMap) ;

    }


    public constructor(init?: Partial< XpsSaveOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "code",
            baseName: "Code",
            type: "number",
        },
        {
            name: "status",
            baseName: "Status",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CellsCloudResponse.attributeTypeMap;

    }

    public code: number;
    public status: string;

    public constructor(init?: Partial< CellsCloudResponse >) {  
    
        Object.assign(this, init);
    } 
}
   
export class BrokenLinksReponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "brokenLinks",
            baseName: "BrokenLinks",
            type: "Array<BrokenLink>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(BrokenLinksReponse.attributeTypeMap) ;

    }

    public brokenLinks: Array<BrokenLink>;

    public constructor(init?: Partial< BrokenLinksReponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class CellsCloudFileInfoResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "fileInfo",
            baseName: "FileInfo",
            type: "CellsCloudFileInfo",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CellsCloudFileInfoResponse.attributeTypeMap) ;

    }

    public fileInfo: CellsCloudFileInfo;

    public constructor(init?: Partial< CellsCloudFileInfoResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class CellsCloudPublicKeyResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "cellsCloudPublicKey",
            baseName: "CellsCloudPublicKey",
            type: "CellsCloudPublicKey",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CellsCloudPublicKeyResponse.attributeTypeMap) ;

    }

    public cellsCloudPublicKey: CellsCloudPublicKey;

    public constructor(init?: Partial< CellsCloudPublicKeyResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class SaveResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "saveResult",
            baseName: "SaveResult",
            type: "SaveResult",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SaveResponse.attributeTypeMap) ;

    }

    public saveResult: SaveResult;

    public constructor(init?: Partial< SaveResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class SearchResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "textItems",
            baseName: "TextItems",
            type: "Array<TextItem>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SearchResponse.attributeTypeMap) ;

    }

    public textItems: Array<TextItem>;

    public constructor(init?: Partial< SearchResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class RenderingFont  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "size",
            baseName: "Size",
            type: "number",
        },
        {
            name: "bold",
            baseName: "Bold",
            type: "boolean",
        },
        {
            name: "italic",
            baseName: "Italic",
            type: "boolean",
        },
        {
            name: "color",
            baseName: "Color",
            type: "Color",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  RenderingFont.attributeTypeMap;

    }

    public name: string;
    public size: number;
    public bold: boolean;
    public italic: boolean;
    public color: Color;

    public constructor(init?: Partial< RenderingFont >) {  
    
        Object.assign(this, init);
    } 
}
/// The error details   
export class ErrorDetails  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ErrorDetails.attributeTypeMap;

    }


    public constructor(init?: Partial< ErrorDetails >) {  
    
        Object.assign(this, init);
    } 
}
/// Describe the AboveAverage conditional formatting rule. This conditional formatting
///     rule highlights cells that are above or below the average for all values
///     in the range.   
export class AboveAverage  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "isAboveAverage",
            baseName: "IsAboveAverage",
            type: "boolean",
        },
        {
            name: "isEqualAverage",
            baseName: "IsEqualAverage",
            type: "boolean",
        },
        {
            name: "stdDev",
            baseName: "StdDev",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  AboveAverage.attributeTypeMap;

    }

    public isAboveAverage: boolean;
    public isEqualAverage: boolean;
    public stdDev: number;

    public constructor(init?: Partial< AboveAverage >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents user's custom calculation engine to extend the default calculation engine of Aspose.Cells.
///     
export class AbstractCalculationEngine  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "isParamLiteralRequired",
            baseName: "IsParamLiteralRequired",
            type: "boolean",
        },
        {
            name: "isParamArrayModeRequired",
            baseName: "IsParamArrayModeRequired",
            type: "boolean",
        },
        {
            name: "processBuiltInFunctions",
            baseName: "ProcessBuiltInFunctions",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  AbstractCalculationEngine.attributeTypeMap;

    }

    public isParamLiteralRequired: boolean;
    public isParamArrayModeRequired: boolean;
    public processBuiltInFunctions: boolean;

    public constructor(init?: Partial< AbstractCalculationEngine >) {  
    
        Object.assign(this, init);
    } 
}
/// Monitor for user to track the progress of formula calculation.
///     
export class AbstractCalculationMonitor  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "originalValue",
            baseName: "OriginalValue",
            type: "Object",
        },
        {
            name: "valueChanged",
            baseName: "ValueChanged",
            type: "boolean",
        },
        {
            name: "calculatedValue",
            baseName: "CalculatedValue",
            type: "Object",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  AbstractCalculationMonitor.attributeTypeMap;

    }

    public originalValue: Object;
    public valueChanged: boolean;
    public calculatedValue: Object;

    public constructor(init?: Partial< AbstractCalculationMonitor >) {  
    
        Object.assign(this, init);
    } 
}
/// Class summary: The features include automatic emergency braking, lane keeping assist, adaptive cruise control, blind spot monitoring, and rear cross-traffic alert.   
export class LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "link",
            baseName: "link",
            type: "Link",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  LinkElement.attributeTypeMap;

    }

    public link: Link;

    public constructor(init?: Partial< LinkElement >) {  
    
        Object.assign(this, init);
    } 
}
/// Summary description for DataSorter.   
export class DataSorter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "caseSensitive",
            baseName: "CaseSensitive",
            type: "boolean",
        },
        {
            name: "hasHeaders",
            baseName: "HasHeaders",
            type: "boolean",
        },
        {
            name: "keyList",
            baseName: "KeyList",
            type: "Array<SortKey>",
        },
        {
            name: "sortLeftToRight",
            baseName: "SortLeftToRight",
            type: "boolean",
        },
        {
            name: "sortAsNumber",
            baseName: "SortAsNumber",
            type: "boolean",
        },
        {
            name: "keys",
            baseName: "Keys",
            type: "Array<DataSorterKey>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DataSorter.attributeTypeMap;

    }

    public caseSensitive: boolean;
    public hasHeaders: boolean;
    public keyList: Array<SortKey>;
    public sortLeftToRight: boolean;
    public sortAsNumber: boolean;
    public keys: Array<DataSorterKey>;

    public constructor(init?: Partial< DataSorter >) {  
    
        Object.assign(this, init);
    } 
}
///            Represents a filter for a single column. The Filter object is a member of the Filters collection
///               
export class FilterColumn  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "fieldIndex",
            baseName: "FieldIndex",
            type: "number",
        },
        {
            name: "filterType",
            baseName: "FilterType",
            type: "string",
        },
        {
            name: "multipleFilters",
            baseName: "MultipleFilters",
            type: "MultipleFilters",
        },
        {
            name: "colorFilter",
            baseName: "ColorFilter",
            type: "ColorFilter",
        },
        {
            name: "customFilters",
            baseName: "CustomFilters",
            type: "Array<CustomFilter>",
        },
        {
            name: "dynamicFilter",
            baseName: "DynamicFilter",
            type: "DynamicFilter",
        },
        {
            name: "iconFilter",
            baseName: "IconFilter",
            type: "IconFilter",
        },
        {
            name: "top10Filter",
            baseName: "Top10Filter",
            type: "Top10Filter",
        },
        {
            name: "visibledropdown",
            baseName: "Visibledropdown",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  FilterColumn.attributeTypeMap;

    }

    public fieldIndex: number;
    public filterType: string;
    public multipleFilters: MultipleFilters;
    public colorFilter: ColorFilter;
    public customFilters: Array<CustomFilter>;
    public dynamicFilter: DynamicFilter;
    public iconFilter: IconFilter;
    public top10Filter: Top10Filter;
    public visibledropdown: string;

    public constructor(init?: Partial< FilterColumn >) {  
    
        Object.assign(this, init);
    } 
}
/// I'm glad to help! Please provide me with the features you would like me to summarize.   
export class Link  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "href",
            baseName: "Href",
            type: "string",
        },
        {
            name: "rel",
            baseName: "Rel",
            type: "string",
        },
        {
            name: "title",
            baseName: "Title",
            type: "string",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Link.attributeTypeMap;

    }

    public href: string;
    public rel: string;
    public title: string;
    public type: string;

    public constructor(init?: Partial< Link >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents autofiltering for the specified worksheet.   
export class AutoFilter  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "filterColumns",
            baseName: "FilterColumns",
            type: "Array<FilterColumn>",
        },
        {
            name: "range",
            baseName: "Range",
            type: "string",
        },
        {
            name: "sorter",
            baseName: "Sorter",
            type: "DataSorter",
        },
        {
            name: "showFilterButton",
            baseName: "ShowFilterButton",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(AutoFilter.attributeTypeMap) ;

    }

    public filterColumns: Array<FilterColumn>;
    public range: string;
    public sorter: DataSorter;
    public showFilterButton: boolean;

    public constructor(init?: Partial< AutoFilter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents all auto fitter options.   
export class AutoFitterOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoFitMergedCellsType",
            baseName: "AutoFitMergedCellsType",
            type: "string",
        },
        {
            name: "ignoreHidden",
            baseName: "IgnoreHidden",
            type: "boolean",
        },
        {
            name: "onlyAuto",
            baseName: "OnlyAuto",
            type: "boolean",
        },
        {
            name: "defaultEditLanguage",
            baseName: "DefaultEditLanguage",
            type: "string",
        },
        {
            name: "maxRowHeight",
            baseName: "MaxRowHeight",
            type: "number",
        },
        {
            name: "autoFitWrappedTextType",
            baseName: "AutoFitWrappedTextType",
            type: "string",
        },
        {
            name: "formatStrategy",
            baseName: "FormatStrategy",
            type: "string",
        },
        {
            name: "forRendering",
            baseName: "ForRendering",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  AutoFitterOptions.attributeTypeMap;

    }

    public autoFitMergedCellsType: string;
    public ignoreHidden: boolean;
    public onlyAuto: boolean;
    public defaultEditLanguage: string;
    public maxRowHeight: number;
    public autoFitWrappedTextType: string;
    public formatStrategy: string;
    public forRendering: boolean;

    public constructor(init?: Partial< AutoFitterOptions >) {  
    
        Object.assign(this, init);
    } 
}
///            Represents a theme color.
///               
export class ThemeColor  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "colorType",
            baseName: "ColorType",
            type: "string",
        },
        {
            name: "tint",
            baseName: "Tint",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ThemeColor.attributeTypeMap;

    }

    public colorType: string;
    public tint: number;

    public constructor(init?: Partial< ThemeColor >) {  
    
        Object.assign(this, init);
    } 
}
///            Encapsulates the object that represents the cell border.
///               
export class Border  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "lineStyle",
            baseName: "LineStyle",
            type: "string",
        },
        {
            name: "color",
            baseName: "Color",
            type: "Color",
        },
        {
            name: "borderType",
            baseName: "BorderType",
            type: "string",
        },
        {
            name: "themeColor",
            baseName: "ThemeColor",
            type: "ThemeColor",
        },
        {
            name: "argbColor",
            baseName: "ArgbColor",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Border.attributeTypeMap;

    }

    public lineStyle: string;
    public color: Color;
    public borderType: string;
    public themeColor: ThemeColor;
    public argbColor: number;

    public constructor(init?: Partial< Border >) {  
    
        Object.assign(this, init);
    } 
}
///            Represents a root object to create an Excel spreadsheet.
///               
export class Workbook  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "fileName",
            baseName: "FileName",
            type: "string",
        },
        {
            name: "links",
            baseName: "Links",
            type: "Array<Link>",
        },
        {
            name: "worksheets",
            baseName: "Worksheets",
            type: "LinkElement",
        },
        {
            name: "defaultStyle",
            baseName: "DefaultStyle",
            type: "LinkElement",
        },
        {
            name: "documentProperties",
            baseName: "DocumentProperties",
            type: "LinkElement",
        },
        {
            name: "names",
            baseName: "Names",
            type: "LinkElement",
        },
        {
            name: "settings",
            baseName: "Settings",
            type: "LinkElement",
        },
        {
            name: "isWriteProtected",
            baseName: "IsWriteProtected",
            type: "string",
        },
        {
            name: "isProtected",
            baseName: "IsProtected",
            type: "string",
        },
        {
            name: "isEncryption",
            baseName: "IsEncryption",
            type: "string",
        },
        {
            name: "password",
            baseName: "Password",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Workbook.attributeTypeMap;

    }

    public fileName: string;
    public links: Array<Link>;
    public worksheets: LinkElement;
    public defaultStyle: LinkElement;
    public documentProperties: LinkElement;
    public names: LinkElement;
    public settings: LinkElement;
    public isWriteProtected: string;
    public isProtected: string;
    public isEncryption: string;
    public password: string;

    public constructor(init?: Partial< Workbook >) {  
    
        Object.assign(this, init);
    } 
}
///            Represents options for calculation.
///               
export class CalculationOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "calcStackSize",
            baseName: "CalcStackSize",
            type: "number",
        },
        {
            name: "ignoreError",
            baseName: "IgnoreError",
            type: "boolean",
        },
        {
            name: "precisionStrategy",
            baseName: "PrecisionStrategy",
            type: "string",
        },
        {
            name: "recursive",
            baseName: "Recursive",
            type: "boolean",
        },
        {
            name: "customEngine",
            baseName: "CustomEngine",
            type: "AbstractCalculationEngine",
        },
        {
            name: "calculationMonitor",
            baseName: "CalculationMonitor",
            type: "AbstractCalculationMonitor",
        },
        {
            name: "linkedDataSources",
            baseName: "LinkedDataSources",
            type: "Array<Workbook>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CalculationOptions.attributeTypeMap;

    }

    public calcStackSize: number;
    public ignoreError: boolean;
    public precisionStrategy: string;
    public recursive: boolean;
    public customEngine: AbstractCalculationEngine;
    public calculationMonitor: AbstractCalculationMonitor;
    public linkedDataSources: Array<Workbook>;

    public constructor(init?: Partial< CalculationOptions >) {  
    
        Object.assign(this, init);
    } 
}
/// Encapsulates the object that represents a single Workbook cell.   
export class Cell  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "row",
            baseName: "Row",
            type: "number",
        },
        {
            name: "column",
            baseName: "Column",
            type: "number",
        },
        {
            name: "value",
            baseName: "Value",
            type: "string",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "formula",
            baseName: "Formula",
            type: "string",
        },
        {
            name: "isFormula",
            baseName: "IsFormula",
            type: "boolean",
        },
        {
            name: "isMerged",
            baseName: "IsMerged",
            type: "boolean",
        },
        {
            name: "isArrayHeader",
            baseName: "IsArrayHeader",
            type: "boolean",
        },
        {
            name: "isInArray",
            baseName: "IsInArray",
            type: "boolean",
        },
        {
            name: "isErrorValue",
            baseName: "IsErrorValue",
            type: "boolean",
        },
        {
            name: "isInTable",
            baseName: "IsInTable",
            type: "boolean",
        },
        {
            name: "isStyleSet",
            baseName: "IsStyleSet",
            type: "boolean",
        },
        {
            name: "htmlString",
            baseName: "HtmlString",
            type: "string",
        },
        {
            name: "style",
            baseName: "Style",
            type: "LinkElement",
        },
        {
            name: "worksheet",
            baseName: "Worksheet",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Cell.attributeTypeMap) ;

    }

    public name: string;
    public row: number;
    public column: number;
    public value: string;
    public type: string;
    public formula: string;
    public isFormula: boolean;
    public isMerged: boolean;
    public isArrayHeader: boolean;
    public isInArray: boolean;
    public isErrorValue: boolean;
    public isInTable: boolean;
    public isStyleSet: boolean;
    public htmlString: string;
    public style: LinkElement;
    public worksheet: string;

    public constructor(init?: Partial< Cell >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates a collection of cell relevant objects, such as Aspose.Cells.Cell, Aspose.Cells.Row, ...etc.   
export class Cells  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "maxRow",
            baseName: "MaxRow",
            type: "number",
        },
        {
            name: "maxColumn",
            baseName: "MaxColumn",
            type: "number",
        },
        {
            name: "cellCount",
            baseName: "CellCount",
            type: "number",
        },
        {
            name: "rows",
            baseName: "Rows",
            type: "LinkElement",
        },
        {
            name: "columns",
            baseName: "Columns",
            type: "LinkElement",
        },
        {
            name: "cellList",
            baseName: "CellList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Cells.attributeTypeMap) ;

    }

    public maxRow: number;
    public maxColumn: number;
    public cellCount: number;
    public rows: LinkElement;
    public columns: LinkElement;
    public cellList: Array<LinkElement>;

    public constructor(init?: Partial< Cells >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///            Represents all types of color.
///               
export class CellsColor  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "color",
            baseName: "Color",
            type: "Color",
        },
        {
            name: "colorIndex",
            baseName: "ColorIndex",
            type: "number",
        },
        {
            name: "isShapeColor",
            baseName: "IsShapeColor",
            type: "boolean",
        },
        {
            name: "tint",
            baseName: "tint",
            type: "number",
        },
        {
            name: "argb",
            baseName: "Argb",
            type: "number",
        },
        {
            name: "themeColor",
            baseName: "ThemeColor",
            type: "ThemeColor",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "transparency",
            baseName: "Transparency",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CellsColor.attributeTypeMap;

    }

    public color: Color;
    public colorIndex: number;
    public isShapeColor: boolean;
    public tint: number;
    public argb: number;
    public themeColor: ThemeColor;
    public type: string;
    public transparency: number;

    public constructor(init?: Partial< CellsColor >) {  
    
        Object.assign(this, init);
    } 
}
/// Cells document property.   
export class CellsDocumentProperty  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "value",
            baseName: "Value",
            type: "string",
        },
        {
            name: "isLinkedToContent",
            baseName: "IsLinkedToContent",
            type: "string",
        },
        {
            name: "source",
            baseName: "Source",
            type: "string",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "isGeneratedName",
            baseName: "IsGeneratedName",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CellsDocumentProperty.attributeTypeMap;

    }

    public name: string;
    public value: string;
    public isLinkedToContent: string;
    public source: string;
    public type: string;
    public isGeneratedName: string;

    public constructor(init?: Partial< CellsDocumentProperty >) {  
    
        Object.assign(this, init);
    } 
}
/// Excel properties   
export class CellsDocumentProperties  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "documentPropertyList",
            baseName: "DocumentPropertyList",
            type: "Array<CellsDocumentProperty>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CellsDocumentProperties.attributeTypeMap;

    }

    public documentPropertyList: Array<CellsDocumentProperty>;

    public constructor(init?: Partial< CellsDocumentProperties >) {  
    
        Object.assign(this, init);
    } 
}
/// Color filter.   
export class ColorFilter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "filterByFillColor",
            baseName: "FilterByFillColor",
            type: "boolean",
        },
        {
            name: "pattern",
            baseName: "Pattern",
            type: "string",
        },
        {
            name: "color",
            baseName: "Color",
            type: "CellsColor",
        },
        {
            name: "foregroundColorColor",
            baseName: "ForegroundColorColor",
            type: "CellsColor",
        },
        {
            name: "backgroundColor",
            baseName: "BackgroundColor",
            type: "CellsColor",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ColorFilter.attributeTypeMap;

    }

    public filterByFillColor: boolean;
    public pattern: string;
    public color: CellsColor;
    public foregroundColorColor: CellsColor;
    public backgroundColor: CellsColor;

    public constructor(init?: Partial< ColorFilter >) {  
    
        Object.assign(this, init);
    } 
}
///            Describes the values of the interpolation points in a gradient scale, dataBar or iconSet.
///               
export class ConditionalFormattingValue  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "isGTE",
            baseName: "IsGTE",
            type: "boolean",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "value",
            baseName: "Value",
            type: "Object",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ConditionalFormattingValue.attributeTypeMap;

    }

    public isGTE: boolean;
    public type: string;
    public value: Object;

    public constructor(init?: Partial< ConditionalFormattingValue >) {  
    
        Object.assign(this, init);
    } 
}
/// Describe the ColorScale conditional formatting rule. This conditional formatting
///    rule creates a gradated color scale on the cells.
///                
export class ColorScale  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "maxCfvo",
            baseName: "MaxCfvo",
            type: "ConditionalFormattingValue",
        },
        {
            name: "maxColor",
            baseName: "MaxColor",
            type: "Color",
        },
        {
            name: "midCfvo",
            baseName: "MidCfvo",
            type: "ConditionalFormattingValue",
        },
        {
            name: "midColor",
            baseName: "MidColor",
            type: "Color",
        },
        {
            name: "minCfvo",
            baseName: "MinCfvo",
            type: "ConditionalFormattingValue",
        },
        {
            name: "minColor",
            baseName: "MinColor",
            type: "Color",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ColorScale.attributeTypeMap;

    }

    public maxCfvo: ConditionalFormattingValue;
    public maxColor: Color;
    public midCfvo: ConditionalFormattingValue;
    public midColor: Color;
    public minCfvo: ConditionalFormattingValue;
    public minColor: Color;

    public constructor(init?: Partial< ColorScale >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents a single column in a worksheet.   
export class Column  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "groupLevel",
            baseName: "GroupLevel",
            type: "number",
        },
        {
            name: "index",
            baseName: "Index",
            type: "number",
        },
        {
            name: "isHidden",
            baseName: "IsHidden",
            type: "boolean",
        },
        {
            name: "width",
            baseName: "Width",
            type: "number",
        },
        {
            name: "style",
            baseName: "Style",
            type: "LinkElement",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Column.attributeTypeMap) ;

    }

    public groupLevel: number;
    public index: number;
    public isHidden: boolean;
    public width: number;
    public style: LinkElement;

    public constructor(init?: Partial< Column >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Columns   
export class Columns  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "maxColumn",
            baseName: "MaxColumn",
            type: "number",
        },
        {
            name: "columnsCount",
            baseName: "ColumnsCount",
            type: "number",
        },
        {
            name: "columnsList",
            baseName: "ColumnsList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Columns.attributeTypeMap) ;

    }

    public maxColumn: number;
    public columnsCount: number;
    public columnsList: Array<LinkElement>;

    public constructor(init?: Partial< Columns >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates the object that represents a cell comment.   
export class Comment  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "cellName",
            baseName: "CellName",
            type: "string",
        },
        {
            name: "author",
            baseName: "Author",
            type: "string",
        },
        {
            name: "htmlNote",
            baseName: "HtmlNote",
            type: "string",
        },
        {
            name: "note",
            baseName: "Note",
            type: "string",
        },
        {
            name: "autoSize",
            baseName: "AutoSize",
            type: "boolean",
        },
        {
            name: "isVisible",
            baseName: "IsVisible",
            type: "boolean",
        },
        {
            name: "width",
            baseName: "Width",
            type: "number",
        },
        {
            name: "height",
            baseName: "Height",
            type: "number",
        },
        {
            name: "textHorizontalAlignment",
            baseName: "TextHorizontalAlignment",
            type: "string",
        },
        {
            name: "textOrientationType",
            baseName: "TextOrientationType",
            type: "string",
        },
        {
            name: "textVerticalAlignment",
            baseName: "TextVerticalAlignment",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Comment.attributeTypeMap) ;

    }

    public cellName: string;
    public author: string;
    public htmlNote: string;
    public note: string;
    public autoSize: boolean;
    public isVisible: boolean;
    public width: number;
    public height: number;
    public textHorizontalAlignment: string;
    public textOrientationType: string;
    public textVerticalAlignment: string;

    public constructor(init?: Partial< Comment >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates a collection of  objects.   
export class Comments  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "commentList",
            baseName: "CommentList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Comments.attributeTypeMap) ;

    }

    public commentList: Array<LinkElement>;

    public constructor(init?: Partial< Comments >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents conditional formatting condition.   
export class FormatCondition  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "priority",
            baseName: "Priority",
            type: "number",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "stopIfTrue",
            baseName: "StopIfTrue",
            type: "boolean",
        },
        {
            name: "aboveAverage",
            baseName: "AboveAverage",
            type: "AboveAverage",
        },
        {
            name: "colorScale",
            baseName: "ColorScale",
            type: "ColorScale",
        },
        {
            name: "dataBar",
            baseName: "DataBar",
            type: "DataBar",
        },
        {
            name: "formula1",
            baseName: "Formula1",
            type: "string",
        },
        {
            name: "formula2",
            baseName: "Formula2",
            type: "string",
        },
        {
            name: "iconSet",
            baseName: "IconSet",
            type: "IconSet",
        },
        {
            name: "operator",
            baseName: "Operator",
            type: "string",
        },
        {
            name: "style",
            baseName: "Style",
            type: "Style",
        },
        {
            name: "text",
            baseName: "Text",
            type: "string",
        },
        {
            name: "timePeriod",
            baseName: "TimePeriod",
            type: "string",
        },
        {
            name: "top10",
            baseName: "Top10",
            type: "Top10",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FormatCondition.attributeTypeMap) ;

    }

    public priority: number;
    public type: string;
    public stopIfTrue: boolean;
    public aboveAverage: AboveAverage;
    public colorScale: ColorScale;
    public dataBar: DataBar;
    public formula1: string;
    public formula2: string;
    public iconSet: IconSet;
    public operator: string;
    public style: Style;
    public text: string;
    public timePeriod: string;
    public top10: Top10;

    public constructor(init?: Partial< FormatCondition >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// I'm here to help! Please provide me with the features that need to be summarized.   
export class ConditionalFormatting  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sqref",
            baseName: "sqref",
            type: "string",
        },
        {
            name: "formatConditions",
            baseName: "FormatConditions",
            type: "Array<FormatCondition>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ConditionalFormatting.attributeTypeMap) ;

    }

    public sqref: string;
    public formatConditions: Array<FormatCondition>;

    public constructor(init?: Partial< ConditionalFormatting >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///            Represents  the custom  icon of conditional formatting rule.
///               
export class ConditionalFormattingIcon  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "imageData",
            baseName: "ImageData",
            type: "string",
        },
        {
            name: "index",
            baseName: "Index",
            type: "number",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ConditionalFormattingIcon.attributeTypeMap;

    }

    public imageData: string;
    public index: number;
    public type: string;

    public constructor(init?: Partial< ConditionalFormattingIcon >) {  
    
        Object.assign(this, init);
    } 
}
/// Encapsulates a collection of  objects.   
export class ConditionalFormattings  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "count",
            baseName: "Count",
            type: "number",
        },
        {
            name: "conditionalFormattingList",
            baseName: "ConditionalFormattingList",
            type: "Array<ConditionalFormatting>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ConditionalFormattings.attributeTypeMap) ;

    }

    public count: number;
    public conditionalFormattingList: Array<ConditionalFormatting>;

    public constructor(init?: Partial< ConditionalFormattings >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the copy options.   
export class CopyOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "columnCharacterWidth",
            baseName: "ColumnCharacterWidth",
            type: "boolean",
        },
        {
            name: "copyInvalidFormulasAsValues",
            baseName: "CopyInvalidFormulasAsValues",
            type: "boolean",
        },
        {
            name: "copyNames",
            baseName: "CopyNames",
            type: "boolean",
        },
        {
            name: "extendToAdjacentRange",
            baseName: "ExtendToAdjacentRange",
            type: "boolean",
        },
        {
            name: "referToDestinationSheet",
            baseName: "ReferToDestinationSheet",
            type: "boolean",
        },
        {
            name: "referToSheetWithSameName",
            baseName: "ReferToSheetWithSameName",
            type: "boolean",
        },
        {
            name: "copyTheme",
            baseName: "CopyTheme",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CopyOptions.attributeTypeMap;

    }

    public columnCharacterWidth: boolean;
    public copyInvalidFormulasAsValues: boolean;
    public copyNames: boolean;
    public extendToAdjacentRange: boolean;
    public referToDestinationSheet: boolean;
    public referToSheetWithSameName: boolean;
    public copyTheme: boolean;

    public constructor(init?: Partial< CopyOptions >) {  
    
        Object.assign(this, init);
    } 
}
/// Class Summary: The features include real-time collaboration, file sharing, scheduling, task tracking, and discussion forums to enhance communication and productivity.   
export class MultipleFilter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  MultipleFilter.attributeTypeMap;

    }


    public constructor(init?: Partial< MultipleFilter >) {  
    
        Object.assign(this, init);
    } 
}
/// 1. Collaboration: Students will have the opportunity to work together on group projects and assignments.
///             2. Critical Thinking: Students will be encouraged to analyze, evaluate, and interpret information in a meaningful way.
///             3. Hands-on Learning: Students will participate in experiential activities to apply theoretical knowledge in practical settings.
///             4. Technology Integration: Students will utilize various digital tools and platforms to enhance their learning experience.
///             5. Communication Skills: Students will develop effective verbal and written communication skills through presentations and written assignments.   
export class CriteriaMultipleFilter  extends MultipleFilter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "criteria",
            baseName: "Criteria",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CriteriaMultipleFilter.attributeTypeMap) ;

    }

    public criteria: string;

    public constructor(init?: Partial< CriteriaMultipleFilter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///            Represents the custom filter.
///               
export class CustomFilter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "criteria",
            baseName: "Criteria",
            type: "Object",
        },
        {
            name: "filterOperatorType",
            baseName: "FilterOperatorType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CustomFilter.attributeTypeMap;

    }

    public criteria: Object;
    public filterOperatorType: string;

    public constructor(init?: Partial< CustomFilter >) {  
    
        Object.assign(this, init);
    } 
}
///            Represents the border of the data bars specified by a conditional formatting rule.
///               
export class DataBarBorder  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "color",
            baseName: "Color",
            type: "Color",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DataBarBorder.attributeTypeMap;

    }

    public color: Color;
    public type: string;

    public constructor(init?: Partial< DataBarBorder >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents the color settings of the data bars for negative values that are
///    defined by a data bar conditional formating rule.
///                
export class NegativeBarFormat  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "borderColor",
            baseName: "BorderColor",
            type: "Color",
        },
        {
            name: "borderColorType",
            baseName: "BorderColorType",
            type: "string",
        },
        {
            name: "color",
            baseName: "Color",
            type: "Color",
        },
        {
            name: "colorType",
            baseName: "ColorType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  NegativeBarFormat.attributeTypeMap;

    }

    public borderColor: Color;
    public borderColorType: string;
    public color: Color;
    public colorType: string;

    public constructor(init?: Partial< NegativeBarFormat >) {  
    
        Object.assign(this, init);
    } 
}
/// Describe the DataBar conditional formatting rule. This conditional formatting
///    rule displays a gradated data bar in the range of cells.   
export class DataBar  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "axisColor",
            baseName: "AxisColor",
            type: "Color",
        },
        {
            name: "axisPosition",
            baseName: "AxisPosition",
            type: "string",
        },
        {
            name: "barBorder",
            baseName: "BarBorder",
            type: "DataBarBorder",
        },
        {
            name: "barFillType",
            baseName: "BarFillType",
            type: "string",
        },
        {
            name: "color",
            baseName: "Color",
            type: "Color",
        },
        {
            name: "direction",
            baseName: "Direction",
            type: "string",
        },
        {
            name: "maxCfvo",
            baseName: "MaxCfvo",
            type: "ConditionalFormattingValue",
        },
        {
            name: "maxLength",
            baseName: "MaxLength",
            type: "number",
        },
        {
            name: "minCfvo",
            baseName: "MinCfvo",
            type: "ConditionalFormattingValue",
        },
        {
            name: "minLength",
            baseName: "MinLength",
            type: "number",
        },
        {
            name: "negativeBarFormat",
            baseName: "NegativeBarFormat",
            type: "NegativeBarFormat",
        },
        {
            name: "showValue",
            baseName: "ShowValue",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DataBar.attributeTypeMap;

    }

    public axisColor: Color;
    public axisPosition: string;
    public barBorder: DataBarBorder;
    public barFillType: string;
    public color: Color;
    public direction: string;
    public maxCfvo: ConditionalFormattingValue;
    public maxLength: number;
    public minCfvo: ConditionalFormattingValue;
    public minLength: number;
    public negativeBarFormat: NegativeBarFormat;
    public showValue: boolean;

    public constructor(init?: Partial< DataBar >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents data filling.   
export class DataFill  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "ranges",
            baseName: "Ranges",
            type: "Array<Range>",
        },
        {
            name: "dataFillDefaultValue",
            baseName: "DataFillDefaultValue",
            type: "DataFillValue",
        },
        {
            name: "dataColumnFillValueList",
            baseName: "DataColumnFillValueList",
            type: "Array<DataColumnFillValue>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DataFill.attributeTypeMap;

    }

    public ranges: Array<Range>;
    public dataFillDefaultValue: DataFillValue;
    public dataColumnFillValueList: Array<DataColumnFillValue>;

    public constructor(init?: Partial< DataFill >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents data cleansing.   
export class DataCleansing  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "ranges",
            baseName: "Ranges",
            type: "Array<Range>",
        },
        {
            name: "needFillData",
            baseName: "NeedFillData",
            type: "boolean",
        },
        {
            name: "dataFill",
            baseName: "DataFill",
            type: "DataFill",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DataCleansing.attributeTypeMap;

    }

    public ranges: Array<Range>;
    public needFillData: boolean;
    public dataFill: DataFill;

    public constructor(init?: Partial< DataCleansing >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents that the data is populated with the specified value.   
export class DataFillValue  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "defaultBoolean",
            baseName: "DefaultBoolean",
            type: "boolean",
        },
        {
            name: "defaultString",
            baseName: "DefaultString",
            type: "string",
        },
        {
            name: "defaultNumber",
            baseName: "DefaultNumber",
            type: "number",
        },
        {
            name: "defaultDouble",
            baseName: "DefaultDouble",
            type: "number",
        },
        {
            name: "defaultDate",
            baseName: "DefaultDate",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DataFillValue.attributeTypeMap;

    }

    public defaultBoolean: boolean;
    public defaultString: string;
    public defaultNumber: number;
    public defaultDouble: number;
    public defaultDate: string;

    public constructor(init?: Partial< DataFillValue >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents that the data column is populated with the specified value.   
export class DataColumnFillValue  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "columnIndex",
            baseName: "ColumnIndex",
            type: "number",
        },
        {
            name: "dataFillValue",
            baseName: "DataFillValue",
            type: "DataFillValue",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DataColumnFillValue.attributeTypeMap;

    }

    public columnIndex: number;
    public dataFillValue: DataFillValue;

    public constructor(init?: Partial< DataColumnFillValue >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents data item.   
export class DataItem  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataItemType",
            baseName: "DataItemType",
            type: "string",
        },
        {
            name: "value",
            baseName: "Value",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DataItem.attributeTypeMap;

    }

    public dataItemType: string;
    public value: string;

    public constructor(init?: Partial< DataItem >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents the key of the data sorter.
///     
export class DataSorterKey  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "order",
            baseName: "Order",
            type: "string",
        },
        {
            name: "index",
            baseName: "Index",
            type: "number",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "iconSetType",
            baseName: "IconSetType",
            type: "string",
        },
        {
            name: "iconId",
            baseName: "IconId",
            type: "number",
        },
        {
            name: "color",
            baseName: "Color",
            type: "Color",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DataSorterKey.attributeTypeMap;

    }

    public order: string;
    public index: number;
    public type: string;
    public iconSetType: string;
    public iconId: number;
    public color: Color;

    public constructor(init?: Partial< DataSorterKey >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents sort key.   
export class SortKey  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "key",
            baseName: "Key",
            type: "number",
        },
        {
            name: "sortOrder",
            baseName: "SortOrder",
            type: "string",
        },
        {
            name: "customList",
            baseName: "CustomList",
            type: "Array<string>",
        },
        {
            name: "order",
            baseName: "Order",
            type: "string",
        },
        {
            name: "index",
            baseName: "Index",
            type: "number",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  SortKey.attributeTypeMap;

    }

    public key: number;
    public sortOrder: string;
    public customList: Array<string>;
    public order: string;
    public index: number;
    public type: string;

    public constructor(init?: Partial< SortKey >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents data source.   
export class DataSource  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSourceType",
            baseName: "DataSourceType",
            type: "string",
        },
        {
            name: "dataPath",
            baseName: "DataPath",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DataSource.attributeTypeMap;

    }

    public dataSourceType: string;
    public dataPath: string;

    public constructor(init?: Partial< DataSource >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents the datetime's group setting.   
export class DateTimeGroupItem  extends MultipleFilter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dateTimeGroupingType",
            baseName: "DateTimeGroupingType",
            type: "string",
        },
        {
            name: "day",
            baseName: "Day",
            type: "number",
        },
        {
            name: "hour",
            baseName: "Hour",
            type: "number",
        },
        {
            name: "minute",
            baseName: "Minute",
            type: "number",
        },
        {
            name: "month",
            baseName: "Month",
            type: "number",
        },
        {
            name: "second",
            baseName: "Second",
            type: "number",
        },
        {
            name: "year",
            baseName: "Year",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DateTimeGroupItem.attributeTypeMap) ;

    }

    public dateTimeGroupingType: string;
    public day: number;
    public hour: number;
    public minute: number;
    public month: number;
    public second: number;
    public year: number;

    public constructor(init?: Partial< DateTimeGroupItem >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents data deduplication region.   
export class DeduplicationRegion  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "ranges",
            baseName: "Ranges",
            type: "Array<Range>",
        },
        {
            name: "worksheetNameList",
            baseName: "WorksheetNameList",
            type: "Array<string>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DeduplicationRegion.attributeTypeMap;

    }

    public ranges: Array<Range>;
    public worksheetNameList: Array<string>;

    public constructor(init?: Partial< DeduplicationRegion >) {  
    
        Object.assign(this, init);
    } 
}
///            Represents the dynamic filter.
///               
export class DynamicFilter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dynamicFilterType",
            baseName: "DynamicFilterType",
            type: "string",
        },
        {
            name: "maxValue",
            baseName: "MaxValue",
            type: "Object",
        },
        {
            name: "value",
            baseName: "Value",
            type: "Object",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DynamicFilter.attributeTypeMap;

    }

    public dynamicFilterType: string;
    public maxValue: Object;
    public value: Object;

    public constructor(init?: Partial< DynamicFilter >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents file information.   
export class FileInfo  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "filename",
            baseName: "Filename",
            type: "string",
        },
        {
            name: "fileSize",
            baseName: "FileSize",
            type: "number",
        },
        {
            name: "fileContent",
            baseName: "FileContent",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  FileInfo.attributeTypeMap;

    }

    public filename: string;
    public fileSize: number;
    public fileContent: string;

    public constructor(init?: Partial< FileInfo >) {  
    
        Object.assign(this, init);
    } 
}
/// I'm sorry, I just realized you didn't provide any features for me to summarize. Please provide the features you'd like me to summarize for the class.   
export class FileSource  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "fileSourceType",
            baseName: "FileSourceType",
            type: "string",
        },
        {
            name: "filePath",
            baseName: "FilePath",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  FileSource.attributeTypeMap;

    }

    public fileSourceType: string;
    public filePath: string;

    public constructor(init?: Partial< FileSource >) {  
    
        Object.assign(this, init);
    } 
}
/// Class features: Weekly lectures, group projects, midterm and final exams, and participation in class discussions.   
export class FilesResult  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "files",
            baseName: "Files",
            type: "Array<FileInfo>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  FilesResult.attributeTypeMap;

    }

    public files: Array<FileInfo>;

    public constructor(init?: Partial< FilesResult >) {  
    
        Object.assign(this, init);
    } 
}
///            Represents icon filter.
///               
export class IconFilter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "iconId",
            baseName: "IconId",
            type: "number",
        },
        {
            name: "iconSetType",
            baseName: "IconSetType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  IconFilter.attributeTypeMap;

    }

    public iconId: number;
    public iconSetType: string;

    public constructor(init?: Partial< IconFilter >) {  
    
        Object.assign(this, init);
    } 
}
///            Represents the multiple filter collection.
///               
export class MultipleFilters  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "matchBlank",
            baseName: "MatchBlank",
            type: "boolean",
        },
        {
            name: "multipleFilterList",
            baseName: "MultipleFilterList",
            type: "Array<MultipleFilter>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  MultipleFilters.attributeTypeMap;

    }

    public matchBlank: boolean;
    public multipleFilterList: Array<MultipleFilter>;

    public constructor(init?: Partial< MultipleFilters >) {  
    
        Object.assign(this, init);
    } 
}
///            Represents the top 10 filter.
///               
export class Top10Filter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "fieldIndex",
            baseName: "FieldIndex",
            type: "number",
        },
        {
            name: "criteria",
            baseName: "Criteria",
            type: "string",
        },
        {
            name: "isPercent",
            baseName: "IsPercent",
            type: "boolean",
        },
        {
            name: "isTop",
            baseName: "IsTop",
            type: "boolean",
        },
        {
            name: "items",
            baseName: "Items",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Top10Filter.attributeTypeMap;

    }

    public fieldIndex: number;
    public criteria: string;
    public isPercent: boolean;
    public isTop: boolean;
    public items: number;

    public constructor(init?: Partial< Top10Filter >) {  
    
        Object.assign(this, init);
    } 
}
///            Encapsulates the font object used in a spreadsheet.
///               
export class Font  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "color",
            baseName: "Color",
            type: "Color",
        },
        {
            name: "doubleSize",
            baseName: "DoubleSize",
            type: "number",
        },
        {
            name: "isBold",
            baseName: "IsBold",
            type: "boolean",
        },
        {
            name: "isItalic",
            baseName: "IsItalic",
            type: "boolean",
        },
        {
            name: "isStrikeout",
            baseName: "IsStrikeout",
            type: "boolean",
        },
        {
            name: "isSubscript",
            baseName: "IsSubscript",
            type: "boolean",
        },
        {
            name: "isSuperscript",
            baseName: "IsSuperscript",
            type: "boolean",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "size",
            baseName: "Size",
            type: "number",
        },
        {
            name: "underline",
            baseName: "Underline",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Font.attributeTypeMap;

    }

    public color: Color;
    public doubleSize: number;
    public isBold: boolean;
    public isItalic: boolean;
    public isStrikeout: boolean;
    public isSubscript: boolean;
    public isSuperscript: boolean;
    public name: string;
    public size: number;
    public underline: string;

    public constructor(init?: Partial< Font >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents the text options.   
export class TextOptions  extends Font  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "fill",
            baseName: "Fill",
            type: "FillFormat",
        },
        {
            name: "kerning",
            baseName: "Kerning",
            type: "number",
        },
        {
            name: "outline",
            baseName: "Outline",
            type: "LineFormat",
        },
        {
            name: "shadow",
            baseName: "Shadow",
            type: "ShadowEffect",
        },
        {
            name: "spacing",
            baseName: "Spacing",
            type: "number",
        },
        {
            name: "underlineColor",
            baseName: "UnderlineColor",
            type: "CellsColor",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TextOptions.attributeTypeMap) ;

    }

    public fill: FillFormat;
    public kerning: number;
    public outline: LineFormat;
    public shadow: ShadowEffect;
    public spacing: number;
    public underlineColor: CellsColor;

    public constructor(init?: Partial< TextOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///            Represents a range of characters within the cell text.
///               
export class FontSetting  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "font",
            baseName: "Font",
            type: "Font",
        },
        {
            name: "length",
            baseName: "Length",
            type: "number",
        },
        {
            name: "startIndex",
            baseName: "StartIndex",
            type: "number",
        },
        {
            name: "textOptions",
            baseName: "TextOptions",
            type: "TextOptions",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  FontSetting.attributeTypeMap;

    }

    public font: Font;
    public length: number;
    public startIndex: number;
    public textOptions: TextOptions;
    public type: string;

    public constructor(init?: Partial< FontSetting >) {  
    
        Object.assign(this, init);
    } 
}
/// Describe the IconSet conditional formatting rule. This conditional formatting
///     rule applies icons to cells according to their values.   
export class IconSet  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "cfIcons",
            baseName: "CfIcons",
            type: "Array<ConditionalFormattingIcon>",
        },
        {
            name: "cfvos",
            baseName: "Cfvos",
            type: "Array<ConditionalFormattingValue>",
        },
        {
            name: "isCustom",
            baseName: "IsCustom",
            type: "boolean",
        },
        {
            name: "reverse",
            baseName: "Reverse",
            type: "boolean",
        },
        {
            name: "showValue",
            baseName: "ShowValue",
            type: "boolean",
        },
        {
            name: "iconSetType",
            baseName: "IconSetType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  IconSet.attributeTypeMap;

    }

    public cfIcons: Array<ConditionalFormattingIcon>;
    public cfvos: Array<ConditionalFormattingValue>;
    public isCustom: boolean;
    public reverse: boolean;
    public showValue: boolean;
    public iconSetType: string;

    public constructor(init?: Partial< IconSet >) {  
    
        Object.assign(this, init);
    } 
}
///            Represents display style of excel document,such as font,color,alignment,border,etc.            The Style object contains all style attributes (font, number format, alignment, and so on) as properties.
///               
export class Style  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "font",
            baseName: "Font",
            type: "Font",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "cultureCustom",
            baseName: "CultureCustom",
            type: "string",
        },
        {
            name: "custom",
            baseName: "Custom",
            type: "string",
        },
        {
            name: "backgroundColor",
            baseName: "BackgroundColor",
            type: "Color",
        },
        {
            name: "foregroundColor",
            baseName: "ForegroundColor",
            type: "Color",
        },
        {
            name: "isFormulaHidden",
            baseName: "IsFormulaHidden",
            type: "boolean",
        },
        {
            name: "isDateTime",
            baseName: "IsDateTime",
            type: "boolean",
        },
        {
            name: "isTextWrapped",
            baseName: "IsTextWrapped",
            type: "boolean",
        },
        {
            name: "isGradient",
            baseName: "IsGradient",
            type: "boolean",
        },
        {
            name: "isLocked",
            baseName: "IsLocked",
            type: "boolean",
        },
        {
            name: "isPercent",
            baseName: "IsPercent",
            type: "boolean",
        },
        {
            name: "shrinkToFit",
            baseName: "ShrinkToFit",
            type: "boolean",
        },
        {
            name: "indentLevel",
            baseName: "IndentLevel",
            type: "number",
        },
        {
            name: "number",
            baseName: "Number",
            type: "number",
        },
        {
            name: "rotationAngle",
            baseName: "RotationAngle",
            type: "number",
        },
        {
            name: "pattern",
            baseName: "Pattern",
            type: "string",
        },
        {
            name: "textDirection",
            baseName: "TextDirection",
            type: "string",
        },
        {
            name: "verticalAlignment",
            baseName: "VerticalAlignment",
            type: "string",
        },
        {
            name: "horizontalAlignment",
            baseName: "HorizontalAlignment",
            type: "string",
        },
        {
            name: "borderCollection",
            baseName: "BorderCollection",
            type: "Array<Border>",
        },
        {
            name: "backgroundThemeColor",
            baseName: "BackgroundThemeColor",
            type: "ThemeColor",
        },
        {
            name: "foregroundThemeColor",
            baseName: "ForegroundThemeColor",
            type: "ThemeColor",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Style.attributeTypeMap;

    }

    public font: Font;
    public name: string;
    public cultureCustom: string;
    public custom: string;
    public backgroundColor: Color;
    public foregroundColor: Color;
    public isFormulaHidden: boolean;
    public isDateTime: boolean;
    public isTextWrapped: boolean;
    public isGradient: boolean;
    public isLocked: boolean;
    public isPercent: boolean;
    public shrinkToFit: boolean;
    public indentLevel: number;
    public number: number;
    public rotationAngle: number;
    public pattern: string;
    public textDirection: string;
    public verticalAlignment: string;
    public horizontalAlignment: string;
    public borderCollection: Array<Border>;
    public backgroundThemeColor: ThemeColor;
    public foregroundThemeColor: ThemeColor;

    public constructor(init?: Partial< Style >) {  
    
        Object.assign(this, init);
    } 
}
/// Describe the Top10 conditional formatting rule. This conditional formatting
///     rule highlights cells whose values fall in the top N or bottom N bracket,
///     as specified.   
export class Top10  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "isBottom",
            baseName: "IsBottom",
            type: "boolean",
        },
        {
            name: "isPercent",
            baseName: "IsPercent",
            type: "boolean",
        },
        {
            name: "rank",
            baseName: "Rank",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Top10.attributeTypeMap;

    }

    public isBottom: boolean;
    public isPercent: boolean;
    public rank: number;

    public constructor(init?: Partial< Top10 >) {  
    
        Object.assign(this, init);
    } 
}
/// Class summary: This class covers various features related to data visualization and graphical representation of data sets.   
export class FormulaFormatCondition  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "formula1",
            baseName: "Formula1",
            type: "string",
        },
        {
            name: "formula2",
            baseName: "Formula2",
            type: "string",
        },
        {
            name: "operator",
            baseName: "Operator",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  FormulaFormatCondition.attributeTypeMap;

    }

    public formula1: string;
    public formula2: string;
    public operator: string;

    public constructor(init?: Partial< FormulaFormatCondition >) {  
    
        Object.assign(this, init);
    } 
}
/// Settings of formulas and calculation.
///     
export class FormulaSettings  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "calculateOnOpen",
            baseName: "CalculateOnOpen",
            type: "boolean",
        },
        {
            name: "calculateOnSave",
            baseName: "CalculateOnSave",
            type: "boolean",
        },
        {
            name: "forceFullCalculation",
            baseName: "ForceFullCalculation",
            type: "boolean",
        },
        {
            name: "calculationMode",
            baseName: "CalculationMode",
            type: "string",
        },
        {
            name: "calculationId",
            baseName: "CalculationId",
            type: "string",
        },
        {
            name: "enableIterativeCalculation",
            baseName: "EnableIterativeCalculation",
            type: "boolean",
        },
        {
            name: "maxIteration",
            baseName: "MaxIteration",
            type: "number",
        },
        {
            name: "maxChange",
            baseName: "MaxChange",
            type: "number",
        },
        {
            name: "precisionAsDisplayed",
            baseName: "PrecisionAsDisplayed",
            type: "boolean",
        },
        {
            name: "enableCalculationChain",
            baseName: "EnableCalculationChain",
            type: "boolean",
        },
        {
            name: "preservePaddingSpaces",
            baseName: "PreservePaddingSpaces",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  FormulaSettings.attributeTypeMap;

    }

    public calculateOnOpen: boolean;
    public calculateOnSave: boolean;
    public forceFullCalculation: boolean;
    public calculationMode: string;
    public calculationId: string;
    public enableIterativeCalculation: boolean;
    public maxIteration: number;
    public maxChange: number;
    public precisionAsDisplayed: boolean;
    public enableCalculationChain: boolean;
    public preservePaddingSpaces: boolean;

    public constructor(init?: Partial< FormulaSettings >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents the globalization settings for chart.
///     
export class ChartGlobalizationSettings  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ChartGlobalizationSettings.attributeTypeMap;

    }


    public constructor(init?: Partial< ChartGlobalizationSettings >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents the globalization settings for pivot tables.
///     
export class PivotGlobalizationSettings  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  PivotGlobalizationSettings.attributeTypeMap;

    }


    public constructor(init?: Partial< PivotGlobalizationSettings >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents the globalization settings.
///     
export class GlobalizationSettings  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "chartSettings",
            baseName: "ChartSettings",
            type: "ChartGlobalizationSettings",
        },
        {
            name: "pivotSettings",
            baseName: "PivotSettings",
            type: "PivotGlobalizationSettings",
        },
        {
            name: "listSeparator",
            baseName: "ListSeparator",
            type: "string",
        },
        {
            name: "rowSeparatorOfFormulaArray",
            baseName: "RowSeparatorOfFormulaArray",
            type: "string",
        },
        {
            name: "columnSeparatorOfFormulaArray",
            baseName: "ColumnSeparatorOfFormulaArray",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  GlobalizationSettings.attributeTypeMap;

    }

    public chartSettings: ChartGlobalizationSettings;
    public pivotSettings: PivotGlobalizationSettings;
    public listSeparator: string;
    public rowSeparatorOfFormulaArray: string;
    public columnSeparatorOfFormulaArray: string;

    public constructor(init?: Partial< GlobalizationSettings >) {  
    
        Object.assign(this, init);
    } 
}
///            Encapsulates the object that represents a horizontal page break.
///               
export class HorizontalPageBreak  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "row",
            baseName: "Row",
            type: "number",
        },
        {
            name: "endColumn",
            baseName: "EndColumn",
            type: "number",
        },
        {
            name: "startColumn",
            baseName: "StartColumn",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  HorizontalPageBreak.attributeTypeMap;

    }

    public row: number;
    public endColumn: number;
    public startColumn: number;

    public constructor(init?: Partial< HorizontalPageBreak >) {  
    
        Object.assign(this, init);
    } 
}
/// Encapsulates a collection of  objects.   
export class HorizontalPageBreaks  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(HorizontalPageBreaks.attributeTypeMap) ;

    }


    public constructor(init?: Partial< HorizontalPageBreaks >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates the object that represents a hyperlink.   
export class Hyperlink  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "address",
            baseName: "Address",
            type: "string",
        },
        {
            name: "area",
            baseName: "Area",
            type: "CellArea",
        },
        {
            name: "screenTip",
            baseName: "ScreenTip",
            type: "string",
        },
        {
            name: "textToDisplay",
            baseName: "TextToDisplay",
            type: "string",
        },
        {
            name: "linkType",
            baseName: "LinkType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Hyperlink.attributeTypeMap) ;

    }

    public address: string;
    public area: CellArea;
    public screenTip: string;
    public textToDisplay: string;
    public linkType: string;

    public constructor(init?: Partial< Hyperlink >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates a collection of  objects.   
export class Hyperlinks  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "count",
            baseName: "Count",
            type: "number",
        },
        {
            name: "hyperlinkList",
            baseName: "HyperlinkList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Hyperlinks.attributeTypeMap) ;

    }

    public count: number;
    public hyperlinkList: Array<LinkElement>;

    public constructor(init?: Partial< Hyperlinks >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the options of loading the file.   
export class LoadOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "convertNumericData",
            baseName: "ConvertNumericData",
            type: "string",
        },
        {
            name: "interruptMonitor",
            baseName: "InterruptMonitor",
            type: "string",
        },
        {
            name: "languageCode",
            baseName: "LanguageCode",
            type: "string",
        },
        {
            name: "loadDataOptions",
            baseName: "LoadDataOptions",
            type: "string",
        },
        {
            name: "loadFormat",
            baseName: "LoadFormat",
            type: "string",
        },
        {
            name: "onlyLoadDocumentProperties",
            baseName: "OnlyLoadDocumentProperties",
            type: "string",
        },
        {
            name: "parsingFormulaOnOpen",
            baseName: "ParsingFormulaOnOpen",
            type: "string",
        },
        {
            name: "password",
            baseName: "Password",
            type: "string",
        },
        {
            name: "region",
            baseName: "Region",
            type: "string",
        },
        {
            name: "standardFont",
            baseName: "StandardFont",
            type: "string",
        },
        {
            name: "standardFontSize",
            baseName: "StandardFontSize",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  LoadOptions.attributeTypeMap;

    }

    public convertNumericData: string;
    public interruptMonitor: string;
    public languageCode: string;
    public loadDataOptions: string;
    public loadFormat: string;
    public onlyLoadDocumentProperties: string;
    public parsingFormulaOnOpen: string;
    public password: string;
    public region: string;
    public standardFont: string;
    public standardFontSize: number;

    public constructor(init?: Partial< LoadOptions >) {  
    
        Object.assign(this, init);
    } 
}
/// I'm happy to help! Could you please provide me with the features you would like me to summarize for the class?   
export class MergedCell  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "endColumn",
            baseName: "EndColumn",
            type: "number",
        },
        {
            name: "endRow",
            baseName: "EndRow",
            type: "number",
        },
        {
            name: "startColumn",
            baseName: "StartColumn",
            type: "number",
        },
        {
            name: "startRow",
            baseName: "StartRow",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(MergedCell.attributeTypeMap) ;

    }

    public endColumn: number;
    public endRow: number;
    public startColumn: number;
    public startRow: number;

    public constructor(init?: Partial< MergedCell >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Sure, could you please provide me with the features you would like me to summarize?   
export class MergedCells  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "count",
            baseName: "Count",
            type: "number",
        },
        {
            name: "mergedCellList",
            baseName: "MergedCellList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(MergedCells.attributeTypeMap) ;

    }

    public count: number;
    public mergedCellList: Array<LinkElement>;

    public constructor(init?: Partial< MergedCells >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents a defined name for a range of cells.   
export class Name  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "comment",
            baseName: "Comment",
            type: "string",
        },
        {
            name: "worksheetIndex",
            baseName: "WorksheetIndex",
            type: "number",
        },
        {
            name: "isReferred",
            baseName: "IsReferred",
            type: "boolean",
        },
        {
            name: "isVisible",
            baseName: "IsVisible",
            type: "boolean",
        },
        {
            name: "r1C1RefersTo",
            baseName: "R1C1RefersTo",
            type: "string",
        },
        {
            name: "refersTo",
            baseName: "RefersTo",
            type: "string",
        },
        {
            name: "text",
            baseName: "Text",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Name.attributeTypeMap) ;

    }

    public comment: string;
    public worksheetIndex: number;
    public isReferred: boolean;
    public isVisible: boolean;
    public r1C1RefersTo: string;
    public refersTo: string;
    public text: string;

    public constructor(init?: Partial< Name >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents a collection of all the  objects in the spreadsheet.   
export class Names  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "count",
            baseName: "Count",
            type: "number",
        },
        {
            name: "nameList",
            baseName: "NameList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Names.attributeTypeMap) ;

    }

    public count: number;
    public nameList: Array<LinkElement>;

    public constructor(init?: Partial< Names >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Class summary: Includes interactive discussions, group projects, guest speakers, and practical applications of course material.   
export class PageSection  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "section",
            baseName: "Section",
            type: "number",
        },
        {
            name: "context",
            baseName: "Context",
            type: "string",
        },
        {
            name: "picture",
            baseName: "Picture",
            type: "string",
        },
        {
            name: "fisrtPageContext",
            baseName: "FisrtPageContext",
            type: "string",
        },
        {
            name: "evenPageContext",
            baseName: "EvenPageContext",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  PageSection.attributeTypeMap;

    }

    public section: number;
    public context: string;
    public picture: string;
    public fisrtPageContext: string;
    public evenPageContext: string;

    public constructor(init?: Partial< PageSection >) {  
    
        Object.assign(this, init);
    } 
}
/// excel print page setting   
export class PageSetup  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "blackAndWhite",
            baseName: "BlackAndWhite",
            type: "boolean",
        },
        {
            name: "bottomMargin",
            baseName: "BottomMargin",
            type: "number",
        },
        {
            name: "centerHorizontally",
            baseName: "CenterHorizontally",
            type: "boolean",
        },
        {
            name: "centerVertically",
            baseName: "CenterVertically",
            type: "boolean",
        },
        {
            name: "firstPageNumber",
            baseName: "FirstPageNumber",
            type: "number",
        },
        {
            name: "fitToPagesTall",
            baseName: "FitToPagesTall",
            type: "number",
        },
        {
            name: "fitToPagesWide",
            baseName: "FitToPagesWide",
            type: "number",
        },
        {
            name: "footerMargin",
            baseName: "FooterMargin",
            type: "number",
        },
        {
            name: "headerMargin",
            baseName: "HeaderMargin",
            type: "number",
        },
        {
            name: "isAutoFirstPageNumber",
            baseName: "IsAutoFirstPageNumber",
            type: "boolean",
        },
        {
            name: "isHFAlignMargins",
            baseName: "IsHFAlignMargins",
            type: "boolean",
        },
        {
            name: "isHFDiffFirst",
            baseName: "IsHFDiffFirst",
            type: "boolean",
        },
        {
            name: "isHFDiffOddEven",
            baseName: "IsHFDiffOddEven",
            type: "boolean",
        },
        {
            name: "isHFScaleWithDoc",
            baseName: "IsHFScaleWithDoc",
            type: "boolean",
        },
        {
            name: "isPercentScale",
            baseName: "IsPercentScale",
            type: "boolean",
        },
        {
            name: "leftMargin",
            baseName: "LeftMargin",
            type: "number",
        },
        {
            name: "order",
            baseName: "Order",
            type: "string",
        },
        {
            name: "orientation",
            baseName: "Orientation",
            type: "string",
        },
        {
            name: "paperSize",
            baseName: "PaperSize",
            type: "string",
        },
        {
            name: "printArea",
            baseName: "PrintArea",
            type: "string",
        },
        {
            name: "printComments",
            baseName: "PrintComments",
            type: "string",
        },
        {
            name: "printCopies",
            baseName: "PrintCopies",
            type: "number",
        },
        {
            name: "printDraft",
            baseName: "PrintDraft",
            type: "boolean",
        },
        {
            name: "printErrors",
            baseName: "PrintErrors",
            type: "string",
        },
        {
            name: "printGridlines",
            baseName: "PrintGridlines",
            type: "boolean",
        },
        {
            name: "printHeadings",
            baseName: "PrintHeadings",
            type: "boolean",
        },
        {
            name: "printQuality",
            baseName: "PrintQuality",
            type: "number",
        },
        {
            name: "printTitleColumns",
            baseName: "PrintTitleColumns",
            type: "string",
        },
        {
            name: "printTitleRows",
            baseName: "PrintTitleRows",
            type: "string",
        },
        {
            name: "rightMargin",
            baseName: "RightMargin",
            type: "number",
        },
        {
            name: "topMargin",
            baseName: "TopMargin",
            type: "number",
        },
        {
            name: "zoom",
            baseName: "Zoom",
            type: "number",
        },
        {
            name: "header",
            baseName: "Header",
            type: "Array<PageSection>",
        },
        {
            name: "footer",
            baseName: "Footer",
            type: "Array<PageSection>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PageSetup.attributeTypeMap) ;

    }

    public blackAndWhite: boolean;
    public bottomMargin: number;
    public centerHorizontally: boolean;
    public centerVertically: boolean;
    public firstPageNumber: number;
    public fitToPagesTall: number;
    public fitToPagesWide: number;
    public footerMargin: number;
    public headerMargin: number;
    public isAutoFirstPageNumber: boolean;
    public isHFAlignMargins: boolean;
    public isHFDiffFirst: boolean;
    public isHFDiffOddEven: boolean;
    public isHFScaleWithDoc: boolean;
    public isPercentScale: boolean;
    public leftMargin: number;
    public order: string;
    public orientation: string;
    public paperSize: string;
    public printArea: string;
    public printComments: string;
    public printCopies: number;
    public printDraft: boolean;
    public printErrors: string;
    public printGridlines: boolean;
    public printHeadings: boolean;
    public printQuality: number;
    public printTitleColumns: string;
    public printTitleRows: string;
    public rightMargin: number;
    public topMargin: number;
    public zoom: number;
    public header: Array<PageSection>;
    public footer: Array<PageSection>;

    public constructor(init?: Partial< PageSetup >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the paste special options.
///                
export class PasteOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "onlyVisibleCells",
            baseName: "OnlyVisibleCells",
            type: "boolean",
        },
        {
            name: "pasteType",
            baseName: "PasteType",
            type: "string",
        },
        {
            name: "skipBlanks",
            baseName: "SkipBlanks",
            type: "boolean",
        },
        {
            name: "transpose",
            baseName: "Transpose",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  PasteOptions.attributeTypeMap;

    }

    public onlyVisibleCells: boolean;
    public pasteType: string;
    public skipBlanks: boolean;
    public transpose: boolean;

    public constructor(init?: Partial< PasteOptions >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents the various types of protection options available for a worksheet.
///                
export class Protection  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "allowDeletingColumn",
            baseName: "AllowDeletingColumn",
            type: "boolean",
        },
        {
            name: "allowDeletingRow",
            baseName: "AllowDeletingRow",
            type: "boolean",
        },
        {
            name: "allowFiltering",
            baseName: "AllowFiltering",
            type: "boolean",
        },
        {
            name: "allowFormattingCell",
            baseName: "AllowFormattingCell",
            type: "boolean",
        },
        {
            name: "allowFormattingColumn",
            baseName: "AllowFormattingColumn",
            type: "boolean",
        },
        {
            name: "allowFormattingRow",
            baseName: "AllowFormattingRow",
            type: "boolean",
        },
        {
            name: "allowInsertingColumn",
            baseName: "AllowInsertingColumn",
            type: "boolean",
        },
        {
            name: "allowInsertingHyperlink",
            baseName: "AllowInsertingHyperlink",
            type: "boolean",
        },
        {
            name: "allowInsertingRow",
            baseName: "AllowInsertingRow",
            type: "boolean",
        },
        {
            name: "allowSorting",
            baseName: "AllowSorting",
            type: "boolean",
        },
        {
            name: "allowUsingPivotTable",
            baseName: "AllowUsingPivotTable",
            type: "boolean",
        },
        {
            name: "allowEditingContent",
            baseName: "AllowEditingContent",
            type: "boolean",
        },
        {
            name: "allowEditingObject",
            baseName: "AllowEditingObject",
            type: "boolean",
        },
        {
            name: "allowEditingScenario",
            baseName: "AllowEditingScenario",
            type: "boolean",
        },
        {
            name: "password",
            baseName: "Password",
            type: "string",
        },
        {
            name: "allowSelectingLockedCell",
            baseName: "AllowSelectingLockedCell",
            type: "boolean",
        },
        {
            name: "allowSelectingUnlockedCell",
            baseName: "AllowSelectingUnlockedCell",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Protection.attributeTypeMap;

    }

    public allowDeletingColumn: boolean;
    public allowDeletingRow: boolean;
    public allowFiltering: boolean;
    public allowFormattingCell: boolean;
    public allowFormattingColumn: boolean;
    public allowFormattingRow: boolean;
    public allowInsertingColumn: boolean;
    public allowInsertingHyperlink: boolean;
    public allowInsertingRow: boolean;
    public allowSorting: boolean;
    public allowUsingPivotTable: boolean;
    public allowEditingContent: boolean;
    public allowEditingObject: boolean;
    public allowEditingScenario: boolean;
    public password: string;
    public allowSelectingLockedCell: boolean;
    public allowSelectingUnlockedCell: boolean;

    public constructor(init?: Partial< Protection >) {  
    
        Object.assign(this, init);
    } 
}
/// Class Summary: The features discussed include natural language processing, image recognition, data visualization, clustering, regression, classification, and recommendation systems.   
export class ProtectSheetParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "protectionType",
            baseName: "ProtectionType",
            type: "string",
        },
        {
            name: "password",
            baseName: "Password",
            type: "string",
        },
        {
            name: "allowEditArea",
            baseName: "AllowEditArea",
            type: "Array<string>",
        },
        {
            name: "allowDeletingColumn",
            baseName: "AllowDeletingColumn",
            type: "string",
        },
        {
            name: "allowDeletingRow",
            baseName: "AllowDeletingRow",
            type: "string",
        },
        {
            name: "allowFiltering",
            baseName: "AllowFiltering",
            type: "string",
        },
        {
            name: "allowFormattingCell",
            baseName: "AllowFormattingCell",
            type: "string",
        },
        {
            name: "allowFormattingColumn",
            baseName: "AllowFormattingColumn",
            type: "string",
        },
        {
            name: "allowFormattingRow",
            baseName: "AllowFormattingRow",
            type: "string",
        },
        {
            name: "allowInsertingColumn",
            baseName: "AllowInsertingColumn",
            type: "string",
        },
        {
            name: "allowInsertingHyperlink",
            baseName: "AllowInsertingHyperlink",
            type: "string",
        },
        {
            name: "allowInsertingRow",
            baseName: "AllowInsertingRow",
            type: "string",
        },
        {
            name: "allowSelectingLockedCell",
            baseName: "AllowSelectingLockedCell",
            type: "string",
        },
        {
            name: "allowSelectingUnlockedCell",
            baseName: "AllowSelectingUnlockedCell",
            type: "string",
        },
        {
            name: "allowSorting",
            baseName: "AllowSorting",
            type: "string",
        },
        {
            name: "allowUsingPivotTable",
            baseName: "AllowUsingPivotTable",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ProtectSheetParameter.attributeTypeMap;

    }

    public protectionType: string;
    public password: string;
    public allowEditArea: Array<string>;
    public allowDeletingColumn: string;
    public allowDeletingRow: string;
    public allowFiltering: string;
    public allowFormattingCell: string;
    public allowFormattingColumn: string;
    public allowFormattingRow: string;
    public allowInsertingColumn: string;
    public allowInsertingHyperlink: string;
    public allowInsertingRow: string;
    public allowSelectingLockedCell: string;
    public allowSelectingUnlockedCell: string;
    public allowSorting: string;
    public allowUsingPivotTable: string;

    public constructor(init?: Partial< ProtectSheetParameter >) {  
    
        Object.assign(this, init);
    } 
}
///            Encapsulates a collection of  objects.
///               
export class Ranges  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "rangeList",
            baseName: "RangeList",
            type: "Array<Range>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Ranges.attributeTypeMap;

    }

    public rangeList: Array<Range>;

    public constructor(init?: Partial< Ranges >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents a single row in a worksheet.   
export class Row  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "groupLevel",
            baseName: "GroupLevel",
            type: "number",
        },
        {
            name: "height",
            baseName: "Height",
            type: "number",
        },
        {
            name: "index",
            baseName: "Index",
            type: "number",
        },
        {
            name: "isBlank",
            baseName: "IsBlank",
            type: "boolean",
        },
        {
            name: "isHeightMatched",
            baseName: "IsHeightMatched",
            type: "boolean",
        },
        {
            name: "isHidden",
            baseName: "IsHidden",
            type: "boolean",
        },
        {
            name: "style",
            baseName: "Style",
            type: "LinkElement",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Row.attributeTypeMap) ;

    }

    public groupLevel: number;
    public height: number;
    public index: number;
    public isBlank: boolean;
    public isHeightMatched: boolean;
    public isHidden: boolean;
    public style: LinkElement;

    public constructor(init?: Partial< Row >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Collects the  objects that represent the individual rows in a worksheet.   
export class Rows  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "maxRow",
            baseName: "MaxRow",
            type: "number",
        },
        {
            name: "rowsCount",
            baseName: "RowsCount",
            type: "number",
        },
        {
            name: "rowsList",
            baseName: "RowsList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Rows.attributeTypeMap) ;

    }

    public maxRow: number;
    public rowsCount: number;
    public rowsList: Array<LinkElement>;

    public constructor(init?: Partial< Rows >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents single value.   
export class SingleValue  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "value",
            baseName: "Value",
            type: "string",
        },
        {
            name: "valueType",
            baseName: "ValueType",
            type: "ValueType",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  SingleValue.attributeTypeMap;

    }

    public value: string;
    public valueType: ValueType;

    public constructor(init?: Partial< SingleValue >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents the result of the file split.   
export class SplitResult  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "documents",
            baseName: "Documents",
            type: "Array<CellsCloudFileInfo>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  SplitResult.attributeTypeMap;

    }

    public documents: Array<CellsCloudFileInfo>;

    public constructor(init?: Partial< SplitResult >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents style format condition.   
export class StyleFormatCondition  extends FormatCondition  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(StyleFormatCondition.attributeTypeMap) ;

    }


    public constructor(init?: Partial< StyleFormatCondition >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents data style collection.   
export class Styles  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "styleList",
            baseName: "StyleList",
            type: "Array<Style>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Styles.attributeTypeMap) ;

    }

    public styleList: Array<Style>;

    public constructor(init?: Partial< Styles >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents text format condition.   
export class TextFormatCondition  extends FormulaFormatCondition  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "text",
            baseName: "Text",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TextFormatCondition.attributeTypeMap) ;

    }

    public text: string;

    public constructor(init?: Partial< TextFormatCondition >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents text item collection.   
export class TextItems  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "textItemList",
            baseName: "TextItemList",
            type: "Array<TextItem>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TextItems.attributeTypeMap) ;

    }

    public textItemList: Array<TextItem>;

    public constructor(init?: Partial< TextItems >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///            Encapsulates the object that represents fill formatting for a shape.
///               
export class FillFormat  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "solidFill",
            baseName: "SolidFill",
            type: "SolidFill",
        },
        {
            name: "patternFill",
            baseName: "PatternFill",
            type: "PatternFill",
        },
        {
            name: "textureFill",
            baseName: "TextureFill",
            type: "TextureFill",
        },
        {
            name: "gradientFill",
            baseName: "GradientFill",
            type: "GradientFill",
        },
        {
            name: "imageData",
            baseName: "ImageData",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  FillFormat.attributeTypeMap;

    }

    public type: string;
    public solidFill: SolidFill;
    public patternFill: PatternFill;
    public textureFill: TextureFill;
    public gradientFill: GradientFill;
    public imageData: string;

    public constructor(init?: Partial< FillFormat >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents all setting of the line.   
export class LineFormat  extends FillFormat  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "beginArrowheadLength",
            baseName: "BeginArrowheadLength",
            type: "string",
        },
        {
            name: "beginArrowheadStyle",
            baseName: "BeginArrowheadStyle",
            type: "string",
        },
        {
            name: "beginArrowheadWidth",
            baseName: "BeginArrowheadWidth",
            type: "string",
        },
        {
            name: "capType",
            baseName: "CapType",
            type: "string",
        },
        {
            name: "compoundType",
            baseName: "CompoundType",
            type: "string",
        },
        {
            name: "dashStyle",
            baseName: "DashStyle",
            type: "string",
        },
        {
            name: "endArrowheadLength",
            baseName: "EndArrowheadLength",
            type: "string",
        },
        {
            name: "endArrowheadStyle",
            baseName: "EndArrowheadStyle",
            type: "string",
        },
        {
            name: "endArrowheadWidth",
            baseName: "EndArrowheadWidth",
            type: "string",
        },
        {
            name: "joinType",
            baseName: "JoinType",
            type: "string",
        },
        {
            name: "weight",
            baseName: "Weight",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LineFormat.attributeTypeMap) ;

    }

    public beginArrowheadLength: string;
    public beginArrowheadStyle: string;
    public beginArrowheadWidth: string;
    public capType: string;
    public compoundType: string;
    public dashStyle: string;
    public endArrowheadLength: string;
    public endArrowheadStyle: string;
    public endArrowheadWidth: string;
    public joinType: string;
    public weight: number;

    public constructor(init?: Partial< LineFormat >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///            This class specifies the shadow effect of the chart element or shape.
///               
export class ShadowEffect  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "angle",
            baseName: "Angle",
            type: "number",
        },
        {
            name: "blur",
            baseName: "Blur",
            type: "number",
        },
        {
            name: "color",
            baseName: "Color",
            type: "CellsColor",
        },
        {
            name: "distance",
            baseName: "Distance",
            type: "number",
        },
        {
            name: "presetType",
            baseName: "PresetType",
            type: "string",
        },
        {
            name: "size",
            baseName: "Size",
            type: "number",
        },
        {
            name: "transparency",
            baseName: "Transparency",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ShadowEffect.attributeTypeMap;

    }

    public angle: number;
    public blur: number;
    public color: CellsColor;
    public distance: number;
    public presetType: string;
    public size: number;
    public transparency: number;

    public constructor(init?: Partial< ShadowEffect >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents time period format condition.   
export class TimePeriodFormatCondition  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "timePeriod",
            baseName: "TimePeriod",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  TimePeriodFormatCondition.attributeTypeMap;

    }

    public timePeriod: string;

    public constructor(init?: Partial< TimePeriodFormatCondition >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents data validation.settings.   
export class Validation  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "alertStyle",
            baseName: "AlertStyle",
            type: "string",
        },
        {
            name: "areaList",
            baseName: "AreaList",
            type: "Array<CellArea>",
        },
        {
            name: "errorMessage",
            baseName: "ErrorMessage",
            type: "string",
        },
        {
            name: "errorTitle",
            baseName: "ErrorTitle",
            type: "string",
        },
        {
            name: "formula1",
            baseName: "Formula1",
            type: "string",
        },
        {
            name: "formula2",
            baseName: "Formula2",
            type: "string",
        },
        {
            name: "ignoreBlank",
            baseName: "IgnoreBlank",
            type: "boolean",
        },
        {
            name: "inCellDropDown",
            baseName: "InCellDropDown",
            type: "boolean",
        },
        {
            name: "inputMessage",
            baseName: "InputMessage",
            type: "string",
        },
        {
            name: "inputTitle",
            baseName: "InputTitle",
            type: "string",
        },
        {
            name: "operator",
            baseName: "Operator",
            type: "string",
        },
        {
            name: "showError",
            baseName: "ShowError",
            type: "boolean",
        },
        {
            name: "showInput",
            baseName: "ShowInput",
            type: "boolean",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "value1",
            baseName: "Value1",
            type: "string",
        },
        {
            name: "value2",
            baseName: "Value2",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Validation.attributeTypeMap) ;

    }

    public alertStyle: string;
    public areaList: Array<CellArea>;
    public errorMessage: string;
    public errorTitle: string;
    public formula1: string;
    public formula2: string;
    public ignoreBlank: boolean;
    public inCellDropDown: boolean;
    public inputMessage: string;
    public inputTitle: string;
    public operator: string;
    public showError: boolean;
    public showInput: boolean;
    public type: string;
    public value1: string;
    public value2: string;

    public constructor(init?: Partial< Validation >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents data validation collection.   
export class Validations  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "count",
            baseName: "Count",
            type: "number",
        },
        {
            name: "validationList",
            baseName: "ValidationList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Validations.attributeTypeMap) ;

    }

    public count: number;
    public validationList: Array<LinkElement>;

    public constructor(init?: Partial< Validations >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///            Encapsulates the object that represents a vertical page break.
///               
export class VerticalPageBreak  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "column",
            baseName: "Column",
            type: "number",
        },
        {
            name: "endRow",
            baseName: "EndRow",
            type: "number",
        },
        {
            name: "startRow",
            baseName: "StartRow",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  VerticalPageBreak.attributeTypeMap;

    }

    public column: number;
    public endRow: number;
    public startRow: number;

    public constructor(init?: Partial< VerticalPageBreak >) {  
    
        Object.assign(this, init);
    } 
}
/// Encapsulates a collection of  objects.   
export class VerticalPageBreaks  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(VerticalPageBreaks.attributeTypeMap) ;

    }


    public constructor(init?: Partial< VerticalPageBreaks >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Specifies write protection settings for a workbook.
///     
export class WriteProtection  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "author",
            baseName: "Author",
            type: "string",
        },
        {
            name: "recommendReadOnly",
            baseName: "RecommendReadOnly",
            type: "boolean",
        },
        {
            name: "isWriteProtected",
            baseName: "IsWriteProtected",
            type: "boolean",
        },
        {
            name: "password",
            baseName: "Password",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  WriteProtection.attributeTypeMap;

    }

    public author: string;
    public recommendReadOnly: boolean;
    public isWriteProtected: boolean;
    public password: string;

    public constructor(init?: Partial< WriteProtection >) {  
    
        Object.assign(this, init);
    } 
}
///            Represents all settings of the workbook.
///               
export class WorkbookSettings  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoCompressPictures",
            baseName: "AutoCompressPictures",
            type: "boolean",
        },
        {
            name: "autoRecover",
            baseName: "AutoRecover",
            type: "boolean",
        },
        {
            name: "buildVersion",
            baseName: "BuildVersion",
            type: "string",
        },
        {
            name: "calcMode",
            baseName: "CalcMode",
            type: "string",
        },
        {
            name: "calculationId",
            baseName: "CalculationId",
            type: "string",
        },
        {
            name: "checkComptiliblity",
            baseName: "CheckComptiliblity",
            type: "boolean",
        },
        {
            name: "checkExcelRestriction",
            baseName: "CheckExcelRestriction",
            type: "boolean",
        },
        {
            name: "crashSave",
            baseName: "CrashSave",
            type: "boolean",
        },
        {
            name: "createCalcChain",
            baseName: "CreateCalcChain",
            type: "boolean",
        },
        {
            name: "dataExtractLoad",
            baseName: "DataExtractLoad",
            type: "boolean",
        },
        {
            name: "date1904",
            baseName: "Date1904",
            type: "boolean",
        },
        {
            name: "displayDrawingObjects",
            baseName: "DisplayDrawingObjects",
            type: "string",
        },
        {
            name: "enableMacros",
            baseName: "EnableMacros",
            type: "boolean",
        },
        {
            name: "firstVisibleTab",
            baseName: "FirstVisibleTab",
            type: "number",
        },
        {
            name: "hidePivotFieldList",
            baseName: "HidePivotFieldList",
            type: "boolean",
        },
        {
            name: "isDefaultEncrypted",
            baseName: "IsDefaultEncrypted",
            type: "boolean",
        },
        {
            name: "isHidden",
            baseName: "IsHidden",
            type: "boolean",
        },
        {
            name: "isHScrollBarVisible",
            baseName: "IsHScrollBarVisible",
            type: "boolean",
        },
        {
            name: "isMinimized",
            baseName: "IsMinimized",
            type: "boolean",
        },
        {
            name: "isVScrollBarVisible",
            baseName: "IsVScrollBarVisible",
            type: "boolean",
        },
        {
            name: "iteration",
            baseName: "Iteration",
            type: "boolean",
        },
        {
            name: "languageCode",
            baseName: "LanguageCode",
            type: "string",
        },
        {
            name: "maxChange",
            baseName: "MaxChange",
            type: "number",
        },
        {
            name: "maxIteration",
            baseName: "MaxIteration",
            type: "number",
        },
        {
            name: "memorySetting",
            baseName: "MemorySetting",
            type: "string",
        },
        {
            name: "numberDecimalSeparator",
            baseName: "NumberDecimalSeparator",
            type: "string",
        },
        {
            name: "numberGroupSeparator",
            baseName: "NumberGroupSeparator",
            type: "string",
        },
        {
            name: "parsingFormulaOnOpen",
            baseName: "ParsingFormulaOnOpen",
            type: "boolean",
        },
        {
            name: "precisionAsDisplayed",
            baseName: "PrecisionAsDisplayed",
            type: "boolean",
        },
        {
            name: "recalculateBeforeSave",
            baseName: "RecalculateBeforeSave",
            type: "boolean",
        },
        {
            name: "reCalculateOnOpen",
            baseName: "ReCalculateOnOpen",
            type: "boolean",
        },
        {
            name: "recommendReadOnly",
            baseName: "RecommendReadOnly",
            type: "boolean",
        },
        {
            name: "region",
            baseName: "Region",
            type: "string",
        },
        {
            name: "removePersonalInformation",
            baseName: "RemovePersonalInformation",
            type: "boolean",
        },
        {
            name: "repairLoad",
            baseName: "RepairLoad",
            type: "boolean",
        },
        {
            name: "shared",
            baseName: "Shared",
            type: "boolean",
        },
        {
            name: "sheetTabBarWidth",
            baseName: "SheetTabBarWidth",
            type: "number",
        },
        {
            name: "showTabs",
            baseName: "ShowTabs",
            type: "boolean",
        },
        {
            name: "updateAdjacentCellsBorder",
            baseName: "UpdateAdjacentCellsBorder",
            type: "boolean",
        },
        {
            name: "updateLinksType",
            baseName: "UpdateLinksType",
            type: "string",
        },
        {
            name: "windowHeight",
            baseName: "WindowHeight",
            type: "number",
        },
        {
            name: "windowLeft",
            baseName: "WindowLeft",
            type: "number",
        },
        {
            name: "windowTop",
            baseName: "WindowTop",
            type: "number",
        },
        {
            name: "windowWidth",
            baseName: "WindowWidth",
            type: "number",
        },
        {
            name: "author",
            baseName: "Author",
            type: "string",
        },
        {
            name: "checkCustomNumberFormat",
            baseName: "CheckCustomNumberFormat",
            type: "boolean",
        },
        {
            name: "protectionType",
            baseName: "ProtectionType",
            type: "string",
        },
        {
            name: "globalizationSettings",
            baseName: "GlobalizationSettings",
            type: "GlobalizationSettings",
        },
        {
            name: "password",
            baseName: "Password",
            type: "string",
        },
        {
            name: "writeProtection",
            baseName: "WriteProtection",
            type: "WriteProtection",
        },
        {
            name: "isEncrypted",
            baseName: "IsEncrypted",
            type: "boolean",
        },
        {
            name: "isProtected",
            baseName: "IsProtected",
            type: "boolean",
        },
        {
            name: "maxRow",
            baseName: "MaxRow",
            type: "number",
        },
        {
            name: "maxColumn",
            baseName: "MaxColumn",
            type: "number",
        },
        {
            name: "significantDigits",
            baseName: "SignificantDigits",
            type: "number",
        },
        {
            name: "checkCompatibility",
            baseName: "CheckCompatibility",
            type: "boolean",
        },
        {
            name: "paperSize",
            baseName: "PaperSize",
            type: "string",
        },
        {
            name: "maxRowsOfSharedFormula",
            baseName: "MaxRowsOfSharedFormula",
            type: "number",
        },
        {
            name: "compliance",
            baseName: "Compliance",
            type: "string",
        },
        {
            name: "quotePrefixToStyle",
            baseName: "QuotePrefixToStyle",
            type: "boolean",
        },
        {
            name: "formulaSettings",
            baseName: "FormulaSettings",
            type: "FormulaSettings",
        },
        {
            name: "forceFullCalculate",
            baseName: "ForceFullCalculate",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  WorkbookSettings.attributeTypeMap;

    }

    public autoCompressPictures: boolean;
    public autoRecover: boolean;
    public buildVersion: string;
    public calcMode: string;
    public calculationId: string;
    public checkComptiliblity: boolean;
    public checkExcelRestriction: boolean;
    public crashSave: boolean;
    public createCalcChain: boolean;
    public dataExtractLoad: boolean;
    public date1904: boolean;
    public displayDrawingObjects: string;
    public enableMacros: boolean;
    public firstVisibleTab: number;
    public hidePivotFieldList: boolean;
    public isDefaultEncrypted: boolean;
    public isHidden: boolean;
    public isHScrollBarVisible: boolean;
    public isMinimized: boolean;
    public isVScrollBarVisible: boolean;
    public iteration: boolean;
    public languageCode: string;
    public maxChange: number;
    public maxIteration: number;
    public memorySetting: string;
    public numberDecimalSeparator: string;
    public numberGroupSeparator: string;
    public parsingFormulaOnOpen: boolean;
    public precisionAsDisplayed: boolean;
    public recalculateBeforeSave: boolean;
    public reCalculateOnOpen: boolean;
    public recommendReadOnly: boolean;
    public region: string;
    public removePersonalInformation: boolean;
    public repairLoad: boolean;
    public shared: boolean;
    public sheetTabBarWidth: number;
    public showTabs: boolean;
    public updateAdjacentCellsBorder: boolean;
    public updateLinksType: string;
    public windowHeight: number;
    public windowLeft: number;
    public windowTop: number;
    public windowWidth: number;
    public author: string;
    public checkCustomNumberFormat: boolean;
    public protectionType: string;
    public globalizationSettings: GlobalizationSettings;
    public password: string;
    public writeProtection: WriteProtection;
    public isEncrypted: boolean;
    public isProtected: boolean;
    public maxRow: number;
    public maxColumn: number;
    public significantDigits: number;
    public checkCompatibility: boolean;
    public paperSize: string;
    public maxRowsOfSharedFormula: number;
    public compliance: string;
    public quotePrefixToStyle: boolean;
    public formulaSettings: FormulaSettings;
    public forceFullCalculate: boolean;

    public constructor(init?: Partial< WorkbookSettings >) {  
    
        Object.assign(this, init);
    } 
}
///            Encapsulates the object that represents a single worksheet.
///               
export class Worksheet  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "links",
            baseName: "Links",
            type: "Array<Link>",
        },
        {
            name: "displayRightToLeft",
            baseName: "DisplayRightToLeft",
            type: "boolean",
        },
        {
            name: "displayZeros",
            baseName: "DisplayZeros",
            type: "boolean",
        },
        {
            name: "firstVisibleColumn",
            baseName: "FirstVisibleColumn",
            type: "number",
        },
        {
            name: "firstVisibleRow",
            baseName: "FirstVisibleRow",
            type: "number",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "index",
            baseName: "Index",
            type: "number",
        },
        {
            name: "isGridlinesVisible",
            baseName: "IsGridlinesVisible",
            type: "boolean",
        },
        {
            name: "isOutlineShown",
            baseName: "IsOutlineShown",
            type: "boolean",
        },
        {
            name: "isPageBreakPreview",
            baseName: "IsPageBreakPreview",
            type: "boolean",
        },
        {
            name: "isVisible",
            baseName: "IsVisible",
            type: "boolean",
        },
        {
            name: "isProtected",
            baseName: "IsProtected",
            type: "boolean",
        },
        {
            name: "isRowColumnHeadersVisible",
            baseName: "IsRowColumnHeadersVisible",
            type: "boolean",
        },
        {
            name: "isRulerVisible",
            baseName: "IsRulerVisible",
            type: "boolean",
        },
        {
            name: "isSelected",
            baseName: "IsSelected",
            type: "boolean",
        },
        {
            name: "tabColor",
            baseName: "TabColor",
            type: "Color",
        },
        {
            name: "transitionEntry",
            baseName: "TransitionEntry",
            type: "boolean",
        },
        {
            name: "transitionEvaluation",
            baseName: "TransitionEvaluation",
            type: "boolean",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "viewType",
            baseName: "ViewType",
            type: "string",
        },
        {
            name: "visibilityType",
            baseName: "VisibilityType",
            type: "string",
        },
        {
            name: "zoom",
            baseName: "Zoom",
            type: "number",
        },
        {
            name: "cells",
            baseName: "Cells",
            type: "LinkElement",
        },
        {
            name: "charts",
            baseName: "Charts",
            type: "LinkElement",
        },
        {
            name: "autoShapes",
            baseName: "AutoShapes",
            type: "LinkElement",
        },
        {
            name: "oleObjects",
            baseName: "OleObjects",
            type: "LinkElement",
        },
        {
            name: "comments",
            baseName: "Comments",
            type: "LinkElement",
        },
        {
            name: "pictures",
            baseName: "Pictures",
            type: "LinkElement",
        },
        {
            name: "mergedCells",
            baseName: "MergedCells",
            type: "LinkElement",
        },
        {
            name: "validations",
            baseName: "Validations",
            type: "LinkElement",
        },
        {
            name: "conditionalFormattings",
            baseName: "ConditionalFormattings",
            type: "LinkElement",
        },
        {
            name: "hyperlinks",
            baseName: "Hyperlinks",
            type: "LinkElement",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Worksheet.attributeTypeMap;

    }

    public links: Array<Link>;
    public displayRightToLeft: boolean;
    public displayZeros: boolean;
    public firstVisibleColumn: number;
    public firstVisibleRow: number;
    public name: string;
    public index: number;
    public isGridlinesVisible: boolean;
    public isOutlineShown: boolean;
    public isPageBreakPreview: boolean;
    public isVisible: boolean;
    public isProtected: boolean;
    public isRowColumnHeadersVisible: boolean;
    public isRulerVisible: boolean;
    public isSelected: boolean;
    public tabColor: Color;
    public transitionEntry: boolean;
    public transitionEvaluation: boolean;
    public type: string;
    public viewType: string;
    public visibilityType: string;
    public zoom: number;
    public cells: LinkElement;
    public charts: LinkElement;
    public autoShapes: LinkElement;
    public oleObjects: LinkElement;
    public comments: LinkElement;
    public pictures: LinkElement;
    public mergedCells: LinkElement;
    public validations: LinkElement;
    public conditionalFormattings: LinkElement;
    public hyperlinks: LinkElement;

    public constructor(init?: Partial< Worksheet >) {  
    
        Object.assign(this, init);
    } 
}
/// Encapsulates a collection of  objects.   
export class Worksheets  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "worksheetList",
            baseName: "WorksheetList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Worksheets.attributeTypeMap) ;

    }

    public worksheetList: Array<LinkElement>;

    public constructor(init?: Partial< Worksheets >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents Xml Data Binding information.
///     
export class XmlDataBinding  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "url",
            baseName: "Url",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  XmlDataBinding.attributeTypeMap;

    }

    public url: string;

    public constructor(init?: Partial< XmlDataBinding >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents Xml map information.
///     
export class XmlMap  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "rootElementName",
            baseName: "RootElementName",
            type: "string",
        },
        {
            name: "dataBinding",
            baseName: "DataBinding",
            type: "XmlDataBinding",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  XmlMap.attributeTypeMap;

    }

    public name: string;
    public rootElementName: string;
    public dataBinding: XmlDataBinding;

    public constructor(init?: Partial< XmlMap >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents task parameter.   
export class TaskParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  TaskParameter.attributeTypeMap;

    }


    public constructor(init?: Partial< TaskParameter >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents operate object.   
export class OperateObject  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "operateObjectType",
            baseName: "OperateObjectType",
            type: "string",
        },
        {
            name: "position",
            baseName: "Position",
            type: "OperateObjectPosition",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  OperateObject.attributeTypeMap;

    }

    public operateObjectType: string;
    public position: OperateObjectPosition;

    public constructor(init?: Partial< OperateObject >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents operate parameter.   
export class OperateParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "operateType",
            baseName: "OperateType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  OperateParameter.attributeTypeMap;

    }

    public operateType: string;

    public constructor(init?: Partial< OperateParameter >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents cells object operate task parameter.   
export class CellsObjectOperateTaskParameter  extends TaskParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "operateObject",
            baseName: "OperateObject",
            type: "OperateObject",
        },
        {
            name: "operateParameter",
            baseName: "OperateParameter",
            type: "OperateParameter",
        },
        {
            name: "destinationDataSource",
            baseName: "DestinationDataSource",
            type: "DataSource",
        },
        {
            name: "destinationWorkbook",
            baseName: "DestinationWorkbook",
            type: "FileSource",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CellsObjectOperateTaskParameter.attributeTypeMap) ;

    }

    public operateObject: OperateObject;
    public operateParameter: OperateParameter;
    public destinationDataSource: DataSource;
    public destinationWorkbook: FileSource;

    public constructor(init?: Partial< CellsObjectOperateTaskParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents convert task parameter.   
export class ConvertTaskParameter  extends TaskParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "workbook",
            baseName: "Workbook",
            type: "FileSource",
        },
        {
            name: "destinationFile",
            baseName: "DestinationFile",
            type: "string",
        },
        {
            name: "region",
            baseName: "Region",
            type: "string",
        },
        {
            name: "saveOptions",
            baseName: "SaveOptions",
            type: "SaveOptions",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ConvertTaskParameter.attributeTypeMap) ;

    }

    public dataSource: DataSource;
    public workbook: FileSource;
    public destinationFile: string;
    public region: string;
    public saveOptions: SaveOptions;

    public constructor(init?: Partial< ConvertTaskParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents convert worksheet task parameter.   
export class ConvertWorksheetTaskParameter  extends TaskParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "workbook",
            baseName: "Workbook",
            type: "FileSource",
        },
        {
            name: "sheet",
            baseName: "Sheet",
            type: "string",
        },
        {
            name: "targetDataSource",
            baseName: "TargetDataSource",
            type: "DataSource",
        },
        {
            name: "target",
            baseName: "Target",
            type: "FileSource",
        },
        {
            name: "format",
            baseName: "Format",
            type: "string",
        },
        {
            name: "area",
            baseName: "Area",
            type: "string",
        },
        {
            name: "pageIndex",
            baseName: "PageIndex",
            type: "number",
        },
        {
            name: "verticalResolution",
            baseName: "VerticalResolution",
            type: "number",
        },
        {
            name: "horizontalResolution",
            baseName: "HorizontalResolution",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ConvertWorksheetTaskParameter.attributeTypeMap) ;

    }

    public dataSource: DataSource;
    public workbook: FileSource;
    public sheet: string;
    public targetDataSource: DataSource;
    public target: FileSource;
    public format: string;
    public area: string;
    public pageIndex: number;
    public verticalResolution: number;
    public horizontalResolution: number;

    public constructor(init?: Partial< ConvertWorksheetTaskParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Class Summary: This class covers the features of artificial intelligence, machine learning, deep learning, and natural language processing.   
export class ImportOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "destinationWorksheet",
            baseName: "DestinationWorksheet",
            type: "string",
        },
        {
            name: "isInsert",
            baseName: "IsInsert",
            type: "boolean",
        },
        {
            name: "importDataType",
            baseName: "ImportDataType",
            type: "string",
        },
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "source",
            baseName: "Source",
            type: "FileSource",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ImportOption.attributeTypeMap;

    }

    public destinationWorksheet: string;
    public isInsert: boolean;
    public importDataType: string;
    public dataSource: DataSource;
    public source: FileSource;

    public constructor(init?: Partial< ImportOption >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents import data task parameter.   
export class ImportDataTaskParameter  extends TaskParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "workbook",
            baseName: "Workbook",
            type: "FileSource",
        },
        {
            name: "importOption",
            baseName: "ImportOption",
            type: "ImportOption",
        },
        {
            name: "targetDataSource",
            baseName: "TargetDataSource",
            type: "DataSource",
        },
        {
            name: "destinationWorkbook",
            baseName: "DestinationWorkbook",
            type: "FileSource",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImportDataTaskParameter.attributeTypeMap) ;

    }

    public dataSource: DataSource;
    public workbook: FileSource;
    public importOption: ImportOption;
    public targetDataSource: DataSource;
    public destinationWorkbook: FileSource;

    public constructor(init?: Partial< ImportDataTaskParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents result destination.   
export class ResultDestination  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "destinationType",
            baseName: "DestinationType",
            type: "string",
        },
        {
            name: "inputFile",
            baseName: "InputFile",
            type: "string",
        },
        {
            name: "outputFile",
            baseName: "OutputFile",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ResultDestination.attributeTypeMap;

    }

    public destinationType: string;
    public inputFile: string;
    public outputFile: string;

    public constructor(init?: Partial< ResultDestination >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents task run result.   
export class TaskRunResult  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "description",
            baseName: "Description",
            type: "string",
        },
        {
            name: "outFileList",
            baseName: "OutFileList",
            type: "Array<DataSource>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  TaskRunResult.attributeTypeMap;

    }

    public description: string;
    public outFileList: Array<DataSource>;

    public constructor(init?: Partial< TaskRunResult >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents save file to cloud result.   
export class SaveFilesToCloudResult  extends TaskRunResult  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "savedFiles",
            baseName: "SavedFiles",
            type: "Array<Link>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SaveFilesToCloudResult.attributeTypeMap) ;

    }

    public savedFiles: Array<Link>;

    public constructor(init?: Partial< SaveFilesToCloudResult >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents save result task parameter.   
export class SaveResultTaskParameter  extends TaskParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "resultSource",
            baseName: "ResultSource",
            type: "string",
        },
        {
            name: "resultDestination",
            baseName: "ResultDestination",
            type: "ResultDestination",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SaveResultTaskParameter.attributeTypeMap) ;

    }

    public resultSource: string;
    public resultDestination: ResultDestination;

    public constructor(init?: Partial< SaveResultTaskParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents smart marker task parameter.   
export class SmartMarkerTaskParameter  extends TaskParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sourceWorkbook",
            baseName: "SourceWorkbook",
            type: "FileSource",
        },
        {
            name: "destinationWorkbook",
            baseName: "DestinationWorkbook",
            type: "FileSource",
        },
        {
            name: "xmlFile",
            baseName: "xmlFile",
            type: "FileSource",
        },
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "targetDataSource",
            baseName: "TargetDataSource",
            type: "DataSource",
        },
        {
            name: "xMLFileDataSource",
            baseName: "XMLFileDataSource",
            type: "DataSource",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SmartMarkerTaskParameter.attributeTypeMap) ;

    }

    public sourceWorkbook: FileSource;
    public destinationWorkbook: FileSource;
    public xmlFile: FileSource;
    public dataSource: DataSource;
    public targetDataSource: DataSource;
    public xMLFileDataSource: DataSource;

    public constructor(init?: Partial< SmartMarkerTaskParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents split workbook task parameter.   
export class SplitWorkbookTaskParameter  extends TaskParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "workbook",
            baseName: "Workbook",
            type: "FileSource",
        },
        {
            name: "destinationFilePosition",
            baseName: "DestinationFilePosition",
            type: "FileSource",
        },
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "targetDataSource",
            baseName: "TargetDataSource",
            type: "DataSource",
        },
        {
            name: "destinationFileFormat",
            baseName: "DestinationFileFormat",
            type: "string",
        },
        {
            name: "splitNameRule",
            baseName: "SplitNameRule",
            type: "string",
        },
        {
            name: "verticalResolution",
            baseName: "VerticalResolution",
            type: "number",
        },
        {
            name: "horizontalResolution",
            baseName: "HorizontalResolution",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SplitWorkbookTaskParameter.attributeTypeMap) ;

    }

    public workbook: FileSource;
    public destinationFilePosition: FileSource;
    public dataSource: DataSource;
    public targetDataSource: DataSource;
    public destinationFileFormat: string;
    public splitNameRule: string;
    public verticalResolution: number;
    public horizontalResolution: number;

    public constructor(init?: Partial< SplitWorkbookTaskParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents task description.   
export class TaskDescription  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "taskType",
            baseName: "TaskType",
            type: "string",
        },
        {
            name: "taskParameter",
            baseName: "TaskParameter",
            type: "TaskParameter",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  TaskDescription.attributeTypeMap;

    }

    public taskType: string;
    public taskParameter: TaskParameter;

    public constructor(init?: Partial< TaskDescription >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents task data.   
export class TaskData  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "tasks",
            baseName: "Tasks",
            type: "Array<TaskDescription>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  TaskData.attributeTypeMap;

    }

    public tasks: Array<TaskDescription>;

    public constructor(init?: Partial< TaskData >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents task result parameter.   
export class TaskResultParameter  extends TaskParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TaskResultParameter.attributeTypeMap) ;

    }


    public constructor(init?: Partial< TaskResultParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents chart operate parameter.   
export class ChartOperateParameter  extends OperateParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "chartIndex",
            baseName: "ChartIndex",
            type: "number",
        },
        {
            name: "chartType",
            baseName: "ChartType",
            type: "string",
        },
        {
            name: "upperLeftRow",
            baseName: "UpperLeftRow",
            type: "number",
        },
        {
            name: "upperLeftColumn",
            baseName: "UpperLeftColumn",
            type: "number",
        },
        {
            name: "lowerRightRow",
            baseName: "LowerRightRow",
            type: "number",
        },
        {
            name: "lowerRightColumn",
            baseName: "LowerRightColumn",
            type: "number",
        },
        {
            name: "area",
            baseName: "Area",
            type: "string",
        },
        {
            name: "isVertical",
            baseName: "IsVertical",
            type: "boolean",
        },
        {
            name: "categoryData",
            baseName: "CategoryData",
            type: "string",
        },
        {
            name: "isAutoGetSerialName",
            baseName: "IsAutoGetSerialName",
            type: "boolean",
        },
        {
            name: "title",
            baseName: "Title",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartOperateParameter.attributeTypeMap) ;

    }

    public chartIndex: number;
    public chartType: string;
    public upperLeftRow: number;
    public upperLeftColumn: number;
    public lowerRightRow: number;
    public lowerRightColumn: number;
    public area: string;
    public isVertical: boolean;
    public categoryData: string;
    public isAutoGetSerialName: boolean;
    public title: string;

    public constructor(init?: Partial< ChartOperateParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents a list object on a worksheet.            The ListObject object is a member of the ListObjects collection.             The ListObjects collection contains all the list objects on a worksheet.   
export class ListObject  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoFilter",
            baseName: "AutoFilter",
            type: "AutoFilter",
        },
        {
            name: "displayName",
            baseName: "DisplayName",
            type: "string",
        },
        {
            name: "startColumn",
            baseName: "StartColumn",
            type: "number",
        },
        {
            name: "startRow",
            baseName: "StartRow",
            type: "number",
        },
        {
            name: "endColumn",
            baseName: "EndColumn",
            type: "number",
        },
        {
            name: "endRow",
            baseName: "EndRow",
            type: "number",
        },
        {
            name: "listColumns",
            baseName: "ListColumns",
            type: "Array<ListColumn>",
        },
        {
            name: "showHeaderRow",
            baseName: "ShowHeaderRow",
            type: "boolean",
        },
        {
            name: "showTableStyleColumnStripes",
            baseName: "ShowTableStyleColumnStripes",
            type: "boolean",
        },
        {
            name: "showTableStyleFirstColumn",
            baseName: "ShowTableStyleFirstColumn",
            type: "boolean",
        },
        {
            name: "showTableStyleLastColumn",
            baseName: "ShowTableStyleLastColumn",
            type: "boolean",
        },
        {
            name: "showTableStyleRowStripes",
            baseName: "ShowTableStyleRowStripes",
            type: "boolean",
        },
        {
            name: "showTotals",
            baseName: "ShowTotals",
            type: "boolean",
        },
        {
            name: "tableStyleName",
            baseName: "TableStyleName",
            type: "string",
        },
        {
            name: "tableStyleType",
            baseName: "TableStyleType",
            type: "string",
        },
        {
            name: "dataRange",
            baseName: "DataRange",
            type: "Range",
        },
        {
            name: "dataSourceType",
            baseName: "DataSourceType",
            type: "string",
        },
        {
            name: "comment",
            baseName: "Comment",
            type: "string",
        },
        {
            name: "xmlMap",
            baseName: "XmlMap",
            type: "XmlMap",
        },
        {
            name: "alternativeText",
            baseName: "AlternativeText",
            type: "string",
        },
        {
            name: "alternativeDescription",
            baseName: "AlternativeDescription",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ListObject.attributeTypeMap) ;

    }

    public autoFilter: AutoFilter;
    public displayName: string;
    public startColumn: number;
    public startRow: number;
    public endColumn: number;
    public endRow: number;
    public listColumns: Array<ListColumn>;
    public showHeaderRow: boolean;
    public showTableStyleColumnStripes: boolean;
    public showTableStyleFirstColumn: boolean;
    public showTableStyleLastColumn: boolean;
    public showTableStyleRowStripes: boolean;
    public showTotals: boolean;
    public tableStyleName: string;
    public tableStyleType: string;
    public dataRange: Range;
    public dataSourceType: string;
    public comment: string;
    public xmlMap: XmlMap;
    public alternativeText: string;
    public alternativeDescription: string;

    public constructor(init?: Partial< ListObject >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents list object operate parameter.   
export class ListObjectOperateParameter  extends OperateParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "listObject",
            baseName: "ListObject",
            type: "ListObject",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ListObjectOperateParameter.attributeTypeMap) ;

    }

    public listObject: ListObject;

    public constructor(init?: Partial< ListObjectOperateParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents operate object position.   
export class OperateObjectPosition  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "workbook",
            baseName: "Workbook",
            type: "FileSource",
        },
        {
            name: "sheetName",
            baseName: "SheetName",
            type: "string",
        },
        {
            name: "chartIndex",
            baseName: "ChartIndex",
            type: "number",
        },
        {
            name: "shapeIndex",
            baseName: "ShapeIndex",
            type: "number",
        },
        {
            name: "cellName",
            baseName: "CellName",
            type: "string",
        },
        {
            name: "listObjectIndex",
            baseName: "ListObjectIndex",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  OperateObjectPosition.attributeTypeMap;

    }

    public dataSource: DataSource;
    public workbook: FileSource;
    public sheetName: string;
    public chartIndex: number;
    public shapeIndex: number;
    public cellName: string;
    public listObjectIndex: number;

    public constructor(init?: Partial< OperateObjectPosition >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents page break operate parameter.   
export class PageBreakOperateParameter  extends OperateParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pageBreakType",
            baseName: "PageBreakType",
            type: "string",
        },
        {
            name: "index",
            baseName: "Index",
            type: "number",
        },
        {
            name: "row",
            baseName: "Row",
            type: "number",
        },
        {
            name: "column",
            baseName: "Column",
            type: "number",
        },
        {
            name: "startIndex",
            baseName: "StartIndex",
            type: "number",
        },
        {
            name: "endIndex",
            baseName: "EndIndex",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PageBreakOperateParameter.attributeTypeMap) ;

    }

    public pageBreakType: string;
    public index: number;
    public row: number;
    public column: number;
    public startIndex: number;
    public endIndex: number;

    public constructor(init?: Partial< PageBreakOperateParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents page setup operate parameter.   
export class PageSetupOperateParameter  extends OperateParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pageSetup",
            baseName: "PageSetup",
            type: "PageSetup",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PageSetupOperateParameter.attributeTypeMap) ;

    }

    public pageSetup: PageSetup;

    public constructor(init?: Partial< PageSetupOperateParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents pivot table operate parameter.   
export class PivotTableOperateParameter  extends OperateParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sourceData",
            baseName: "SourceData",
            type: "string",
        },
        {
            name: "destCellName",
            baseName: "DestCellName",
            type: "string",
        },
        {
            name: "tableName",
            baseName: "TableName",
            type: "string",
        },
        {
            name: "useSameSource",
            baseName: "UseSameSource",
            type: "boolean",
        },
        {
            name: "pivotTableIndex",
            baseName: "PivotTableIndex",
            type: "number",
        },
        {
            name: "pivotFieldRows",
            baseName: "PivotFieldRows",
            type: "Array<number>",
        },
        {
            name: "pivotFieldColumns",
            baseName: "PivotFieldColumns",
            type: "Array<number>",
        },
        {
            name: "pivotFieldData",
            baseName: "PivotFieldData",
            type: "Array<number>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PivotTableOperateParameter.attributeTypeMap) ;

    }

    public sourceData: string;
    public destCellName: string;
    public tableName: string;
    public useSameSource: boolean;
    public pivotTableIndex: number;
    public pivotFieldRows: Array<number>;
    public pivotFieldColumns: Array<number>;
    public pivotFieldData: Array<number>;

    public constructor(init?: Partial< PivotTableOperateParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the msodrawing object.   
export class Shape  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "msoDrawingType",
            baseName: "MsoDrawingType",
            type: "string",
        },
        {
            name: "autoShapeType",
            baseName: "AutoShapeType",
            type: "string",
        },
        {
            name: "placement",
            baseName: "Placement",
            type: "string",
        },
        {
            name: "upperLeftRow",
            baseName: "UpperLeftRow",
            type: "number",
        },
        {
            name: "top",
            baseName: "Top",
            type: "number",
        },
        {
            name: "upperLeftColumn",
            baseName: "UpperLeftColumn",
            type: "number",
        },
        {
            name: "left",
            baseName: "Left",
            type: "number",
        },
        {
            name: "lowerRightRow",
            baseName: "LowerRightRow",
            type: "number",
        },
        {
            name: "bottom",
            baseName: "Bottom",
            type: "number",
        },
        {
            name: "lowerRightColumn",
            baseName: "LowerRightColumn",
            type: "number",
        },
        {
            name: "right",
            baseName: "Right",
            type: "number",
        },
        {
            name: "width",
            baseName: "Width",
            type: "number",
        },
        {
            name: "height",
            baseName: "Height",
            type: "number",
        },
        {
            name: "x",
            baseName: "X",
            type: "number",
        },
        {
            name: "y",
            baseName: "Y",
            type: "number",
        },
        {
            name: "rotationAngle",
            baseName: "RotationAngle",
            type: "number",
        },
        {
            name: "htmlText",
            baseName: "HtmlText",
            type: "string",
        },
        {
            name: "text",
            baseName: "Text",
            type: "string",
        },
        {
            name: "alternativeText",
            baseName: "AlternativeText",
            type: "string",
        },
        {
            name: "textHorizontalAlignment",
            baseName: "TextHorizontalAlignment",
            type: "string",
        },
        {
            name: "textHorizontalOverflow",
            baseName: "TextHorizontalOverflow",
            type: "string",
        },
        {
            name: "textOrientationType",
            baseName: "TextOrientationType",
            type: "string",
        },
        {
            name: "textVerticalAlignment",
            baseName: "TextVerticalAlignment",
            type: "string",
        },
        {
            name: "textVerticalOverflow",
            baseName: "TextVerticalOverflow",
            type: "string",
        },
        {
            name: "isGroup",
            baseName: "IsGroup",
            type: "boolean",
        },
        {
            name: "isHidden",
            baseName: "IsHidden",
            type: "boolean",
        },
        {
            name: "isLockAspectRatio",
            baseName: "IsLockAspectRatio",
            type: "boolean",
        },
        {
            name: "isLocked",
            baseName: "IsLocked",
            type: "boolean",
        },
        {
            name: "isPrintable",
            baseName: "IsPrintable",
            type: "boolean",
        },
        {
            name: "isTextWrapped",
            baseName: "IsTextWrapped",
            type: "boolean",
        },
        {
            name: "isWordArt",
            baseName: "IsWordArt",
            type: "boolean",
        },
        {
            name: "linkedCell",
            baseName: "LinkedCell",
            type: "string",
        },
        {
            name: "zOrderPosition",
            baseName: "ZOrderPosition",
            type: "number",
        },
        {
            name: "font",
            baseName: "Font",
            type: "Font",
        },
        {
            name: "hyperlink",
            baseName: "Hyperlink",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Shape.attributeTypeMap) ;

    }

    public name: string;
    public msoDrawingType: string;
    public autoShapeType: string;
    public placement: string;
    public upperLeftRow: number;
    public top: number;
    public upperLeftColumn: number;
    public left: number;
    public lowerRightRow: number;
    public bottom: number;
    public lowerRightColumn: number;
    public right: number;
    public width: number;
    public height: number;
    public x: number;
    public y: number;
    public rotationAngle: number;
    public htmlText: string;
    public text: string;
    public alternativeText: string;
    public textHorizontalAlignment: string;
    public textHorizontalOverflow: string;
    public textOrientationType: string;
    public textVerticalAlignment: string;
    public textVerticalOverflow: string;
    public isGroup: boolean;
    public isHidden: boolean;
    public isLockAspectRatio: boolean;
    public isLocked: boolean;
    public isPrintable: boolean;
    public isTextWrapped: boolean;
    public isWordArt: boolean;
    public linkedCell: string;
    public zOrderPosition: number;
    public font: Font;
    public hyperlink: string;

    public constructor(init?: Partial< Shape >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents shape operate parameter.   
export class ShapeOperateParameter  extends OperateParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "Shape",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ShapeOperateParameter.attributeTypeMap) ;

    }

    public shape: Shape;

    public constructor(init?: Partial< ShapeOperateParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents workbook operate parameter.   
export class WorkbookOperateParameter  extends OperateParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WorkbookOperateParameter.attributeTypeMap) ;

    }


    public constructor(init?: Partial< WorkbookOperateParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents workbook setting operate parameter.   
export class WorkbookSettingsOperateParameter  extends OperateParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "workbookSettings",
            baseName: "WorkbookSettings",
            type: "WorkbookSettings",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WorkbookSettingsOperateParameter.attributeTypeMap) ;

    }

    public workbookSettings: WorkbookSettings;

    public constructor(init?: Partial< WorkbookSettingsOperateParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Used by workbook moving requests.   
export class WorksheetMovingRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "destinationWorksheet",
            baseName: "DestinationWorksheet",
            type: "string",
        },
        {
            name: "position",
            baseName: "Position",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  WorksheetMovingRequest.attributeTypeMap;

    }

    public destinationWorksheet: string;
    public position: string;

    public constructor(init?: Partial< WorksheetMovingRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents worksheet operate parameter.   
export class WorksheetOperateParameter  extends OperateParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "sheetType",
            baseName: "SheetType",
            type: "string",
        },
        {
            name: "newName",
            baseName: "NewName",
            type: "string",
        },
        {
            name: "movingRequest",
            baseName: "MovingRequest",
            type: "WorksheetMovingRequest",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WorksheetOperateParameter.attributeTypeMap) ;

    }

    public name: string;
    public sheetType: string;
    public newName: string;
    public movingRequest: WorksheetMovingRequest;

    public constructor(init?: Partial< WorksheetOperateParameter >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///            Represents a column in a Table.
///               
export class ListColumn  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "range",
            baseName: "Range",
            type: "Range",
        },
        {
            name: "totalsCalculation",
            baseName: "TotalsCalculation",
            type: "string",
        },
        {
            name: "formula",
            baseName: "Formula",
            type: "string",
        },
        {
            name: "totalsRowLabel",
            baseName: "TotalsRowLabel",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ListColumn.attributeTypeMap;

    }

    public name: string;
    public range: Range;
    public totalsCalculation: string;
    public formula: string;
    public totalsRowLabel: string;

    public constructor(init?: Partial< ListColumn >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents a collection of  objects in the worksheet.   
export class ListObjects  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "listObjectList",
            baseName: "ListObjectList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ListObjects.attributeTypeMap) ;

    }

    public listObjectList: Array<LinkElement>;

    public constructor(init?: Partial< ListObjects >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the arc shape.   
export class ArcShape  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "beginArrowheadLength",
            baseName: "BeginArrowheadLength",
            type: "string",
        },
        {
            name: "beginArrowheadStyle",
            baseName: "BeginArrowheadStyle",
            type: "string",
        },
        {
            name: "beginArrowheadWidth",
            baseName: "BeginArrowheadWidth",
            type: "string",
        },
        {
            name: "endArrowheadLength",
            baseName: "EndArrowheadLength",
            type: "string",
        },
        {
            name: "endArrowheadStyle",
            baseName: "EndArrowheadStyle",
            type: "string",
        },
        {
            name: "endArrowheadWidth",
            baseName: "EndArrowheadWidth",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ArcShape.attributeTypeMap) ;

    }

    public beginArrowheadLength: string;
    public beginArrowheadStyle: string;
    public beginArrowheadWidth: string;
    public endArrowheadLength: string;
    public endArrowheadStyle: string;
    public endArrowheadWidth: string;

    public constructor(init?: Partial< ArcShape >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the ArcShape Response.   
export class ArcShapeResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "ArcShape",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ArcShapeResponse.attributeTypeMap) ;

    }

    public shape: ArcShape;

    public constructor(init?: Partial< ArcShapeResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the AutoFilter Response.   
export class AutoFilterResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoFilter",
            baseName: "AutoFilter",
            type: "AutoFilter",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(AutoFilterResponse.attributeTypeMap) ;

    }

    public autoFilter: AutoFilter;

    public constructor(init?: Partial< AutoFilterResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents an AutoShape.   
export class AutoShape  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(AutoShape.attributeTypeMap) ;

    }


    public constructor(init?: Partial< AutoShape >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the AutoShape Response.   
export class AutoShapeResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoShape",
            baseName: "AutoShape",
            type: "AutoShape",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(AutoShapeResponse.attributeTypeMap) ;

    }

    public autoShape: AutoShape;

    public constructor(init?: Partial< AutoShapeResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Sure! Just provide me with the features you would like me to summarize into one sentence.   
export class AutoShapes  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoShapeList",
            baseName: "AutoShapeList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(AutoShapes.attributeTypeMap) ;

    }

    public autoShapeList: Array<LinkElement>;

    public constructor(init?: Partial< AutoShapes >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the AutoShapes Response.   
export class AutoShapesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoShapes",
            baseName: "AutoShapes",
            type: "AutoShapes",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(AutoShapesResponse.attributeTypeMap) ;

    }

    public autoShapes: AutoShapes;

    public constructor(init?: Partial< AutoShapesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates the object that represents an axis of chart.   
export class Axis  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "area",
            baseName: "Area",
            type: "Area",
        },
        {
            name: "axisBetweenCategories",
            baseName: "AxisBetweenCategories",
            type: "boolean",
        },
        {
            name: "axisLine",
            baseName: "AxisLine",
            type: "Line",
        },
        {
            name: "baseUnitScale",
            baseName: "BaseUnitScale",
            type: "string",
        },
        {
            name: "categoryType",
            baseName: "CategoryType",
            type: "string",
        },
        {
            name: "crossAt",
            baseName: "CrossAt",
            type: "number",
        },
        {
            name: "crossType",
            baseName: "CrossType",
            type: "string",
        },
        {
            name: "displayUnit",
            baseName: "DisplayUnit",
            type: "string",
        },
        {
            name: "displayUnitLabel",
            baseName: "DisplayUnitLabel",
            type: "DisplayUnitLabel",
        },
        {
            name: "hasMultiLevelLabels",
            baseName: "HasMultiLevelLabels",
            type: "boolean",
        },
        {
            name: "isAutomaticMajorUnit",
            baseName: "IsAutomaticMajorUnit",
            type: "boolean",
        },
        {
            name: "isAutomaticMaxValue",
            baseName: "IsAutomaticMaxValue",
            type: "boolean",
        },
        {
            name: "isAutomaticMinorUnit",
            baseName: "IsAutomaticMinorUnit",
            type: "boolean",
        },
        {
            name: "isAutomaticMinValue",
            baseName: "IsAutomaticMinValue",
            type: "boolean",
        },
        {
            name: "isDisplayUnitLabelShown",
            baseName: "IsDisplayUnitLabelShown",
            type: "boolean",
        },
        {
            name: "isLogarithmic",
            baseName: "IsLogarithmic",
            type: "boolean",
        },
        {
            name: "isPlotOrderReversed",
            baseName: "IsPlotOrderReversed",
            type: "boolean",
        },
        {
            name: "isVisible",
            baseName: "IsVisible",
            type: "boolean",
        },
        {
            name: "logBase",
            baseName: "LogBase",
            type: "number",
        },
        {
            name: "majorGridLines",
            baseName: "MajorGridLines",
            type: "Line",
        },
        {
            name: "majorTickMark",
            baseName: "MajorTickMark",
            type: "string",
        },
        {
            name: "majorUnit",
            baseName: "MajorUnit",
            type: "number",
        },
        {
            name: "majorUnitScale",
            baseName: "MajorUnitScale",
            type: "string",
        },
        {
            name: "maxValue",
            baseName: "MaxValue",
            type: "number",
        },
        {
            name: "minorGridLines",
            baseName: "MinorGridLines",
            type: "Line",
        },
        {
            name: "minorTickMark",
            baseName: "MinorTickMark",
            type: "string",
        },
        {
            name: "minorUnit",
            baseName: "MinorUnit",
            type: "number",
        },
        {
            name: "minorUnitScale",
            baseName: "MinorUnitScale",
            type: "string",
        },
        {
            name: "minValue",
            baseName: "MinValue",
            type: "number",
        },
        {
            name: "tickLabelPosition",
            baseName: "TickLabelPosition",
            type: "string",
        },
        {
            name: "tickLabels",
            baseName: "TickLabels",
            type: "TickLabels",
        },
        {
            name: "tickLabelSpacing",
            baseName: "TickLabelSpacing",
            type: "number",
        },
        {
            name: "tickMarkSpacing",
            baseName: "TickMarkSpacing",
            type: "number",
        },
        {
            name: "title",
            baseName: "Title",
            type: "Title",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Axis.attributeTypeMap) ;

    }

    public area: Area;
    public axisBetweenCategories: boolean;
    public axisLine: Line;
    public baseUnitScale: string;
    public categoryType: string;
    public crossAt: number;
    public crossType: string;
    public displayUnit: string;
    public displayUnitLabel: DisplayUnitLabel;
    public hasMultiLevelLabels: boolean;
    public isAutomaticMajorUnit: boolean;
    public isAutomaticMaxValue: boolean;
    public isAutomaticMinorUnit: boolean;
    public isAutomaticMinValue: boolean;
    public isDisplayUnitLabelShown: boolean;
    public isLogarithmic: boolean;
    public isPlotOrderReversed: boolean;
    public isVisible: boolean;
    public logBase: number;
    public majorGridLines: Line;
    public majorTickMark: string;
    public majorUnit: number;
    public majorUnitScale: string;
    public maxValue: number;
    public minorGridLines: Line;
    public minorTickMark: string;
    public minorUnit: number;
    public minorUnitScale: string;
    public minValue: number;
    public tickLabelPosition: string;
    public tickLabels: TickLabels;
    public tickLabelSpacing: number;
    public tickMarkSpacing: number;
    public title: Title;

    public constructor(init?: Partial< Axis >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Axis Response.   
export class AxisResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "axis",
            baseName: "Axis",
            type: "Axis",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(AxisResponse.attributeTypeMap) ;

    }

    public axis: Axis;

    public constructor(init?: Partial< AxisResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Border Response.   
export class BorderResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "border",
            baseName: "Border",
            type: "Border",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(BorderResponse.attributeTypeMap) ;

    }

    public border: Border;

    public constructor(init?: Partial< BorderResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Forms control: Button   
export class Button  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Button.attributeTypeMap) ;

    }


    public constructor(init?: Partial< Button >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Button Response.   
export class ButtonResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "Button",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ButtonResponse.attributeTypeMap) ;

    }

    public shape: Button;

    public constructor(init?: Partial< ButtonResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the CalculateFormula Response.   
export class CalculateFormulaResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "result",
            baseName: "Result",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CalculateFormulaResponse.attributeTypeMap) ;

    }

    public result: string;

    public constructor(init?: Partial< CalculateFormulaResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Cell Response.   
export class CellResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "cell",
            baseName: "Cell",
            type: "Cell",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CellResponse.attributeTypeMap) ;

    }

    public cell: Cell;

    public constructor(init?: Partial< CellResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the CellsDocumentProperties Response.   
export class CellsDocumentPropertiesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "documentProperties",
            baseName: "DocumentProperties",
            type: "CellsDocumentProperties",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CellsDocumentPropertiesResponse.attributeTypeMap) ;

    }

    public documentProperties: CellsDocumentProperties;

    public constructor(init?: Partial< CellsDocumentPropertiesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the CellsDocumentProperty Response.   
export class CellsDocumentPropertyResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "documentProperty",
            baseName: "DocumentProperty",
            type: "CellsDocumentProperty",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CellsDocumentPropertyResponse.attributeTypeMap) ;

    }

    public documentProperty: CellsDocumentProperty;

    public constructor(init?: Partial< CellsDocumentPropertyResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the auto shape and drawing object.   
export class CellsDrawing  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CellsDrawing.attributeTypeMap) ;

    }


    public constructor(init?: Partial< CellsDrawing >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the CellsDrawing Response.   
export class CellsDrawingResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "CellsDrawing",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CellsDrawingResponse.attributeTypeMap) ;

    }

    public shape: CellsDrawing;

    public constructor(init?: Partial< CellsDrawingResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Cells Response.   
export class CellsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "cells",
            baseName: "Cells",
            type: "Cells",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CellsResponse.attributeTypeMap) ;

    }

    public cells: Cells;

    public constructor(init?: Partial< CellsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///            Encapsulates the object that represents the frame object in a chart.
///               
export class ChartFrame  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "area",
            baseName: "Area",
            type: "Area",
        },
        {
            name: "autoScaleFont",
            baseName: "AutoScaleFont",
            type: "boolean",
        },
        {
            name: "backgroundMode",
            baseName: "BackgroundMode",
            type: "string",
        },
        {
            name: "border",
            baseName: "Border",
            type: "Line",
        },
        {
            name: "font",
            baseName: "Font",
            type: "Font",
        },
        {
            name: "isAutomaticSize",
            baseName: "IsAutomaticSize",
            type: "boolean",
        },
        {
            name: "isInnerMode",
            baseName: "IsInnerMode",
            type: "boolean",
        },
        {
            name: "shadow",
            baseName: "Shadow",
            type: "boolean",
        },
        {
            name: "width",
            baseName: "Width",
            type: "number",
        },
        {
            name: "height",
            baseName: "Height",
            type: "number",
        },
        {
            name: "x",
            baseName: "X",
            type: "number",
        },
        {
            name: "y",
            baseName: "Y",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ChartFrame.attributeTypeMap;

    }

    public area: Area;
    public autoScaleFont: boolean;
    public backgroundMode: string;
    public border: Line;
    public font: Font;
    public isAutomaticSize: boolean;
    public isInnerMode: boolean;
    public shadow: boolean;
    public width: number;
    public height: number;
    public x: number;
    public y: number;

    public constructor(init?: Partial< ChartFrame >) {  
    
        Object.assign(this, init);
    } 
}
/// Encapsulates the object that represents the chart area in the worksheet.   
export class ChartArea  extends ChartFrame  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartArea.attributeTypeMap) ;

    }


    public constructor(init?: Partial< ChartArea >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the ChartArea Response.   
export class ChartAreaResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "chartArea",
            baseName: "ChartArea",
            type: "ChartArea",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartAreaResponse.attributeTypeMap) ;

    }

    public chartArea: ChartArea;

    public constructor(init?: Partial< ChartAreaResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents a chart data table.   
export class ChartDataTable  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoScaleFont",
            baseName: "AutoScaleFont",
            type: "boolean",
        },
        {
            name: "backgroundMode",
            baseName: "BackgroundMode",
            type: "string",
        },
        {
            name: "border",
            baseName: "Border",
            type: "Line",
        },
        {
            name: "font",
            baseName: "Font",
            type: "Font",
        },
        {
            name: "hasBorderHorizontal",
            baseName: "HasBorderHorizontal",
            type: "boolean",
        },
        {
            name: "hasBorderOutline",
            baseName: "HasBorderOutline",
            type: "boolean",
        },
        {
            name: "hasBorderVertical",
            baseName: "HasBorderVertical",
            type: "boolean",
        },
        {
            name: "showLegendKey",
            baseName: "ShowLegendKey",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartDataTable.attributeTypeMap) ;

    }

    public autoScaleFont: boolean;
    public backgroundMode: string;
    public border: Line;
    public font: Font;
    public hasBorderHorizontal: boolean;
    public hasBorderOutline: boolean;
    public hasBorderVertical: boolean;
    public showLegendKey: boolean;

    public constructor(init?: Partial< ChartDataTable >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the ChartDataTable Response.   
export class ChartDataTableResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "chartDataTable",
            baseName: "ChartDataTable",
            type: "ChartDataTable",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartDataTableResponse.attributeTypeMap) ;

    }

    public chartDataTable: ChartDataTable;

    public constructor(init?: Partial< ChartDataTableResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents a single point in a series in a chart.   
export class ChartPoint  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "area",
            baseName: "Area",
            type: "Area",
        },
        {
            name: "border",
            baseName: "Border",
            type: "Line",
        },
        {
            name: "dataLabels",
            baseName: "DataLabels",
            type: "DataLabels",
        },
        {
            name: "explosion",
            baseName: "Explosion",
            type: "number",
        },
        {
            name: "marker",
            baseName: "Marker",
            type: "Marker",
        },
        {
            name: "shadow",
            baseName: "Shadow",
            type: "boolean",
        },
        {
            name: "xValue",
            baseName: "XValue",
            type: "Object",
        },
        {
            name: "yValue",
            baseName: "YValue",
            type: "Object",
        },
        {
            name: "isInSecondaryPlot",
            baseName: "IsInSecondaryPlot",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartPoint.attributeTypeMap) ;

    }

    public area: Area;
    public border: Line;
    public dataLabels: DataLabels;
    public explosion: number;
    public marker: Marker;
    public shadow: boolean;
    public xValue: Object;
    public yValue: Object;
    public isInSecondaryPlot: boolean;

    public constructor(init?: Partial< ChartPoint >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the ChartPoint Response.   
export class ChartPointResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "chartPoint",
            baseName: "ChartPoint",
            type: "ChartPoint",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartPointResponse.attributeTypeMap) ;

    }

    public chartPoint: ChartPoint;

    public constructor(init?: Partial< ChartPointResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents a collection that contains all the points in one series.   
export class ChartPoints  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "chartPointList",
            baseName: "ChartPointList",
            type: "Array<ChartPoint>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartPoints.attributeTypeMap) ;

    }

    public chartPointList: Array<ChartPoint>;

    public constructor(init?: Partial< ChartPoints >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the ChartPoints Response.   
export class ChartPointsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "chartPoints",
            baseName: "ChartPoints",
            type: "ChartPoints",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartPointsResponse.attributeTypeMap) ;

    }

    public chartPoints: ChartPoints;

    public constructor(init?: Partial< ChartPointsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates the object that represents a single Excel chart.   
export class Chart  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoScaling",
            baseName: "AutoScaling",
            type: "boolean",
        },
        {
            name: "backWall",
            baseName: "BackWall",
            type: "Walls",
        },
        {
            name: "categoryAxis",
            baseName: "CategoryAxis",
            type: "Axis",
        },
        {
            name: "chartArea",
            baseName: "ChartArea",
            type: "ChartArea",
        },
        {
            name: "chartDataTable",
            baseName: "ChartDataTable",
            type: "ChartDataTable",
        },
        {
            name: "chartObject",
            baseName: "ChartObject",
            type: "LinkElement",
        },
        {
            name: "depthPercent",
            baseName: "DepthPercent",
            type: "number",
        },
        {
            name: "elevation",
            baseName: "Elevation",
            type: "number",
        },
        {
            name: "firstSliceAngle",
            baseName: "FirstSliceAngle",
            type: "number",
        },
        {
            name: "floor",
            baseName: "Floor",
            type: "Floor",
        },
        {
            name: "gapDepth",
            baseName: "GapDepth",
            type: "number",
        },
        {
            name: "gapWidth",
            baseName: "GapWidth",
            type: "number",
        },
        {
            name: "heightPercent",
            baseName: "HeightPercent",
            type: "number",
        },
        {
            name: "hidePivotFieldButtons",
            baseName: "HidePivotFieldButtons",
            type: "boolean",
        },
        {
            name: "is3D",
            baseName: "Is3D",
            type: "boolean",
        },
        {
            name: "isRectangularCornered",
            baseName: "IsRectangularCornered",
            type: "boolean",
        },
        {
            name: "legend",
            baseName: "Legend",
            type: "Legend",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "nSeries",
            baseName: "NSeries",
            type: "SeriesItems",
        },
        {
            name: "pageSetup",
            baseName: "PageSetup",
            type: "LinkElement",
        },
        {
            name: "perspective",
            baseName: "Perspective",
            type: "number",
        },
        {
            name: "pivotSource",
            baseName: "PivotSource",
            type: "string",
        },
        {
            name: "placement",
            baseName: "Placement",
            type: "string",
        },
        {
            name: "plotArea",
            baseName: "PlotArea",
            type: "PlotArea",
        },
        {
            name: "plotEmptyCellsType",
            baseName: "PlotEmptyCellsType",
            type: "string",
        },
        {
            name: "plotVisibleCells",
            baseName: "PlotVisibleCells",
            type: "boolean",
        },
        {
            name: "printSize",
            baseName: "PrintSize",
            type: "string",
        },
        {
            name: "rightAngleAxes",
            baseName: "RightAngleAxes",
            type: "boolean",
        },
        {
            name: "rotationAngle",
            baseName: "RotationAngle",
            type: "number",
        },
        {
            name: "secondCategoryAxis",
            baseName: "SecondCategoryAxis",
            type: "LinkElement",
        },
        {
            name: "secondValueAxis",
            baseName: "SecondValueAxis",
            type: "LinkElement",
        },
        {
            name: "seriesAxis",
            baseName: "SeriesAxis",
            type: "LinkElement",
        },
        {
            name: "shapes",
            baseName: "Shapes",
            type: "LinkElement",
        },
        {
            name: "showDataTable",
            baseName: "ShowDataTable",
            type: "boolean",
        },
        {
            name: "showLegend",
            baseName: "ShowLegend",
            type: "boolean",
        },
        {
            name: "sideWall",
            baseName: "SideWall",
            type: "LinkElement",
        },
        {
            name: "sizeWithWindow",
            baseName: "SizeWithWindow",
            type: "boolean",
        },
        {
            name: "style",
            baseName: "Style",
            type: "number",
        },
        {
            name: "title",
            baseName: "Title",
            type: "LinkElement",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "valueAxis",
            baseName: "ValueAxis",
            type: "Axis",
        },
        {
            name: "walls",
            baseName: "Walls",
            type: "LinkElement",
        },
        {
            name: "wallsAndGridlines2D",
            baseName: "WallsAndGridlines2D",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Chart.attributeTypeMap) ;

    }

    public autoScaling: boolean;
    public backWall: Walls;
    public categoryAxis: Axis;
    public chartArea: ChartArea;
    public chartDataTable: ChartDataTable;
    public chartObject: LinkElement;
    public depthPercent: number;
    public elevation: number;
    public firstSliceAngle: number;
    public floor: Floor;
    public gapDepth: number;
    public gapWidth: number;
    public heightPercent: number;
    public hidePivotFieldButtons: boolean;
    public is3D: boolean;
    public isRectangularCornered: boolean;
    public legend: Legend;
    public name: string;
    public nSeries: SeriesItems;
    public pageSetup: LinkElement;
    public perspective: number;
    public pivotSource: string;
    public placement: string;
    public plotArea: PlotArea;
    public plotEmptyCellsType: string;
    public plotVisibleCells: boolean;
    public printSize: string;
    public rightAngleAxes: boolean;
    public rotationAngle: number;
    public secondCategoryAxis: LinkElement;
    public secondValueAxis: LinkElement;
    public seriesAxis: LinkElement;
    public shapes: LinkElement;
    public showDataTable: boolean;
    public showLegend: boolean;
    public sideWall: LinkElement;
    public sizeWithWindow: boolean;
    public style: number;
    public title: LinkElement;
    public type: string;
    public valueAxis: Axis;
    public walls: LinkElement;
    public wallsAndGridlines2D: boolean;

    public constructor(init?: Partial< Chart >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Chart Response.   
export class ChartResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "chart",
            baseName: "Chart",
            type: "Chart",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartResponse.attributeTypeMap) ;

    }

    public chart: Chart;

    public constructor(init?: Partial< ChartResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates a collection of  objects.   
export class Charts  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "chartList",
            baseName: "ChartList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Charts.attributeTypeMap) ;

    }

    public chartList: Array<LinkElement>;

    public constructor(init?: Partial< Charts >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Charts Response.   
export class ChartsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "charts",
            baseName: "Charts",
            type: "Charts",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartsResponse.attributeTypeMap) ;

    }

    public charts: Charts;

    public constructor(init?: Partial< ChartsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents a check box object in a worksheet.   
export class CheckBox  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "checkedValue",
            baseName: "CheckedValue",
            type: "string",
        },
        {
            name: "shadow",
            baseName: "Shadow",
            type: "boolean",
        },
        {
            name: "value",
            baseName: "Value",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CheckBox.attributeTypeMap) ;

    }

    public checkedValue: string;
    public shadow: boolean;
    public value: boolean;

    public constructor(init?: Partial< CheckBox >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the CheckBox Response.   
export class CheckBoxResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "CheckBox",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CheckBoxResponse.attributeTypeMap) ;

    }

    public shape: CheckBox;

    public constructor(init?: Partial< CheckBoxResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class CheckedExternalReferenceResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "referenceOtherWorkbook",
            baseName: "ReferenceOtherWorkbook",
            type: "boolean",
        },
        {
            name: "referenceOtherWorksheet",
            baseName: "ReferenceOtherWorksheet",
            type: "boolean",
        },
        {
            name: "formulas",
            baseName: "Formulas",
            type: "Array<string>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CheckedExternalReferenceResponse.attributeTypeMap) ;

    }

    public referenceOtherWorkbook: boolean;
    public referenceOtherWorksheet: boolean;
    public formulas: Array<string>;

    public constructor(init?: Partial< CheckedExternalReferenceResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///    
export class CheckedFormulaErrorsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "isFormulasErrors",
            baseName: "IsFormulasErrors",
            type: "boolean",
        },
        {
            name: "formulasErrors",
            baseName: "FormulasErrors",
            type: "Array<string>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CheckedFormulaErrorsResponse.attributeTypeMap) ;

    }

    public isFormulasErrors: boolean;
    public formulasErrors: Array<string>;

    public constructor(init?: Partial< CheckedFormulaErrorsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Column Response.   
export class ColumnResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "column",
            baseName: "Column",
            type: "Column",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ColumnResponse.attributeTypeMap) ;

    }

    public column: Column;

    public constructor(init?: Partial< ColumnResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Columns Response.   
export class ColumnsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "columns",
            baseName: "Columns",
            type: "Columns",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ColumnsResponse.attributeTypeMap) ;

    }

    public columns: Columns;

    public constructor(init?: Partial< ColumnsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the control form ComboBox.   
export class ComboBox  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dropDownLines",
            baseName: "DropDownLines",
            type: "number",
        },
        {
            name: "inputRange",
            baseName: "InputRange",
            type: "string",
        },
        {
            name: "selectedCell",
            baseName: "SelectedCell",
            type: "LinkElement",
        },
        {
            name: "selectedIndex",
            baseName: "SelectedIndex",
            type: "number",
        },
        {
            name: "selectedValue",
            baseName: "SelectedValue",
            type: "string",
        },
        {
            name: "shadow",
            baseName: "Shadow",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ComboBox.attributeTypeMap) ;

    }

    public dropDownLines: number;
    public inputRange: string;
    public selectedCell: LinkElement;
    public selectedIndex: number;
    public selectedValue: string;
    public shadow: boolean;

    public constructor(init?: Partial< ComboBox >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the ComboBox Response.   
export class ComboBoxResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "ComboBox",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ComboBoxResponse.attributeTypeMap) ;

    }

    public shape: ComboBox;

    public constructor(init?: Partial< ComboBoxResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Comment Response.   
export class CommentResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "comment",
            baseName: "Comment",
            type: "Comment",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CommentResponse.attributeTypeMap) ;

    }

    public comment: Comment;

    public constructor(init?: Partial< CommentResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the shape of the comment.   
export class CommentShape  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "comment",
            baseName: "Comment",
            type: "LinkElement",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CommentShape.attributeTypeMap) ;

    }

    public comment: LinkElement;

    public constructor(init?: Partial< CommentShape >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the CommentShape Response.   
export class CommentShapeResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "comment",
            baseName: "Comment",
            type: "CommentShape",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CommentShapeResponse.attributeTypeMap) ;

    }

    public comment: CommentShape;

    public constructor(init?: Partial< CommentShapeResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Comments Response.   
export class CommentsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "comments",
            baseName: "Comments",
            type: "Comments",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(CommentsResponse.attributeTypeMap) ;

    }

    public comments: Comments;

    public constructor(init?: Partial< CommentsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the ConditionalFormatting Response.   
export class ConditionalFormattingResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "conditionalFormatting",
            baseName: "ConditionalFormatting",
            type: "ConditionalFormatting",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ConditionalFormattingResponse.attributeTypeMap) ;

    }

    public conditionalFormatting: ConditionalFormatting;

    public constructor(init?: Partial< ConditionalFormattingResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the ConditionalFormattings Response.   
export class ConditionalFormattingsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "conditionalFormattings",
            baseName: "ConditionalFormattings",
            type: "ConditionalFormattings",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ConditionalFormattingsResponse.attributeTypeMap) ;

    }

    public conditionalFormattings: ConditionalFormattings;

    public constructor(init?: Partial< ConditionalFormattingsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates a collection of all the DataLabel objects for the specified Series.   
export class DataLabels  extends ChartFrame  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "isAutoText",
            baseName: "IsAutoText",
            type: "boolean",
        },
        {
            name: "isDeleted",
            baseName: "IsDeleted",
            type: "boolean",
        },
        {
            name: "linkedSource",
            baseName: "LinkedSource",
            type: "string",
        },
        {
            name: "number",
            baseName: "Number",
            type: "number",
        },
        {
            name: "numberFormat",
            baseName: "NumberFormat",
            type: "string",
        },
        {
            name: "numberFormatLinked",
            baseName: "NumberFormatLinked",
            type: "boolean",
        },
        {
            name: "position",
            baseName: "Position",
            type: "string",
        },
        {
            name: "rotationAngle",
            baseName: "RotationAngle",
            type: "number",
        },
        {
            name: "separator",
            baseName: "Separator",
            type: "string",
        },
        {
            name: "showBubbleSize",
            baseName: "ShowBubbleSize",
            type: "boolean",
        },
        {
            name: "showCategoryName",
            baseName: "ShowCategoryName",
            type: "boolean",
        },
        {
            name: "showLegendKey",
            baseName: "ShowLegendKey",
            type: "boolean",
        },
        {
            name: "showPercentage",
            baseName: "ShowPercentage",
            type: "boolean",
        },
        {
            name: "showSeriesName",
            baseName: "ShowSeriesName",
            type: "boolean",
        },
        {
            name: "showValue",
            baseName: "ShowValue",
            type: "boolean",
        },
        {
            name: "text",
            baseName: "Text",
            type: "string",
        },
        {
            name: "textDirection",
            baseName: "TextDirection",
            type: "string",
        },
        {
            name: "textHorizontalAlignment",
            baseName: "TextHorizontalAlignment",
            type: "string",
        },
        {
            name: "textVerticalAlignment",
            baseName: "TextVerticalAlignment",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DataLabels.attributeTypeMap) ;

    }

    public isAutoText: boolean;
    public isDeleted: boolean;
    public linkedSource: string;
    public number: number;
    public numberFormat: string;
    public numberFormatLinked: boolean;
    public position: string;
    public rotationAngle: number;
    public separator: string;
    public showBubbleSize: boolean;
    public showCategoryName: boolean;
    public showLegendKey: boolean;
    public showPercentage: boolean;
    public showSeriesName: boolean;
    public showValue: boolean;
    public text: string;
    public textDirection: string;
    public textHorizontalAlignment: string;
    public textVerticalAlignment: string;

    public constructor(init?: Partial< DataLabels >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the DataLabels Response.   
export class DataLabelsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataLabels",
            baseName: "DataLabels",
            type: "DataLabels",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DataLabelsResponse.attributeTypeMap) ;

    }

    public dataLabels: DataLabels;

    public constructor(init?: Partial< DataLabelsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the display unit label.   
export class DisplayUnitLabel  extends ChartFrame  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "linkedSource",
            baseName: "LinkedSource",
            type: "string",
        },
        {
            name: "rotationAngle",
            baseName: "RotationAngle",
            type: "number",
        },
        {
            name: "text",
            baseName: "Text",
            type: "string",
        },
        {
            name: "textHorizontalAlignment",
            baseName: "TextHorizontalAlignment",
            type: "string",
        },
        {
            name: "textVerticalAlignment",
            baseName: "TextVerticalAlignment",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DisplayUnitLabel.attributeTypeMap) ;

    }

    public linkedSource: string;
    public rotationAngle: number;
    public text: string;
    public textHorizontalAlignment: string;
    public textVerticalAlignment: string;

    public constructor(init?: Partial< DisplayUnitLabel >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the DisplayUnitLabel Response.   
export class DisplayUnitLabelResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "displayUnitLabel",
            baseName: "DisplayUnitLabel",
            type: "DisplayUnitLabel",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DisplayUnitLabelResponse.attributeTypeMap) ;

    }

    public displayUnitLabel: DisplayUnitLabel;

    public constructor(init?: Partial< DisplayUnitLabelResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the up/down bars in a chart.   
export class DropBars  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "area",
            baseName: "Area",
            type: "Area",
        },
        {
            name: "border",
            baseName: "Border",
            type: "Line",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DropBars.attributeTypeMap) ;

    }

    public area: Area;
    public border: Line;

    public constructor(init?: Partial< DropBars >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the DropBars Response.   
export class DropBarsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dropBars",
            baseName: "DropBars",
            type: "DropBars",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(DropBarsResponse.attributeTypeMap) ;

    }

    public dropBars: DropBars;

    public constructor(init?: Partial< DropBarsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates the object that represents the line format.   
export class Line  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "beginArrowLength",
            baseName: "BeginArrowLength",
            type: "string",
        },
        {
            name: "beginArrowWidth",
            baseName: "BeginArrowWidth",
            type: "string",
        },
        {
            name: "beginType",
            baseName: "BeginType",
            type: "string",
        },
        {
            name: "capType",
            baseName: "CapType",
            type: "string",
        },
        {
            name: "color",
            baseName: "Color",
            type: "Color",
        },
        {
            name: "compoundType",
            baseName: "CompoundType",
            type: "string",
        },
        {
            name: "dashType",
            baseName: "DashType",
            type: "string",
        },
        {
            name: "endArrowLength",
            baseName: "EndArrowLength",
            type: "string",
        },
        {
            name: "endArrowWidth",
            baseName: "EndArrowWidth",
            type: "string",
        },
        {
            name: "endType",
            baseName: "EndType",
            type: "string",
        },
        {
            name: "gradientFill",
            baseName: "GradientFill",
            type: "GradientFill",
        },
        {
            name: "isAuto",
            baseName: "IsAuto",
            type: "boolean",
        },
        {
            name: "isAutomaticColor",
            baseName: "IsAutomaticColor",
            type: "boolean",
        },
        {
            name: "isVisible",
            baseName: "IsVisible",
            type: "boolean",
        },
        {
            name: "joinType",
            baseName: "JoinType",
            type: "string",
        },
        {
            name: "style",
            baseName: "Style",
            type: "string",
        },
        {
            name: "transparency",
            baseName: "Transparency",
            type: "number",
        },
        {
            name: "weight",
            baseName: "Weight",
            type: "string",
        },
        {
            name: "weightPt",
            baseName: "WeightPt",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Line.attributeTypeMap;

    }

    public beginArrowLength: string;
    public beginArrowWidth: string;
    public beginType: string;
    public capType: string;
    public color: Color;
    public compoundType: string;
    public dashType: string;
    public endArrowLength: string;
    public endArrowWidth: string;
    public endType: string;
    public gradientFill: GradientFill;
    public isAuto: boolean;
    public isAutomaticColor: boolean;
    public isVisible: boolean;
    public joinType: string;
    public style: string;
    public transparency: number;
    public weight: string;
    public weightPt: number;

    public constructor(init?: Partial< Line >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents error bar of data series.   
export class ErrorBar  extends Line  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "link",
            baseName: "Link",
            type: "Link",
        },
        {
            name: "amount",
            baseName: "Amount",
            type: "number",
        },
        {
            name: "displayType",
            baseName: "DisplayType",
            type: "string",
        },
        {
            name: "minusValue",
            baseName: "MinusValue",
            type: "string",
        },
        {
            name: "plusValue",
            baseName: "PlusValue",
            type: "string",
        },
        {
            name: "showMarkerTTop",
            baseName: "ShowMarkerTTop",
            type: "boolean",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ErrorBar.attributeTypeMap) ;

    }

    public link: Link;
    public amount: number;
    public displayType: string;
    public minusValue: string;
    public plusValue: string;
    public showMarkerTTop: boolean;
    public type: string;

    public constructor(init?: Partial< ErrorBar >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the ErrorBar Response.   
export class ErrorBarResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "errorBar",
            baseName: "ErrorBar",
            type: "ErrorBar",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ErrorBarResponse.attributeTypeMap) ;

    }

    public errorBar: ErrorBar;

    public constructor(init?: Partial< ErrorBarResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the FillFormat Response.   
export class FillFormatResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "fillFormat",
            baseName: "FillFormat",
            type: "FillFormat",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FillFormatResponse.attributeTypeMap) ;

    }

    public fillFormat: FillFormat;

    public constructor(init?: Partial< FillFormatResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Find Response.   
export class FindResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "count",
            baseName: "Count",
            type: "number",
        },
        {
            name: "textItems",
            baseName: "TextItems",
            type: "TextItems",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FindResponse.attributeTypeMap) ;

    }

    public count: number;
    public textItems: TextItems;

    public constructor(init?: Partial< FindResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///            Encapsulates the object that represents an area format.
///               
export class Area  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "backgroundColor",
            baseName: "BackgroundColor",
            type: "Color",
        },
        {
            name: "fillFormat",
            baseName: "FillFormat",
            type: "FillFormat",
        },
        {
            name: "foregroundColor",
            baseName: "ForegroundColor",
            type: "Color",
        },
        {
            name: "format",
            baseName: "Format",
            type: "string",
        },
        {
            name: "invertIfNegative",
            baseName: "InvertIfNegative",
            type: "boolean",
        },
        {
            name: "transparency",
            baseName: "Transparency",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Area.attributeTypeMap;

    }

    public backgroundColor: Color;
    public fillFormat: FillFormat;
    public foregroundColor: Color;
    public format: string;
    public invertIfNegative: boolean;
    public transparency: number;

    public constructor(init?: Partial< Area >) {  
    
        Object.assign(this, init);
    } 
}
/// Encapsulates the object that represents the floor of a 3-D chart.   
export class Floor  extends Area  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "border",
            baseName: "Border",
            type: "Line",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Floor.attributeTypeMap) ;

    }

    public border: Line;

    public constructor(init?: Partial< Floor >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Floor Response.   
export class FloorResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "floor",
            baseName: "Floor",
            type: "Floor",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FloorResponse.attributeTypeMap) ;

    }

    public floor: Floor;

    public constructor(init?: Partial< FloorResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// I'm happy to help! Please provide the features you would like me to summarize into one sentence for the class.   
export class Form  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "formType",
            baseName: "FormType",
            type: "string",
        },
        {
            name: "checkedValue",
            baseName: "CheckedValue",
            type: "string",
        },
        {
            name: "shadow",
            baseName: "Shadow",
            type: "boolean",
        },
        {
            name: "inputRange",
            baseName: "InputRange",
            type: "string",
        },
        {
            name: "selectedIndex",
            baseName: "SelectedIndex",
            type: "number",
        },
        {
            name: "selectedValue",
            baseName: "SelectedValue",
            type: "string",
        },
        {
            name: "selectedCell",
            baseName: "SelectedCell",
            type: "LinkElement",
        },
        {
            name: "dropDownLines",
            baseName: "DropDownLines",
            type: "number",
        },
        {
            name: "itemCount",
            baseName: "ItemCount",
            type: "number",
        },
        {
            name: "selectedCells",
            baseName: "SelectedCells",
            type: "Array<LinkElement>",
        },
        {
            name: "selectionType",
            baseName: "SelectionType",
            type: "string",
        },
        {
            name: "isChecked",
            baseName: "IsChecked",
            type: "boolean",
        },
        {
            name: "currentValue",
            baseName: "CurrentValue",
            type: "number",
        },
        {
            name: "min",
            baseName: "Min",
            type: "number",
        },
        {
            name: "max",
            baseName: "Max",
            type: "number",
        },
        {
            name: "incrementalChange",
            baseName: "IncrementalChange",
            type: "number",
        },
        {
            name: "pageChange",
            baseName: "PageChange",
            type: "number",
        },
        {
            name: "isHorizontal",
            baseName: "IsHorizontal",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Form.attributeTypeMap) ;

    }

    public formType: string;
    public checkedValue: string;
    public shadow: boolean;
    public inputRange: string;
    public selectedIndex: number;
    public selectedValue: string;
    public selectedCell: LinkElement;
    public dropDownLines: number;
    public itemCount: number;
    public selectedCells: Array<LinkElement>;
    public selectionType: string;
    public isChecked: boolean;
    public currentValue: number;
    public min: number;
    public max: number;
    public incrementalChange: number;
    public pageChange: number;
    public isHorizontal: boolean;

    public constructor(init?: Partial< Form >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Form Response.   
export class FormResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "form",
            baseName: "Form",
            type: "Form",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FormResponse.attributeTypeMap) ;

    }

    public form: Form;

    public constructor(init?: Partial< FormResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// "Summary: The class covers a range of features including advanced machine learning techniques, statistical analysis tools, and computer vision algorithms."   
export class Forms  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "formList",
            baseName: "FormList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Forms.attributeTypeMap) ;

    }

    public formList: Array<LinkElement>;

    public constructor(init?: Partial< Forms >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Forms Response.   
export class FormsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "forms",
            baseName: "Forms",
            type: "Forms",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(FormsResponse.attributeTypeMap) ;

    }

    public forms: Forms;

    public constructor(init?: Partial< FormsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates the object that represents a groupbox in a spreadsheet.   
export class GroupBox  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shadow",
            baseName: "Shadow",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(GroupBox.attributeTypeMap) ;

    }

    public shadow: boolean;

    public constructor(init?: Partial< GroupBox >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the GroupBox Response.   
export class GroupBoxResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "GroupBox",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(GroupBoxResponse.attributeTypeMap) ;

    }

    public shape: GroupBox;

    public constructor(init?: Partial< GroupBoxResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the HorizontalPageBreak Response.   
export class HorizontalPageBreakResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "horizontalPageBreak",
            baseName: "HorizontalPageBreak",
            type: "HorizontalPageBreak",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(HorizontalPageBreakResponse.attributeTypeMap) ;

    }

    public horizontalPageBreak: HorizontalPageBreak;

    public constructor(init?: Partial< HorizontalPageBreakResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the HorizontalPageBreaks Response.   
export class HorizontalPageBreaksResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "horizontalPageBreaks",
            baseName: "HorizontalPageBreaks",
            type: "HorizontalPageBreaks",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(HorizontalPageBreaksResponse.attributeTypeMap) ;

    }

    public horizontalPageBreaks: HorizontalPageBreaks;

    public constructor(init?: Partial< HorizontalPageBreaksResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Hyperlink Response.   
export class HyperlinkResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "hyperlink",
            baseName: "Hyperlink",
            type: "Hyperlink",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(HyperlinkResponse.attributeTypeMap) ;

    }

    public hyperlink: Hyperlink;

    public constructor(init?: Partial< HyperlinkResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Hyperlinks Response.   
export class HyperlinksResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "hyperlinks",
            baseName: "Hyperlinks",
            type: "Hyperlinks",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(HyperlinksResponse.attributeTypeMap) ;

    }

    public hyperlinks: Hyperlinks;

    public constructor(init?: Partial< HyperlinksResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates the object that represents a label in a spreadsheet.   
export class Label  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Label.attributeTypeMap) ;

    }


    public constructor(init?: Partial< Label >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Label Response.   
export class LabelResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "Label",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LabelResponse.attributeTypeMap) ;

    }

    public shape: Label;

    public constructor(init?: Partial< LabelResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Sure, please provide me with the features you would like me to summarize in one sentence for the class summary.   
export class LegendEntries  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "legendEntryList",
            baseName: "legendEntryList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LegendEntries.attributeTypeMap) ;

    }

    public legendEntryList: Array<LinkElement>;

    public constructor(init?: Partial< LegendEntries >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the LegendEntries Response.   
export class LegendEntriesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "legendEntries",
            baseName: "LegendEntries",
            type: "LegendEntries",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LegendEntriesResponse.attributeTypeMap) ;

    }

    public legendEntries: LegendEntries;

    public constructor(init?: Partial< LegendEntriesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents a legend entry in a chart legend.   
export class LegendEntry  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoScaleFont",
            baseName: "AutoScaleFont",
            type: "boolean",
        },
        {
            name: "backgroundMode",
            baseName: "BackgroundMode",
            type: "string",
        },
        {
            name: "font",
            baseName: "Font",
            type: "Font",
        },
        {
            name: "isDeleted",
            baseName: "IsDeleted",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LegendEntry.attributeTypeMap) ;

    }

    public autoScaleFont: boolean;
    public backgroundMode: string;
    public font: Font;
    public isDeleted: boolean;

    public constructor(init?: Partial< LegendEntry >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the LegendEntry Response.   
export class LegendEntryResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "legendEntry",
            baseName: "LegendEntry",
            type: "LegendEntry",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LegendEntryResponse.attributeTypeMap) ;

    }

    public legendEntry: LegendEntry;

    public constructor(init?: Partial< LegendEntryResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates the object that represents the chart legend.   
export class Legend  extends ChartFrame  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "position",
            baseName: "Position",
            type: "string",
        },
        {
            name: "legendEntries",
            baseName: "LegendEntries",
            type: "LinkElement",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Legend.attributeTypeMap) ;

    }

    public position: string;
    public legendEntries: LinkElement;

    public constructor(init?: Partial< Legend >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Legend Response.   
export class LegendResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "legend",
            baseName: "Legend",
            type: "Legend",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LegendResponse.attributeTypeMap) ;

    }

    public legend: Legend;

    public constructor(init?: Partial< LegendResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Line Response.   
export class LineResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "line",
            baseName: "Line",
            type: "Line",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LineResponse.attributeTypeMap) ;

    }

    public line: Line;

    public constructor(init?: Partial< LineResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the line shape.   
export class LineShape  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "beginArrowheadLength",
            baseName: "BeginArrowheadLength",
            type: "string",
        },
        {
            name: "beginArrowheadStyle",
            baseName: "BeginArrowheadStyle",
            type: "string",
        },
        {
            name: "beginArrowheadWidth",
            baseName: "BeginArrowheadWidth",
            type: "string",
        },
        {
            name: "endArrowheadLength",
            baseName: "EndArrowheadLength",
            type: "string",
        },
        {
            name: "endArrowheadStyle",
            baseName: "EndArrowheadStyle",
            type: "string",
        },
        {
            name: "endArrowheadWidth",
            baseName: "EndArrowheadWidth",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LineShape.attributeTypeMap) ;

    }

    public beginArrowheadLength: string;
    public beginArrowheadStyle: string;
    public beginArrowheadWidth: string;
    public endArrowheadLength: string;
    public endArrowheadStyle: string;
    public endArrowheadWidth: string;

    public constructor(init?: Partial< LineShape >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the LineShape Response.   
export class LineShapeResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "LineShape",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(LineShapeResponse.attributeTypeMap) ;

    }

    public shape: LineShape;

    public constructor(init?: Partial< LineShapeResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents a list box object.   
export class ListBox  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "inputRange",
            baseName: "InputRange",
            type: "string",
        },
        {
            name: "itemCount",
            baseName: "ItemCount",
            type: "number",
        },
        {
            name: "pageChange",
            baseName: "PageChange",
            type: "number",
        },
        {
            name: "selectedCells",
            baseName: "SelectedCells",
            type: "Array<LinkElement>",
        },
        {
            name: "selectedIndex",
            baseName: "SelectedIndex",
            type: "number",
        },
        {
            name: "selectionType",
            baseName: "SelectionType",
            type: "string",
        },
        {
            name: "shadow",
            baseName: "Shadow",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ListBox.attributeTypeMap) ;

    }

    public inputRange: string;
    public itemCount: number;
    public pageChange: number;
    public selectedCells: Array<LinkElement>;
    public selectedIndex: number;
    public selectionType: string;
    public shadow: boolean;

    public constructor(init?: Partial< ListBox >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the ListBox Response.   
export class ListBoxResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "ListBox",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ListBoxResponse.attributeTypeMap) ;

    }

    public shape: ListBox;

    public constructor(init?: Partial< ListBoxResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the ListObject Response.   
export class ListObjectResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "listObject",
            baseName: "ListObject",
            type: "ListObject",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ListObjectResponse.attributeTypeMap) ;

    }

    public listObject: ListObject;

    public constructor(init?: Partial< ListObjectResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the ListObjects Response.   
export class ListObjectsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "listObjects",
            baseName: "ListObjects",
            type: "ListObjects",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ListObjectsResponse.attributeTypeMap) ;

    }

    public listObjects: ListObjects;

    public constructor(init?: Partial< ListObjectsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the MergedCell Response.   
export class MergedCellResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "mergedCell",
            baseName: "MergedCell",
            type: "MergedCell",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(MergedCellResponse.attributeTypeMap) ;

    }

    public mergedCell: MergedCell;

    public constructor(init?: Partial< MergedCellResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the MergedCells Response.   
export class MergedCellsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "mergedCells",
            baseName: "MergedCells",
            type: "MergedCells",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(MergedCellsResponse.attributeTypeMap) ;

    }

    public mergedCells: MergedCells;

    public constructor(init?: Partial< MergedCellsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Name Response.   
export class NameResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "Name",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(NameResponse.attributeTypeMap) ;

    }

    public name: Name;

    public constructor(init?: Partial< NameResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Names Response.   
export class NamesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "names",
            baseName: "Names",
            type: "Names",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(NamesResponse.attributeTypeMap) ;

    }

    public names: Names;

    public constructor(init?: Partial< NamesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents an OleObject in a worksheet.   
export class OleObject  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "displayAsIcon",
            baseName: "DisplayAsIcon",
            type: "boolean",
        },
        {
            name: "fileFormatType",
            baseName: "FileFormatType",
            type: "string",
        },
        {
            name: "imageSourceFullName",
            baseName: "ImageSourceFullName",
            type: "string",
        },
        {
            name: "isAutoSize",
            baseName: "IsAutoSize",
            type: "boolean",
        },
        {
            name: "isLink",
            baseName: "IsLink",
            type: "boolean",
        },
        {
            name: "progID",
            baseName: "ProgID",
            type: "string",
        },
        {
            name: "sourceFullName",
            baseName: "SourceFullName",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(OleObject.attributeTypeMap) ;

    }

    public displayAsIcon: boolean;
    public fileFormatType: string;
    public imageSourceFullName: string;
    public isAutoSize: boolean;
    public isLink: boolean;
    public progID: string;
    public sourceFullName: string;

    public constructor(init?: Partial< OleObject >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the OleObject Response.   
export class OleObjectResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "oleObject",
            baseName: "OleObject",
            type: "OleObject",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(OleObjectResponse.attributeTypeMap) ;

    }

    public oleObject: OleObject;

    public constructor(init?: Partial< OleObjectResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents embedded OLE objects.   
export class OleObjects  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "oleObjectList",
            baseName: "OleObjectList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(OleObjects.attributeTypeMap) ;

    }

    public oleObjectList: Array<LinkElement>;

    public constructor(init?: Partial< OleObjects >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the OleObjects Response.   
export class OleObjectsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "oleObjects",
            baseName: "OleObjects",
            type: "OleObjects",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(OleObjectsResponse.attributeTypeMap) ;

    }

    public oleObjects: OleObjects;

    public constructor(init?: Partial< OleObjectsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the oval shape.   
export class Oval  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Oval.attributeTypeMap) ;

    }


    public constructor(init?: Partial< Oval >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Oval Response.   
export class OvalResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "Oval",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(OvalResponse.attributeTypeMap) ;

    }

    public shape: Oval;

    public constructor(init?: Partial< OvalResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the PageSections Response.   
export class PageSectionsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pageSections",
            baseName: "PageSections",
            type: "Array<PageSection>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PageSectionsResponse.attributeTypeMap) ;

    }

    public pageSections: Array<PageSection>;

    public constructor(init?: Partial< PageSectionsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the PageSetup Response.   
export class PageSetupResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pageSetup",
            baseName: "PageSetup",
            type: "PageSetup",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PageSetupResponse.attributeTypeMap) ;

    }

    public pageSetup: PageSetup;

    public constructor(init?: Partial< PageSetupResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates the object that represents a single picture in a spreadsheet.   
export class Picture  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "borderLineColor",
            baseName: "BorderLineColor",
            type: "Color",
        },
        {
            name: "borderWeight",
            baseName: "BorderWeight",
            type: "number",
        },
        {
            name: "originalHeight",
            baseName: "OriginalHeight",
            type: "number",
        },
        {
            name: "originalWidth",
            baseName: "OriginalWidth",
            type: "number",
        },
        {
            name: "imageFormat",
            baseName: "ImageFormat",
            type: "string",
        },
        {
            name: "sourceFullName",
            baseName: "SourceFullName",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Picture.attributeTypeMap) ;

    }

    public borderLineColor: Color;
    public borderWeight: number;
    public originalHeight: number;
    public originalWidth: number;
    public imageFormat: string;
    public sourceFullName: string;

    public constructor(init?: Partial< Picture >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Picture Response.   
export class PictureResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "picture",
            baseName: "Picture",
            type: "Picture",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PictureResponse.attributeTypeMap) ;

    }

    public picture: Picture;

    public constructor(init?: Partial< PictureResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates a collection of  objects.   
export class Pictures  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pictureList",
            baseName: "PictureList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Pictures.attributeTypeMap) ;

    }

    public pictureList: Array<LinkElement>;

    public constructor(init?: Partial< Pictures >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Pictures Response.   
export class PicturesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pictures",
            baseName: "Pictures",
            type: "Pictures",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PicturesResponse.attributeTypeMap) ;

    }

    public pictures: Pictures;

    public constructor(init?: Partial< PicturesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///            Represents a field in a PivotTable report.
///               
export class PivotField  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoShowCount",
            baseName: "AutoShowCount",
            type: "number",
        },
        {
            name: "autoShowField",
            baseName: "AutoShowField",
            type: "number",
        },
        {
            name: "autoSortField",
            baseName: "AutoSortField",
            type: "number",
        },
        {
            name: "baseField",
            baseName: "BaseField",
            type: "number",
        },
        {
            name: "baseIndex",
            baseName: "BaseIndex",
            type: "number",
        },
        {
            name: "baseItem",
            baseName: "BaseItem",
            type: "number",
        },
        {
            name: "baseItemPosition",
            baseName: "BaseItemPosition",
            type: "string",
        },
        {
            name: "currentPageItem",
            baseName: "CurrentPageItem",
            type: "number",
        },
        {
            name: "dataDisplayFormat",
            baseName: "DataDisplayFormat",
            type: "string",
        },
        {
            name: "displayName",
            baseName: "DisplayName",
            type: "string",
        },
        {
            name: "dragToColumn",
            baseName: "DragToColumn",
            type: "boolean",
        },
        {
            name: "dragToData",
            baseName: "DragToData",
            type: "boolean",
        },
        {
            name: "dragToHide",
            baseName: "DragToHide",
            type: "boolean",
        },
        {
            name: "dragToPage",
            baseName: "DragToPage",
            type: "boolean",
        },
        {
            name: "dragToRow",
            baseName: "DragToRow",
            type: "boolean",
        },
        {
            name: "function",
            baseName: "Function",
            type: "string",
        },
        {
            name: "insertBlankRow",
            baseName: "InsertBlankRow",
            type: "boolean",
        },
        {
            name: "isAscendShow",
            baseName: "IsAscendShow",
            type: "boolean",
        },
        {
            name: "isAscendSort",
            baseName: "IsAscendSort",
            type: "boolean",
        },
        {
            name: "isAutoShow",
            baseName: "IsAutoShow",
            type: "boolean",
        },
        {
            name: "isAutoSort",
            baseName: "IsAutoSort",
            type: "boolean",
        },
        {
            name: "isAutoSubtotals",
            baseName: "IsAutoSubtotals",
            type: "boolean",
        },
        {
            name: "isCalculatedField",
            baseName: "IsCalculatedField",
            type: "boolean",
        },
        {
            name: "isIncludeNewItemsInFilter",
            baseName: "IsIncludeNewItemsInFilter",
            type: "boolean",
        },
        {
            name: "isInsertPageBreaksBetweenItems",
            baseName: "IsInsertPageBreaksBetweenItems",
            type: "boolean",
        },
        {
            name: "isMultipleItemSelectionAllowed",
            baseName: "IsMultipleItemSelectionAllowed",
            type: "boolean",
        },
        {
            name: "isRepeatItemLabels",
            baseName: "IsRepeatItemLabels",
            type: "boolean",
        },
        {
            name: "itemCount",
            baseName: "ItemCount",
            type: "number",
        },
        {
            name: "items",
            baseName: "Items",
            type: "Array<string>",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "number",
            baseName: "Number",
            type: "number",
        },
        {
            name: "numberFormat",
            baseName: "NumberFormat",
            type: "string",
        },
        {
            name: "originalItems",
            baseName: "OriginalItems",
            type: "Array<string>",
        },
        {
            name: "pivotItems",
            baseName: "PivotItems",
            type: "Array<PivotItem>",
        },
        {
            name: "position",
            baseName: "Position",
            type: "number",
        },
        {
            name: "showAllItems",
            baseName: "ShowAllItems",
            type: "boolean",
        },
        {
            name: "showCompact",
            baseName: "ShowCompact",
            type: "boolean",
        },
        {
            name: "showInOutlineForm",
            baseName: "ShowInOutlineForm",
            type: "boolean",
        },
        {
            name: "showSubtotalAtTop",
            baseName: "ShowSubtotalAtTop",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  PivotField.attributeTypeMap;

    }

    public autoShowCount: number;
    public autoShowField: number;
    public autoSortField: number;
    public baseField: number;
    public baseIndex: number;
    public baseItem: number;
    public baseItemPosition: string;
    public currentPageItem: number;
    public dataDisplayFormat: string;
    public displayName: string;
    public dragToColumn: boolean;
    public dragToData: boolean;
    public dragToHide: boolean;
    public dragToPage: boolean;
    public dragToRow: boolean;
    public function: string;
    public insertBlankRow: boolean;
    public isAscendShow: boolean;
    public isAscendSort: boolean;
    public isAutoShow: boolean;
    public isAutoSort: boolean;
    public isAutoSubtotals: boolean;
    public isCalculatedField: boolean;
    public isIncludeNewItemsInFilter: boolean;
    public isInsertPageBreaksBetweenItems: boolean;
    public isMultipleItemSelectionAllowed: boolean;
    public isRepeatItemLabels: boolean;
    public itemCount: number;
    public items: Array<string>;
    public name: string;
    public number: number;
    public numberFormat: string;
    public originalItems: Array<string>;
    public pivotItems: Array<PivotItem>;
    public position: number;
    public showAllItems: boolean;
    public showCompact: boolean;
    public showInOutlineForm: boolean;
    public showSubtotalAtTop: boolean;

    public constructor(init?: Partial< PivotField >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents the PivotField Response.   
export class PivotFieldResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pivotField",
            baseName: "PivotField",
            type: "PivotField",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PivotFieldResponse.attributeTypeMap) ;

    }

    public pivotField: PivotField;

    public constructor(init?: Partial< PivotFieldResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents a PivotFilter in PivotFilter Collection.   
export class PivotFilter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoFilter",
            baseName: "AutoFilter",
            type: "AutoFilter",
        },
        {
            name: "evaluationOrder",
            baseName: "EvaluationOrder",
            type: "number",
        },
        {
            name: "fieldIndex",
            baseName: "FieldIndex",
            type: "number",
        },
        {
            name: "filterType",
            baseName: "FilterType",
            type: "string",
        },
        {
            name: "valueFieldIndex",
            baseName: "ValueFieldIndex",
            type: "number",
        },
        {
            name: "memberPropertyFieldIndex",
            baseName: "MemberPropertyFieldIndex",
            type: "number",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "value1",
            baseName: "Value1",
            type: "string",
        },
        {
            name: "value2",
            baseName: "Value2",
            type: "string",
        },
        {
            name: "top10Filter",
            baseName: "Top10Filter",
            type: "Top10Filter",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  PivotFilter.attributeTypeMap;

    }

    public autoFilter: AutoFilter;
    public evaluationOrder: number;
    public fieldIndex: number;
    public filterType: string;
    public valueFieldIndex: number;
    public memberPropertyFieldIndex: number;
    public name: string;
    public value1: string;
    public value2: string;
    public top10Filter: Top10Filter;

    public constructor(init?: Partial< PivotFilter >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents the PivotFilter Response.   
export class PivotFilterResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pivotFilter",
            baseName: "PivotFilter",
            type: "PivotFilter",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PivotFilterResponse.attributeTypeMap) ;

    }

    public pivotFilter: PivotFilter;

    public constructor(init?: Partial< PivotFilterResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the PivotFilters Response.   
export class PivotFiltersResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pivotFilters",
            baseName: "PivotFilters",
            type: "Array<PivotFilter>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PivotFiltersResponse.attributeTypeMap) ;

    }

    public pivotFilters: Array<PivotFilter>;

    public constructor(init?: Partial< PivotFiltersResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Summary description for PivotTable.   
export class PivotTable  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "altTextDescription",
            baseName: "AltTextDescription",
            type: "string",
        },
        {
            name: "altTextTitle",
            baseName: "AltTextTitle",
            type: "string",
        },
        {
            name: "autoFormatType",
            baseName: "AutoFormatType",
            type: "string",
        },
        {
            name: "baseFields",
            baseName: "BaseFields",
            type: "Array<PivotField>",
        },
        {
            name: "columnFields",
            baseName: "ColumnFields",
            type: "Array<PivotField>",
        },
        {
            name: "columnGrand",
            baseName: "ColumnGrand",
            type: "boolean",
        },
        {
            name: "columnHeaderCaption",
            baseName: "ColumnHeaderCaption",
            type: "string",
        },
        {
            name: "columnRange",
            baseName: "ColumnRange",
            type: "CellArea",
        },
        {
            name: "customListSort",
            baseName: "CustomListSort",
            type: "boolean",
        },
        {
            name: "dataBodyRange",
            baseName: "DataBodyRange",
            type: "CellArea",
        },
        {
            name: "dataField",
            baseName: "DataField",
            type: "PivotField",
        },
        {
            name: "dataFields",
            baseName: "DataFields",
            type: "Array<PivotField>",
        },
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "Array<string>",
        },
        {
            name: "displayErrorString",
            baseName: "DisplayErrorString",
            type: "boolean",
        },
        {
            name: "displayImmediateItems",
            baseName: "DisplayImmediateItems",
            type: "boolean",
        },
        {
            name: "displayNullString",
            baseName: "DisplayNullString",
            type: "boolean",
        },
        {
            name: "enableDataValueEditing",
            baseName: "EnableDataValueEditing",
            type: "boolean",
        },
        {
            name: "enableDrilldown",
            baseName: "EnableDrilldown",
            type: "boolean",
        },
        {
            name: "enableFieldDialog",
            baseName: "EnableFieldDialog",
            type: "boolean",
        },
        {
            name: "enableFieldList",
            baseName: "EnableFieldList",
            type: "boolean",
        },
        {
            name: "enableWizard",
            baseName: "EnableWizard",
            type: "boolean",
        },
        {
            name: "errorString",
            baseName: "ErrorString",
            type: "string",
        },
        {
            name: "fieldListSortAscending",
            baseName: "FieldListSortAscending",
            type: "boolean",
        },
        {
            name: "grandTotalName",
            baseName: "GrandTotalName",
            type: "string",
        },
        {
            name: "hasBlankRows",
            baseName: "HasBlankRows",
            type: "boolean",
        },
        {
            name: "indent",
            baseName: "Indent",
            type: "number",
        },
        {
            name: "isAutoFormat",
            baseName: "IsAutoFormat",
            type: "boolean",
        },
        {
            name: "isGridDropZones",
            baseName: "IsGridDropZones",
            type: "boolean",
        },
        {
            name: "isMultipleFieldFilters",
            baseName: "IsMultipleFieldFilters",
            type: "boolean",
        },
        {
            name: "isSelected",
            baseName: "IsSelected",
            type: "boolean",
        },
        {
            name: "itemPrintTitles",
            baseName: "ItemPrintTitles",
            type: "boolean",
        },
        {
            name: "manualUpdate",
            baseName: "ManualUpdate",
            type: "boolean",
        },
        {
            name: "mergeLabels",
            baseName: "MergeLabels",
            type: "boolean",
        },
        {
            name: "missingItemsLimit",
            baseName: "MissingItemsLimit",
            type: "string",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "nullString",
            baseName: "NullString",
            type: "string",
        },
        {
            name: "pageFieldOrder",
            baseName: "PageFieldOrder",
            type: "string",
        },
        {
            name: "pageFields",
            baseName: "PageFields",
            type: "Array<PivotField>",
        },
        {
            name: "pageFieldWrapCount",
            baseName: "PageFieldWrapCount",
            type: "number",
        },
        {
            name: "pivotFilters",
            baseName: "PivotFilters",
            type: "Array<PivotFilter>",
        },
        {
            name: "pivotTableStyleName",
            baseName: "PivotTableStyleName",
            type: "string",
        },
        {
            name: "pivotTableStyleType",
            baseName: "PivotTableStyleType",
            type: "string",
        },
        {
            name: "preserveFormatting",
            baseName: "PreserveFormatting",
            type: "boolean",
        },
        {
            name: "printDrill",
            baseName: "PrintDrill",
            type: "boolean",
        },
        {
            name: "printTitles",
            baseName: "PrintTitles",
            type: "boolean",
        },
        {
            name: "refreshDataFlag",
            baseName: "RefreshDataFlag",
            type: "boolean",
        },
        {
            name: "refreshDataOnOpeningFile",
            baseName: "RefreshDataOnOpeningFile",
            type: "boolean",
        },
        {
            name: "rowFields",
            baseName: "RowFields",
            type: "Array<PivotField>",
        },
        {
            name: "rowGrand",
            baseName: "RowGrand",
            type: "boolean",
        },
        {
            name: "rowHeaderCaption",
            baseName: "RowHeaderCaption",
            type: "string",
        },
        {
            name: "rowRange",
            baseName: "RowRange",
            type: "CellArea",
        },
        {
            name: "saveData",
            baseName: "SaveData",
            type: "boolean",
        },
        {
            name: "showDataTips",
            baseName: "ShowDataTips",
            type: "boolean",
        },
        {
            name: "showDrill",
            baseName: "ShowDrill",
            type: "boolean",
        },
        {
            name: "showEmptyCol",
            baseName: "ShowEmptyCol",
            type: "boolean",
        },
        {
            name: "showEmptyRow",
            baseName: "ShowEmptyRow",
            type: "boolean",
        },
        {
            name: "showMemberPropertyTips",
            baseName: "ShowMemberPropertyTips",
            type: "boolean",
        },
        {
            name: "showPivotStyleColumnHeader",
            baseName: "ShowPivotStyleColumnHeader",
            type: "boolean",
        },
        {
            name: "showPivotStyleColumnStripes",
            baseName: "ShowPivotStyleColumnStripes",
            type: "boolean",
        },
        {
            name: "showPivotStyleLastColumn",
            baseName: "ShowPivotStyleLastColumn",
            type: "boolean",
        },
        {
            name: "showPivotStyleRowHeader",
            baseName: "ShowPivotStyleRowHeader",
            type: "boolean",
        },
        {
            name: "showPivotStyleRowStripes",
            baseName: "ShowPivotStyleRowStripes",
            type: "boolean",
        },
        {
            name: "showRowHeaderCaption",
            baseName: "ShowRowHeaderCaption",
            type: "boolean",
        },
        {
            name: "showValuesRow",
            baseName: "ShowValuesRow",
            type: "boolean",
        },
        {
            name: "subtotalHiddenPageItems",
            baseName: "SubtotalHiddenPageItems",
            type: "boolean",
        },
        {
            name: "tableRange1",
            baseName: "TableRange1",
            type: "CellArea",
        },
        {
            name: "tableRange2",
            baseName: "TableRange2",
            type: "CellArea",
        },
        {
            name: "tag",
            baseName: "Tag",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PivotTable.attributeTypeMap) ;

    }

    public altTextDescription: string;
    public altTextTitle: string;
    public autoFormatType: string;
    public baseFields: Array<PivotField>;
    public columnFields: Array<PivotField>;
    public columnGrand: boolean;
    public columnHeaderCaption: string;
    public columnRange: CellArea;
    public customListSort: boolean;
    public dataBodyRange: CellArea;
    public dataField: PivotField;
    public dataFields: Array<PivotField>;
    public dataSource: Array<string>;
    public displayErrorString: boolean;
    public displayImmediateItems: boolean;
    public displayNullString: boolean;
    public enableDataValueEditing: boolean;
    public enableDrilldown: boolean;
    public enableFieldDialog: boolean;
    public enableFieldList: boolean;
    public enableWizard: boolean;
    public errorString: string;
    public fieldListSortAscending: boolean;
    public grandTotalName: string;
    public hasBlankRows: boolean;
    public indent: number;
    public isAutoFormat: boolean;
    public isGridDropZones: boolean;
    public isMultipleFieldFilters: boolean;
    public isSelected: boolean;
    public itemPrintTitles: boolean;
    public manualUpdate: boolean;
    public mergeLabels: boolean;
    public missingItemsLimit: string;
    public name: string;
    public nullString: string;
    public pageFieldOrder: string;
    public pageFields: Array<PivotField>;
    public pageFieldWrapCount: number;
    public pivotFilters: Array<PivotFilter>;
    public pivotTableStyleName: string;
    public pivotTableStyleType: string;
    public preserveFormatting: boolean;
    public printDrill: boolean;
    public printTitles: boolean;
    public refreshDataFlag: boolean;
    public refreshDataOnOpeningFile: boolean;
    public rowFields: Array<PivotField>;
    public rowGrand: boolean;
    public rowHeaderCaption: string;
    public rowRange: CellArea;
    public saveData: boolean;
    public showDataTips: boolean;
    public showDrill: boolean;
    public showEmptyCol: boolean;
    public showEmptyRow: boolean;
    public showMemberPropertyTips: boolean;
    public showPivotStyleColumnHeader: boolean;
    public showPivotStyleColumnStripes: boolean;
    public showPivotStyleLastColumn: boolean;
    public showPivotStyleRowHeader: boolean;
    public showPivotStyleRowStripes: boolean;
    public showRowHeaderCaption: boolean;
    public showValuesRow: boolean;
    public subtotalHiddenPageItems: boolean;
    public tableRange1: CellArea;
    public tableRange2: CellArea;
    public tag: string;

    public constructor(init?: Partial< PivotTable >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the PivotTable Response.   
export class PivotTableResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pivotTable",
            baseName: "PivotTable",
            type: "PivotTable",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PivotTableResponse.attributeTypeMap) ;

    }

    public pivotTable: PivotTable;

    public constructor(init?: Partial< PivotTableResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the collection of all the PivotTable objects on the specified worksheet.   
export class PivotTables  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pivotTableList",
            baseName: "PivotTableList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PivotTables.attributeTypeMap) ;

    }

    public pivotTableList: Array<LinkElement>;

    public constructor(init?: Partial< PivotTables >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the PivotTables Response.   
export class PivotTablesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pivotTables",
            baseName: "PivotTables",
            type: "PivotTables",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PivotTablesResponse.attributeTypeMap) ;

    }

    public pivotTables: PivotTables;

    public constructor(init?: Partial< PivotTablesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates the object that represents the plot area in a chart.   
export class PlotArea  extends ChartFrame  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "innerHeight",
            baseName: "InnerHeight",
            type: "number",
        },
        {
            name: "innerWidth",
            baseName: "InnerWidth",
            type: "number",
        },
        {
            name: "innerX",
            baseName: "InnerX",
            type: "number",
        },
        {
            name: "innerY",
            baseName: "InnerY",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PlotArea.attributeTypeMap) ;

    }

    public innerHeight: number;
    public innerWidth: number;
    public innerX: number;
    public innerY: number;

    public constructor(init?: Partial< PlotArea >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the PlotArea Response.   
export class PlotAreaResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "plotArea",
            baseName: "PlotArea",
            type: "PlotArea",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PlotAreaResponse.attributeTypeMap) ;

    }

    public plotArea: PlotArea;

    public constructor(init?: Partial< PlotAreaResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents a radio button.   
export class RadioButton  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "groupBox",
            baseName: "GroupBox",
            type: "GroupBox",
        },
        {
            name: "isChecked",
            baseName: "IsChecked",
            type: "boolean",
        },
        {
            name: "shadow",
            baseName: "Shadow",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(RadioButton.attributeTypeMap) ;

    }

    public groupBox: GroupBox;
    public isChecked: boolean;
    public shadow: boolean;

    public constructor(init?: Partial< RadioButton >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the RadioButton Response.   
export class RadioButtonResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "RadioButton",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(RadioButtonResponse.attributeTypeMap) ;

    }

    public shape: RadioButton;

    public constructor(init?: Partial< RadioButtonResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Range Response.   
export class RangeResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "range",
            baseName: "Range",
            type: "Range",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(RangeResponse.attributeTypeMap) ;

    }

    public range: Range;

    public constructor(init?: Partial< RangeResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Ranges Response.   
export class RangesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "ranges",
            baseName: "Ranges",
            type: "Ranges",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(RangesResponse.attributeTypeMap) ;

    }

    public ranges: Ranges;

    public constructor(init?: Partial< RangesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the RangeValue Response.   
export class RangeValueResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "cellsList",
            baseName: "CellsList",
            type: "Array<Cell>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(RangeValueResponse.attributeTypeMap) ;

    }

    public cellsList: Array<Cell>;

    public constructor(init?: Partial< RangeValueResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the rectangle shape.   
export class RectangleShape  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(RectangleShape.attributeTypeMap) ;

    }


    public constructor(init?: Partial< RectangleShape >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the RectangleShape Response.   
export class RectangleShapeResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "RectangleShape",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(RectangleShapeResponse.attributeTypeMap) ;

    }

    public shape: RectangleShape;

    public constructor(init?: Partial< RectangleShapeResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Row Response.   
export class RowResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "row",
            baseName: "Row",
            type: "Row",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(RowResponse.attributeTypeMap) ;

    }

    public row: Row;

    public constructor(init?: Partial< RowResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Rows Response.   
export class RowsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "rows",
            baseName: "Rows",
            type: "Rows",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(RowsResponse.attributeTypeMap) ;

    }

    public rows: Rows;

    public constructor(init?: Partial< RowsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the SaveFilesToCloudResult Response.   
export class SaveFilesToCloudResultResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "saveFilesToCloudResult",
            baseName: "SaveFilesToCloudResult",
            type: "SaveFilesToCloudResult",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SaveFilesToCloudResultResponse.attributeTypeMap) ;

    }

    public saveFilesToCloudResult: SaveFilesToCloudResult;

    public constructor(init?: Partial< SaveFilesToCloudResultResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents a scroll bar object.   
export class ScrollBar  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "currentValue",
            baseName: "CurrentValue",
            type: "number",
        },
        {
            name: "incrementalChange",
            baseName: "IncrementalChange",
            type: "number",
        },
        {
            name: "isHorizontal",
            baseName: "IsHorizontal",
            type: "boolean",
        },
        {
            name: "max",
            baseName: "Max",
            type: "number",
        },
        {
            name: "min",
            baseName: "Min",
            type: "number",
        },
        {
            name: "pageChange",
            baseName: "PageChange",
            type: "number",
        },
        {
            name: "shadow",
            baseName: "Shadow",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ScrollBar.attributeTypeMap) ;

    }

    public currentValue: number;
    public incrementalChange: number;
    public isHorizontal: boolean;
    public max: number;
    public min: number;
    public pageChange: number;
    public shadow: boolean;

    public constructor(init?: Partial< ScrollBar >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the ScrollBar Response.   
export class ScrollBarResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "ScrollBar",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ScrollBarResponse.attributeTypeMap) ;

    }

    public shape: ScrollBar;

    public constructor(init?: Partial< ScrollBarResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Class Summary: 
///             - Features: Active class participation, group projects, quizzes, and final exam.   
export class SeriesItems  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "categoryData",
            baseName: "CategoryData",
            type: "string",
        },
        {
            name: "isColorVaried",
            baseName: "IsColorVaried",
            type: "boolean",
        },
        {
            name: "secondCatergoryData",
            baseName: "SecondCatergoryData",
            type: "string",
        },
        {
            name: "seriesList",
            baseName: "SeriesList",
            type: "Array<Series>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SeriesItems.attributeTypeMap) ;

    }

    public categoryData: string;
    public isColorVaried: boolean;
    public secondCatergoryData: string;
    public seriesList: Array<Series>;

    public constructor(init?: Partial< SeriesItems >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Serieses Response.   
export class SeriesesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "serieses",
            baseName: "Serieses",
            type: "SeriesItems",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SeriesesResponse.attributeTypeMap) ;

    }

    public serieses: SeriesItems;

    public constructor(init?: Partial< SeriesesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates the object that represents a single data series in a chart.   
export class Series  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "area",
            baseName: "Area",
            type: "Area",
        },
        {
            name: "bar3DShapeType",
            baseName: "Bar3DShapeType",
            type: "string",
        },
        {
            name: "border",
            baseName: "Border",
            type: "Line",
        },
        {
            name: "bubbleScale",
            baseName: "BubbleScale",
            type: "number",
        },
        {
            name: "bubbleSizes",
            baseName: "BubbleSizes",
            type: "string",
        },
        {
            name: "countOfDataValues",
            baseName: "CountOfDataValues",
            type: "number",
        },
        {
            name: "dataLabels",
            baseName: "DataLabels",
            type: "DataLabels",
        },
        {
            name: "displayName",
            baseName: "DisplayName",
            type: "string",
        },
        {
            name: "doughnutHoleSize",
            baseName: "DoughnutHoleSize",
            type: "number",
        },
        {
            name: "downBars",
            baseName: "DownBars",
            type: "DropBars",
        },
        {
            name: "dropLines",
            baseName: "DropLines",
            type: "Line",
        },
        {
            name: "explosion",
            baseName: "Explosion",
            type: "number",
        },
        {
            name: "firstSliceAngle",
            baseName: "FirstSliceAngle",
            type: "number",
        },
        {
            name: "gapWidth",
            baseName: "GapWidth",
            type: "number",
        },
        {
            name: "has3DEffect",
            baseName: "Has3DEffect",
            type: "boolean",
        },
        {
            name: "hasDropLines",
            baseName: "HasDropLines",
            type: "boolean",
        },
        {
            name: "hasHiLoLines",
            baseName: "HasHiLoLines",
            type: "boolean",
        },
        {
            name: "hasLeaderLines",
            baseName: "HasLeaderLines",
            type: "boolean",
        },
        {
            name: "hasRadarAxisLabels",
            baseName: "HasRadarAxisLabels",
            type: "boolean",
        },
        {
            name: "hasSeriesLines",
            baseName: "HasSeriesLines",
            type: "boolean",
        },
        {
            name: "hasUpDownBars",
            baseName: "HasUpDownBars",
            type: "boolean",
        },
        {
            name: "hiLoLines",
            baseName: "HiLoLines",
            type: "Line",
        },
        {
            name: "isAutoSplit",
            baseName: "IsAutoSplit",
            type: "boolean",
        },
        {
            name: "isColorVaried",
            baseName: "IsColorVaried",
            type: "boolean",
        },
        {
            name: "leaderLines",
            baseName: "LeaderLines",
            type: "Line",
        },
        {
            name: "legendEntry",
            baseName: "LegendEntry",
            type: "LegendEntry",
        },
        {
            name: "marker",
            baseName: "Marker",
            type: "Marker",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "overlap",
            baseName: "Overlap",
            type: "number",
        },
        {
            name: "plotOnSecondAxis",
            baseName: "PlotOnSecondAxis",
            type: "boolean",
        },
        {
            name: "points",
            baseName: "Points",
            type: "LinkElement",
        },
        {
            name: "secondPlotSize",
            baseName: "SecondPlotSize",
            type: "number",
        },
        {
            name: "seriesLines",
            baseName: "SeriesLines",
            type: "Line",
        },
        {
            name: "shadow",
            baseName: "Shadow",
            type: "boolean",
        },
        {
            name: "showNegativeBubbles",
            baseName: "ShowNegativeBubbles",
            type: "boolean",
        },
        {
            name: "sizeRepresents",
            baseName: "SizeRepresents",
            type: "string",
        },
        {
            name: "smooth",
            baseName: "Smooth",
            type: "boolean",
        },
        {
            name: "splitType",
            baseName: "SplitType",
            type: "string",
        },
        {
            name: "splitValue",
            baseName: "SplitValue",
            type: "number",
        },
        {
            name: "trendLines",
            baseName: "TrendLines",
            type: "Trendlines",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "upBars",
            baseName: "UpBars",
            type: "DropBars",
        },
        {
            name: "values",
            baseName: "Values",
            type: "string",
        },
        {
            name: "xErrorBar",
            baseName: "XErrorBar",
            type: "ErrorBar",
        },
        {
            name: "xValues",
            baseName: "XValues",
            type: "string",
        },
        {
            name: "yErrorBar",
            baseName: "YErrorBar",
            type: "ErrorBar",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Series.attributeTypeMap) ;

    }

    public area: Area;
    public bar3DShapeType: string;
    public border: Line;
    public bubbleScale: number;
    public bubbleSizes: string;
    public countOfDataValues: number;
    public dataLabels: DataLabels;
    public displayName: string;
    public doughnutHoleSize: number;
    public downBars: DropBars;
    public dropLines: Line;
    public explosion: number;
    public firstSliceAngle: number;
    public gapWidth: number;
    public has3DEffect: boolean;
    public hasDropLines: boolean;
    public hasHiLoLines: boolean;
    public hasLeaderLines: boolean;
    public hasRadarAxisLabels: boolean;
    public hasSeriesLines: boolean;
    public hasUpDownBars: boolean;
    public hiLoLines: Line;
    public isAutoSplit: boolean;
    public isColorVaried: boolean;
    public leaderLines: Line;
    public legendEntry: LegendEntry;
    public marker: Marker;
    public name: string;
    public overlap: number;
    public plotOnSecondAxis: boolean;
    public points: LinkElement;
    public secondPlotSize: number;
    public seriesLines: Line;
    public shadow: boolean;
    public showNegativeBubbles: boolean;
    public sizeRepresents: string;
    public smooth: boolean;
    public splitType: string;
    public splitValue: number;
    public trendLines: Trendlines;
    public type: string;
    public upBars: DropBars;
    public values: string;
    public xErrorBar: ErrorBar;
    public xValues: string;
    public yErrorBar: ErrorBar;

    public constructor(init?: Partial< Series >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Series Response.   
export class SeriesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "series",
            baseName: "Series",
            type: "Series",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SeriesResponse.attributeTypeMap) ;

    }

    public series: Series;

    public constructor(init?: Partial< SeriesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Shape Response.   
export class ShapeResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "Shape",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ShapeResponse.attributeTypeMap) ;

    }

    public shape: Shape;

    public constructor(init?: Partial< ShapeResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents all the shape in a worksheet/chart.   
export class Shapes  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shapeList",
            baseName: "ShapeList",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Shapes.attributeTypeMap) ;

    }

    public shapeList: Array<LinkElement>;

    public constructor(init?: Partial< Shapes >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Shapes Response.   
export class ShapesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shapes",
            baseName: "Shapes",
            type: "Shapes",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ShapesResponse.attributeTypeMap) ;

    }

    public shapes: Shapes;

    public constructor(init?: Partial< ShapesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the SingleValue Response.   
export class SingleValueResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "value",
            baseName: "Value",
            type: "SingleValue",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SingleValueResponse.attributeTypeMap) ;

    }

    public value: SingleValue;

    public constructor(init?: Partial< SingleValueResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///            is organized into sparkline group. A SparklineGroup contains a variable number of sparkline items.             A sparkline group specifies the type, display settings and axis settings for the sparklines.
///               
export class SparklineGroup  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "displayHidden",
            baseName: "DisplayHidden",
            type: "boolean",
        },
        {
            name: "firstPointColor",
            baseName: "FirstPointColor",
            type: "CellsColor",
        },
        {
            name: "highPointColor",
            baseName: "HighPointColor",
            type: "CellsColor",
        },
        {
            name: "horizontalAxisColor",
            baseName: "HorizontalAxisColor",
            type: "CellsColor",
        },
        {
            name: "horizontalAxisDateRange",
            baseName: "HorizontalAxisDateRange",
            type: "string",
        },
        {
            name: "lastPointColor",
            baseName: "LastPointColor",
            type: "CellsColor",
        },
        {
            name: "lineWeight",
            baseName: "LineWeight",
            type: "number",
        },
        {
            name: "lowPointColor",
            baseName: "LowPointColor",
            type: "CellsColor",
        },
        {
            name: "markersColor",
            baseName: "MarkersColor",
            type: "CellsColor",
        },
        {
            name: "negativePointsColor",
            baseName: "NegativePointsColor",
            type: "CellsColor",
        },
        {
            name: "plotEmptyCellsType",
            baseName: "PlotEmptyCellsType",
            type: "string",
        },
        {
            name: "plotRightToLeft",
            baseName: "PlotRightToLeft",
            type: "boolean",
        },
        {
            name: "presetStyle",
            baseName: "PresetStyle",
            type: "string",
        },
        {
            name: "seriesColor",
            baseName: "SeriesColor",
            type: "CellsColor",
        },
        {
            name: "showFirstPoint",
            baseName: "ShowFirstPoint",
            type: "boolean",
        },
        {
            name: "showHighPoint",
            baseName: "ShowHighPoint",
            type: "boolean",
        },
        {
            name: "showHorizontalAxis",
            baseName: "ShowHorizontalAxis",
            type: "boolean",
        },
        {
            name: "showLastPoint",
            baseName: "ShowLastPoint",
            type: "boolean",
        },
        {
            name: "showLowPoint",
            baseName: "ShowLowPoint",
            type: "boolean",
        },
        {
            name: "showMarkers",
            baseName: "ShowMarkers",
            type: "boolean",
        },
        {
            name: "showNegativePoints",
            baseName: "ShowNegativePoints",
            type: "boolean",
        },
        {
            name: "sparklineCollection",
            baseName: "SparklineCollection",
            type: "Array<Sparkline>",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "verticalAxisMaxValue",
            baseName: "VerticalAxisMaxValue",
            type: "number",
        },
        {
            name: "verticalAxisMaxValueType",
            baseName: "VerticalAxisMaxValueType",
            type: "string",
        },
        {
            name: "verticalAxisMinValue",
            baseName: "VerticalAxisMinValue",
            type: "number",
        },
        {
            name: "verticalAxisMinValueType",
            baseName: "VerticalAxisMinValueType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  SparklineGroup.attributeTypeMap;

    }

    public displayHidden: boolean;
    public firstPointColor: CellsColor;
    public highPointColor: CellsColor;
    public horizontalAxisColor: CellsColor;
    public horizontalAxisDateRange: string;
    public lastPointColor: CellsColor;
    public lineWeight: number;
    public lowPointColor: CellsColor;
    public markersColor: CellsColor;
    public negativePointsColor: CellsColor;
    public plotEmptyCellsType: string;
    public plotRightToLeft: boolean;
    public presetStyle: string;
    public seriesColor: CellsColor;
    public showFirstPoint: boolean;
    public showHighPoint: boolean;
    public showHorizontalAxis: boolean;
    public showLastPoint: boolean;
    public showLowPoint: boolean;
    public showMarkers: boolean;
    public showNegativePoints: boolean;
    public sparklineCollection: Array<Sparkline>;
    public type: string;
    public verticalAxisMaxValue: number;
    public verticalAxisMaxValueType: string;
    public verticalAxisMinValue: number;
    public verticalAxisMinValueType: string;

    public constructor(init?: Partial< SparklineGroup >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents the SparklineGroup Response.   
export class SparklineGroupResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sparklineGroup",
            baseName: "SparklineGroup",
            type: "SparklineGroup",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SparklineGroupResponse.attributeTypeMap) ;

    }

    public sparklineGroup: SparklineGroup;

    public constructor(init?: Partial< SparklineGroupResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates a collection of Aspose.Cells.Charts.SparklineGroup objects.
///                
export class SparklineGroups  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sparklineGroupList",
            baseName: "SparklineGroupList",
            type: "Array<SparklineGroup>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  SparklineGroups.attributeTypeMap;

    }

    public sparklineGroupList: Array<SparklineGroup>;

    public constructor(init?: Partial< SparklineGroups >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents the SparklineGroups Response.   
export class SparklineGroupsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sparklineGroups",
            baseName: "SparklineGroups",
            type: "SparklineGroups",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SparklineGroupsResponse.attributeTypeMap) ;

    }

    public sparklineGroups: SparklineGroups;

    public constructor(init?: Partial< SparklineGroupsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Forms control: Spinner.   
export class Spinner  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "currentValue",
            baseName: "CurrentValue",
            type: "number",
        },
        {
            name: "incrementalChange",
            baseName: "IncrementalChange",
            type: "number",
        },
        {
            name: "max",
            baseName: "Max",
            type: "number",
        },
        {
            name: "min",
            baseName: "Min",
            type: "number",
        },
        {
            name: "shadow",
            baseName: "Shadow",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Spinner.attributeTypeMap) ;

    }

    public currentValue: number;
    public incrementalChange: number;
    public max: number;
    public min: number;
    public shadow: boolean;

    public constructor(init?: Partial< Spinner >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Spinner Response.   
export class SpinnerResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "Spinner",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SpinnerResponse.attributeTypeMap) ;

    }

    public shape: Spinner;

    public constructor(init?: Partial< SpinnerResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the SplitResult Response.   
export class SplitResultResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "result",
            baseName: "Result",
            type: "SplitResult",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SplitResultResponse.attributeTypeMap) ;

    }

    public result: SplitResult;

    public constructor(init?: Partial< SplitResultResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Style Response.   
export class StyleResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "style",
            baseName: "Style",
            type: "Style",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(StyleResponse.attributeTypeMap) ;

    }

    public style: Style;

    public constructor(init?: Partial< StyleResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Styles Response.   
export class StylesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "styles",
            baseName: "Styles",
            type: "Styles",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(StylesResponse.attributeTypeMap) ;

    }

    public styles: Styles;

    public constructor(init?: Partial< StylesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the TaskRunResult Response.   
export class TaskRunResultResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "taskRunResult",
            baseName: "TaskRunResult",
            type: "TaskRunResult",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TaskRunResultResponse.attributeTypeMap) ;

    }

    public taskRunResult: TaskRunResult;

    public constructor(init?: Partial< TaskRunResultResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates the object that represents a textbox in a spreadsheet.   
export class TextBox  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TextBox.attributeTypeMap) ;

    }


    public constructor(init?: Partial< TextBox >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the TextBox Response.   
export class TextBoxResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "shape",
            baseName: "Shape",
            type: "TextBox",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TextBoxResponse.attributeTypeMap) ;

    }

    public shape: TextBox;

    public constructor(init?: Partial< TextBoxResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the TextItem Response.   
export class TextItemResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "textItem",
            baseName: "TextItem",
            type: "TextItem",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TextItemResponse.attributeTypeMap) ;

    }

    public textItem: TextItem;

    public constructor(init?: Partial< TextItemResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the TextItems Response.   
export class TextItemsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "textItems",
            baseName: "TextItems",
            type: "TextItems",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TextItemsResponse.attributeTypeMap) ;

    }

    public textItems: TextItems;

    public constructor(init?: Partial< TextItemsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the tick-mark labels associated with tick marks on a chart axis.   
export class TickLabels  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "autoScaleFont",
            baseName: "AutoScaleFont",
            type: "boolean",
        },
        {
            name: "backgroundMode",
            baseName: "BackgroundMode",
            type: "string",
        },
        {
            name: "font",
            baseName: "Font",
            type: "Font",
        },
        {
            name: "number",
            baseName: "Number",
            type: "number",
        },
        {
            name: "numberFormat",
            baseName: "NumberFormat",
            type: "string",
        },
        {
            name: "numberFormatLinked",
            baseName: "NumberFormatLinked",
            type: "boolean",
        },
        {
            name: "offset",
            baseName: "Offset",
            type: "number",
        },
        {
            name: "rotationAngle",
            baseName: "RotationAngle",
            type: "number",
        },
        {
            name: "textDirection",
            baseName: "TextDirection",
            type: "string",
        },
        {
            name: "readingOrder",
            baseName: "ReadingOrder",
            type: "string",
        },
        {
            name: "directionType",
            baseName: "DirectionType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TickLabels.attributeTypeMap) ;

    }

    public autoScaleFont: boolean;
    public backgroundMode: string;
    public font: Font;
    public number: number;
    public numberFormat: string;
    public numberFormatLinked: boolean;
    public offset: number;
    public rotationAngle: number;
    public textDirection: string;
    public readingOrder: string;
    public directionType: string;

    public constructor(init?: Partial< TickLabels >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the TickLabels Response.   
export class TickLabelsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "tickLabels",
            baseName: "TickLabels",
            type: "TickLabels",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TickLabelsResponse.attributeTypeMap) ;

    }

    public tickLabels: TickLabels;

    public constructor(init?: Partial< TickLabelsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates the object that represents the title of chart or axis.   
export class Title  extends ChartFrame  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "isVisible",
            baseName: "IsVisible",
            type: "boolean",
        },
        {
            name: "linkedSource",
            baseName: "LinkedSource",
            type: "string",
        },
        {
            name: "rotationAngle",
            baseName: "RotationAngle",
            type: "number",
        },
        {
            name: "text",
            baseName: "Text",
            type: "string",
        },
        {
            name: "textDirection",
            baseName: "TextDirection",
            type: "string",
        },
        {
            name: "textHorizontalAlignment",
            baseName: "TextHorizontalAlignment",
            type: "string",
        },
        {
            name: "textVerticalAlignment",
            baseName: "TextVerticalAlignment",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Title.attributeTypeMap) ;

    }

    public isVisible: boolean;
    public linkedSource: string;
    public rotationAngle: number;
    public text: string;
    public textDirection: string;
    public textHorizontalAlignment: string;
    public textVerticalAlignment: string;

    public constructor(init?: Partial< Title >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Title Response.   
export class TitleResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "title",
            baseName: "Title",
            type: "Title",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TitleResponse.attributeTypeMap) ;

    }

    public title: Title;

    public constructor(init?: Partial< TitleResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents a trendline in a chart.   
export class Trendline  extends Line  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "link",
            baseName: "link",
            type: "Link",
        },
        {
            name: "backward",
            baseName: "Backward",
            type: "number",
        },
        {
            name: "dataLabels",
            baseName: "DataLabels",
            type: "DataLabels",
        },
        {
            name: "displayEquation",
            baseName: "DisplayEquation",
            type: "boolean",
        },
        {
            name: "displayRSquared",
            baseName: "DisplayRSquared",
            type: "boolean",
        },
        {
            name: "forward",
            baseName: "Forward",
            type: "number",
        },
        {
            name: "intercept",
            baseName: "Intercept",
            type: "number",
        },
        {
            name: "isNameAuto",
            baseName: "IsNameAuto",
            type: "boolean",
        },
        {
            name: "legendEntry",
            baseName: "LegendEntry",
            type: "LegendEntry",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "order",
            baseName: "Order",
            type: "number",
        },
        {
            name: "period",
            baseName: "Period",
            type: "number",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Trendline.attributeTypeMap) ;

    }

    public link: Link;
    public backward: number;
    public dataLabels: DataLabels;
    public displayEquation: boolean;
    public displayRSquared: boolean;
    public forward: number;
    public intercept: number;
    public isNameAuto: boolean;
    public legendEntry: LegendEntry;
    public name: string;
    public order: number;
    public period: number;
    public type: string;

    public constructor(init?: Partial< Trendline >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Trendline Response.   
export class TrendlineResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "trendline",
            baseName: "Trendline",
            type: "Trendline",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TrendlineResponse.attributeTypeMap) ;

    }

    public trendline: Trendline;

    public constructor(init?: Partial< TrendlineResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents a collection of all the  objects for the specified data series.   
export class Trendlines  extends LinkElement  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "trendlineList",
            baseName: "TrendlineList",
            type: "Array<Trendline>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Trendlines.attributeTypeMap) ;

    }

    public trendlineList: Array<Trendline>;

    public constructor(init?: Partial< Trendlines >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Trendlines Response.   
export class TrendlinesResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "trendlines",
            baseName: "Trendlines",
            type: "Trendlines",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(TrendlinesResponse.attributeTypeMap) ;

    }

    public trendlines: Trendlines;

    public constructor(init?: Partial< TrendlinesResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Validation Response.   
export class ValidationResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "validation",
            baseName: "Validation",
            type: "Validation",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ValidationResponse.attributeTypeMap) ;

    }

    public validation: Validation;

    public constructor(init?: Partial< ValidationResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Validations Response.   
export class ValidationsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "validations",
            baseName: "Validations",
            type: "Validations",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ValidationsResponse.attributeTypeMap) ;

    }

    public validations: Validations;

    public constructor(init?: Partial< ValidationsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the VerticalPageBreak Response.   
export class VerticalPageBreakResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "verticalPageBreak",
            baseName: "VerticalPageBreak",
            type: "VerticalPageBreak",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(VerticalPageBreakResponse.attributeTypeMap) ;

    }

    public verticalPageBreak: VerticalPageBreak;

    public constructor(init?: Partial< VerticalPageBreakResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the VerticalPageBreaks Response.   
export class VerticalPageBreaksResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "verticalPageBreaks",
            baseName: "VerticalPageBreaks",
            type: "VerticalPageBreaks",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(VerticalPageBreaksResponse.attributeTypeMap) ;

    }

    public verticalPageBreaks: VerticalPageBreaks;

    public constructor(init?: Partial< VerticalPageBreaksResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Encapsulates the object that represents the walls of a 3-D chart.   
export class Walls  extends Floor  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "centerX",
            baseName: "CenterX",
            type: "number",
        },
        {
            name: "centerY",
            baseName: "CenterY",
            type: "number",
        },
        {
            name: "depth",
            baseName: "Depth",
            type: "number",
        },
        {
            name: "height",
            baseName: "Height",
            type: "number",
        },
        {
            name: "width",
            baseName: "Width",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Walls.attributeTypeMap) ;

    }

    public centerX: number;
    public centerY: number;
    public depth: number;
    public height: number;
    public width: number;

    public constructor(init?: Partial< Walls >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Walls Response.   
export class WallsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "walls",
            baseName: "Walls",
            type: "Walls",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WallsResponse.attributeTypeMap) ;

    }

    public walls: Walls;

    public constructor(init?: Partial< WallsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the WorkbookReplace Response.   
export class WorkbookReplaceResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "matches",
            baseName: "Matches",
            type: "number",
        },
        {
            name: "workbook",
            baseName: "Workbook",
            type: "LinkElement",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WorkbookReplaceResponse.attributeTypeMap) ;

    }

    public matches: number;
    public workbook: LinkElement;

    public constructor(init?: Partial< WorkbookReplaceResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Workbook Response.   
export class WorkbookResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "workbook",
            baseName: "Workbook",
            type: "Workbook",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WorkbookResponse.attributeTypeMap) ;

    }

    public workbook: Workbook;

    public constructor(init?: Partial< WorkbookResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the WorkbookSettings Response.   
export class WorkbookSettingsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "settings",
            baseName: "settings",
            type: "WorkbookSettings",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WorkbookSettingsResponse.attributeTypeMap) ;

    }

    public settings: WorkbookSettings;

    public constructor(init?: Partial< WorkbookSettingsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Workbooks Response.   
export class WorkbooksResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "workbooks",
            baseName: "Workbooks",
            type: "Array<LinkElement>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WorkbooksResponse.attributeTypeMap) ;

    }

    public workbooks: Array<LinkElement>;

    public constructor(init?: Partial< WorkbooksResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the WorksheetReplace Response.   
export class WorksheetReplaceResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "matches",
            baseName: "Matches",
            type: "number",
        },
        {
            name: "worksheet",
            baseName: "Worksheet",
            type: "LinkElement",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WorksheetReplaceResponse.attributeTypeMap) ;

    }

    public matches: number;
    public worksheet: LinkElement;

    public constructor(init?: Partial< WorksheetReplaceResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Worksheet Response.   
export class WorksheetResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "worksheet",
            baseName: "Worksheet",
            type: "Worksheet",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WorksheetResponse.attributeTypeMap) ;

    }

    public worksheet: Worksheet;

    public constructor(init?: Partial< WorksheetResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents the Worksheets Response.   
export class WorksheetsResponse  extends CellsCloudResponse  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "worksheets",
            baseName: "Worksheets",
            type: "Worksheets",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(WorksheetsResponse.attributeTypeMap) ;

    }

    public worksheets: Worksheets;

    public constructor(init?: Partial< WorksheetsResponse >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Can you please provide the features that you would like me to summarize for the class?   
export class AnalyzeExcelRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "files",
            baseName: "Files",
            type: "Array<FileInfo>",
        },
        {
            name: "needThumbnail",
            baseName: "NeedThumbnail",
            type: "boolean",
        },
        {
            name: "buildSuggestoinSheet",
            baseName: "BuildSuggestoinSheet",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  AnalyzeExcelRequest.attributeTypeMap;

    }

    public files: Array<FileInfo>;
    public needThumbnail: boolean;
    public buildSuggestoinSheet: boolean;

    public constructor(init?: Partial< AnalyzeExcelRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates the match condition that needs to be processed for the file name.   
export class MatchConditionRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "regexPattern",
            baseName: "RegexPattern",
            type: "string",
        },
        {
            name: "fullMatchConditions",
            baseName: "FullMatchConditions",
            type: "Array<string>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  MatchConditionRequest.attributeTypeMap;

    }

    public regexPattern: string;
    public fullMatchConditions: Array<string>;

    public constructor(init?: Partial< MatchConditionRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates batch convert file request   
export class BatchConvertRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sourceFolder",
            baseName: "SourceFolder",
            type: "string",
        },
        {
            name: "sourceStorage",
            baseName: "SourceStorage",
            type: "string",
        },
        {
            name: "matchCondition",
            baseName: "MatchCondition",
            type: "MatchConditionRequest",
        },
        {
            name: "format",
            baseName: "Format",
            type: "string",
        },
        {
            name: "outFolder",
            baseName: "OutFolder",
            type: "string",
        },
        {
            name: "outStorage",
            baseName: "OutStorage",
            type: "string",
        },
        {
            name: "region",
            baseName: "Region",
            type: "string",
        },
        {
            name: "pageWideFitOnPerSheet",
            baseName: "PageWideFitOnPerSheet",
            type: "boolean",
        },
        {
            name: "pageTallFitOnPerSheet",
            baseName: "PageTallFitOnPerSheet",
            type: "boolean",
        },
        {
            name: "saveOptions",
            baseName: "SaveOptions",
            type: "SaveOptions",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  BatchConvertRequest.attributeTypeMap;

    }

    public sourceFolder: string;
    public sourceStorage: string;
    public matchCondition: MatchConditionRequest;
    public format: string;
    public outFolder: string;
    public outStorage: string;
    public region: string;
    public pageWideFitOnPerSheet: boolean;
    public pageTallFitOnPerSheet: boolean;
    public saveOptions: SaveOptions;

    public constructor(init?: Partial< BatchConvertRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates batch lock file request   
export class BatchLockRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sourceFolder",
            baseName: "SourceFolder",
            type: "string",
        },
        {
            name: "sourceStorage",
            baseName: "SourceStorage",
            type: "string",
        },
        {
            name: "matchCondition",
            baseName: "MatchCondition",
            type: "MatchConditionRequest",
        },
        {
            name: "password",
            baseName: "Password",
            type: "string",
        },
        {
            name: "outFolder",
            baseName: "OutFolder",
            type: "string",
        },
        {
            name: "outStorage",
            baseName: "OutStorage",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  BatchLockRequest.attributeTypeMap;

    }

    public sourceFolder: string;
    public sourceStorage: string;
    public matchCondition: MatchConditionRequest;
    public password: string;
    public outFolder: string;
    public outStorage: string;

    public constructor(init?: Partial< BatchLockRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates batch protect file request   
export class BatchProtectRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sourceFolder",
            baseName: "SourceFolder",
            type: "string",
        },
        {
            name: "sourceStorage",
            baseName: "SourceStorage",
            type: "string",
        },
        {
            name: "matchCondition",
            baseName: "MatchCondition",
            type: "MatchConditionRequest",
        },
        {
            name: "protectionType",
            baseName: "ProtectionType",
            type: "string",
        },
        {
            name: "password",
            baseName: "Password",
            type: "string",
        },
        {
            name: "outFolder",
            baseName: "OutFolder",
            type: "string",
        },
        {
            name: "outStorage",
            baseName: "OutStorage",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  BatchProtectRequest.attributeTypeMap;

    }

    public sourceFolder: string;
    public sourceStorage: string;
    public matchCondition: MatchConditionRequest;
    public protectionType: string;
    public password: string;
    public outFolder: string;
    public outStorage: string;

    public constructor(init?: Partial< BatchProtectRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Class summary: Identifying key features of a statistical dataset and methods for data analysis.   
export class BatchSplitRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sourceFolder",
            baseName: "SourceFolder",
            type: "string",
        },
        {
            name: "sourceStorage",
            baseName: "SourceStorage",
            type: "string",
        },
        {
            name: "matchCondition",
            baseName: "MatchCondition",
            type: "MatchConditionRequest",
        },
        {
            name: "format",
            baseName: "Format",
            type: "string",
        },
        {
            name: "fromIndex",
            baseName: "FromIndex",
            type: "number",
        },
        {
            name: "toIndex",
            baseName: "ToIndex",
            type: "number",
        },
        {
            name: "outFolder",
            baseName: "OutFolder",
            type: "string",
        },
        {
            name: "outStorage",
            baseName: "OutStorage",
            type: "string",
        },
        {
            name: "region",
            baseName: "Region",
            type: "string",
        },
        {
            name: "saveOptions",
            baseName: "SaveOptions",
            type: "SaveOptions",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  BatchSplitRequest.attributeTypeMap;

    }

    public sourceFolder: string;
    public sourceStorage: string;
    public matchCondition: MatchConditionRequest;
    public format: string;
    public fromIndex: number;
    public toIndex: number;
    public outFolder: string;
    public outStorage: string;
    public region: string;
    public saveOptions: SaveOptions;

    public constructor(init?: Partial< BatchSplitRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates color filter request   
export class ColorFilterRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pattern",
            baseName: "Pattern",
            type: "string",
        },
        {
            name: "foregroundColor",
            baseName: "ForegroundColor",
            type: "CellsColor",
        },
        {
            name: "backgroundColor",
            baseName: "BackgroundColor",
            type: "CellsColor",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ColorFilterRequest.attributeTypeMap;

    }

    public pattern: string;
    public foregroundColor: CellsColor;
    public backgroundColor: CellsColor;

    public constructor(init?: Partial< ColorFilterRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates convert parameter   
export class ConvertParameter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "value",
            baseName: "Value",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ConvertParameter.attributeTypeMap;

    }

    public name: string;
    public value: string;

    public constructor(init?: Partial< ConvertParameter >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates create pivot table request   
export class CreatePivotTableRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "sourceData",
            baseName: "SourceData",
            type: "string",
        },
        {
            name: "destCellName",
            baseName: "DestCellName",
            type: "string",
        },
        {
            name: "useSameSource",
            baseName: "UseSameSource",
            type: "boolean",
        },
        {
            name: "pivotFieldRows",
            baseName: "PivotFieldRows",
            type: "Array<number>",
        },
        {
            name: "pivotFieldColumns",
            baseName: "PivotFieldColumns",
            type: "Array<number>",
        },
        {
            name: "pivotFieldData",
            baseName: "PivotFieldData",
            type: "Array<number>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CreatePivotTableRequest.attributeTypeMap;

    }

    public name: string;
    public sourceData: string;
    public destCellName: string;
    public useSameSource: boolean;
    public pivotFieldRows: Array<number>;
    public pivotFieldColumns: Array<number>;
    public pivotFieldData: Array<number>;

    public constructor(init?: Partial< CreatePivotTableRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// A data cleansing request for an Spreadsheet file.   
export class DataCleansingRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "file",
            baseName: "File",
            type: "FileInfo",
        },
        {
            name: "checkExcelRestriction",
            baseName: "CheckExcelRestriction",
            type: "boolean",
        },
        {
            name: "region",
            baseName: "Region",
            type: "string",
        },
        {
            name: "outFileFormat",
            baseName: "OutFileFormat",
            type: "string",
        },
        {
            name: "dataCleansing",
            baseName: "DataCleansing",
            type: "DataCleansing",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DataCleansingRequest.attributeTypeMap;

    }

    public file: FileInfo;
    public checkExcelRestriction: boolean;
    public region: string;
    public outFileFormat: string;
    public dataCleansing: DataCleansing;

    public constructor(init?: Partial< DataCleansingRequest >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class DataDeduplicationRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "file",
            baseName: "File",
            type: "FileInfo",
        },
        {
            name: "deduplicationRegion",
            baseName: "DeduplicationRegion",
            type: "DeduplicationRegion",
        },
        {
            name: "outFileFormat",
            baseName: "OutFileFormat",
            type: "string",
        },
        {
            name: "checkExcelRestriction",
            baseName: "CheckExcelRestriction",
            type: "boolean",
        },
        {
            name: "region",
            baseName: "Region",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DataDeduplicationRequest.attributeTypeMap;

    }

    public file: FileInfo;
    public deduplicationRegion: DeduplicationRegion;
    public outFileFormat: string;
    public checkExcelRestriction: boolean;
    public region: string;

    public constructor(init?: Partial< DataDeduplicationRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// I'm happy to help! Please provide the features you would like me to summarize.   
export class DataFillRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "file",
            baseName: "File",
            type: "FileInfo",
        },
        {
            name: "outFileFormat",
            baseName: "OutFileFormat",
            type: "string",
        },
        {
            name: "checkExcelRestriction",
            baseName: "CheckExcelRestriction",
            type: "boolean",
        },
        {
            name: "region",
            baseName: "Region",
            type: "string",
        },
        {
            name: "dataFill",
            baseName: "DataFill",
            type: "DataFill",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DataFillRequest.attributeTypeMap;

    }

    public file: FileInfo;
    public outFileFormat: string;
    public checkExcelRestriction: boolean;
    public region: string;
    public dataFill: DataFill;

    public constructor(init?: Partial< DataFillRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Each data manipulation step that is performed when you get the query data.   
export class AppliedStep  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "stepName",
            baseName: "StepName",
            type: "string",
        },
        {
            name: "appliedOperate",
            baseName: "AppliedOperate",
            type: "AppliedOperate",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  AppliedStep.attributeTypeMap;

    }

    public stepName: string;
    public appliedOperate: AppliedOperate;

    public constructor(init?: Partial< AppliedStep >) {  
    
        Object.assign(this, init);
    } 
}
/// Loading data information.   
export class LoadData  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "loadTo",
            baseName: "LoadTo",
            type: "LoadTo",
        },
        {
            name: "dataQuery",
            baseName: "DataQuery",
            type: "DataQuery",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  LoadData.attributeTypeMap;

    }

    public loadTo: LoadTo;
    public dataQuery: DataQuery;

    public constructor(init?: Partial< LoadData >) {  
    
        Object.assign(this, init);
    } 
}
/// Data Transformation Request   
export class DataTransformationRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "fileInfo",
            baseName: "FileInfo",
            type: "FileInfo",
        },
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "loadData",
            baseName: "LoadData",
            type: "LoadData",
        },
        {
            name: "appliedSteps",
            baseName: "AppliedSteps",
            type: "Array<AppliedStep>",
        },
        {
            name: "region",
            baseName: "Region",
            type: "string",
        },
        {
            name: "outFormat",
            baseName: "OutFormat",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DataTransformationRequest.attributeTypeMap;

    }

    public fileInfo: FileInfo;
    public dataSource: DataSource;
    public loadData: LoadData;
    public appliedSteps: Array<AppliedStep>;
    public region: string;
    public outFormat: string;

    public constructor(init?: Partial< DataTransformationRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// I'm here to help! Could you please provide the features you would like me to summarize?   
export class DeleteIncompleteRowsRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "file",
            baseName: "File",
            type: "FileInfo",
        },
        {
            name: "outFileFormat",
            baseName: "OutFileFormat",
            type: "string",
        },
        {
            name: "checkExcelRestriction",
            baseName: "CheckExcelRestriction",
            type: "boolean",
        },
        {
            name: "region",
            baseName: "Region",
            type: "string",
        },
        {
            name: "ranges",
            baseName: "Ranges",
            type: "Array<Range>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DeleteIncompleteRowsRequest.attributeTypeMap;

    }

    public file: FileInfo;
    public outFileFormat: string;
    public checkExcelRestriction: boolean;
    public region: string;
    public ranges: Array<Range>;

    public constructor(init?: Partial< DeleteIncompleteRowsRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// I can help with that. Just provide me with the features you'd like me to summarize.   
export class ImportPosition  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "sheetName",
            baseName: "SheetName",
            type: "string",
        },
        {
            name: "rowIndex",
            baseName: "RowIndex",
            type: "number",
        },
        {
            name: "columnIndex",
            baseName: "ColumnIndex",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ImportPosition.attributeTypeMap;

    }

    public sheetName: string;
    public rowIndex: number;
    public columnIndex: number;

    public constructor(init?: Partial< ImportPosition >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates import xml data request   
export class ImportJsonRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "jsonFileSource",
            baseName: "JsonFileSource",
            type: "DataSource",
        },
        {
            name: "importPosition",
            baseName: "ImportPosition",
            type: "ImportPosition",
        },
        {
            name: "jsonContent",
            baseName: "JsonContent",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ImportJsonRequest.attributeTypeMap;

    }

    public jsonFileSource: DataSource;
    public importPosition: ImportPosition;
    public jsonContent: string;

    public constructor(init?: Partial< ImportJsonRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates import xml data request   
export class ImportXMLRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "xMLFileSource",
            baseName: "XMLFileSource",
            type: "DataSource",
        },
        {
            name: "importPosition",
            baseName: "ImportPosition",
            type: "ImportPosition",
        },
        {
            name: "xMLContent",
            baseName: "XMLContent",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ImportXMLRequest.attributeTypeMap;

    }

    public xMLFileSource: DataSource;
    public importPosition: ImportPosition;
    public xMLContent: string;

    public constructor(init?: Partial< ImportXMLRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Used for password data transfer.   
export class PasswordRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "password",
            baseName: "Password",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  PasswordRequest.attributeTypeMap;

    }

    public password: string;

    public constructor(init?: Partial< PasswordRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates pivot table field request   
export class PivotTableFieldRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "data",
            baseName: "Data",
            type: "Array<number>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  PivotTableFieldRequest.attributeTypeMap;

    }

    public data: Array<number>;

    public constructor(init?: Partial< PivotTableFieldRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Signature in file.
///                
export class DigitalSignature  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "comments",
            baseName: "Comments",
            type: "string",
        },
        {
            name: "signTime",
            baseName: "SignTime",
            type: "string",
        },
        {
            name: "id",
            baseName: "Id",
            type: "string",
        },
        {
            name: "password",
            baseName: "Password",
            type: "string",
        },
        {
            name: "image",
            baseName: "Image",
            type: "Array<number>",
        },
        {
            name: "providerId",
            baseName: "ProviderId",
            type: "string",
        },
        {
            name: "isValid",
            baseName: "IsValid",
            type: "boolean",
        },
        {
            name: "xAdESType",
            baseName: "XAdESType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DigitalSignature.attributeTypeMap;

    }

    public comments: string;
    public signTime: string;
    public id: string;
    public password: string;
    public image: Array<number>;
    public providerId: string;
    public isValid: boolean;
    public xAdESType: string;

    public constructor(init?: Partial< DigitalSignature >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates protect workbook request   
export class ProtectWorkbookRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "awaysOpenReadOnly",
            baseName: "AwaysOpenReadOnly",
            type: "boolean",
        },
        {
            name: "encryptWithPassword",
            baseName: "EncryptWithPassword",
            type: "string",
        },
        {
            name: "protectCurrentSheet",
            baseName: "ProtectCurrentSheet",
            type: "Protection",
        },
        {
            name: "protectAllSheets",
            baseName: "ProtectAllSheets",
            type: "Protection",
        },
        {
            name: "protectWorkbookStructure",
            baseName: "ProtectWorkbookStructure",
            type: "string",
        },
        {
            name: "digitalSignature",
            baseName: "DigitalSignature",
            type: "DigitalSignature",
        },
        {
            name: "markAsFinal",
            baseName: "MarkAsFinal",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ProtectWorkbookRequest.attributeTypeMap;

    }

    public awaysOpenReadOnly: boolean;
    public encryptWithPassword: string;
    public protectCurrentSheet: Protection;
    public protectAllSheets: Protection;
    public protectWorkbookStructure: string;
    public digitalSignature: DigitalSignature;
    public markAsFinal: boolean;

    public constructor(init?: Partial< ProtectWorkbookRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates range copy request   
export class RangeConvertRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "source",
            baseName: "Source",
            type: "Range",
        },
        {
            name: "imageType",
            baseName: "ImageType",
            type: "string",
        },
        {
            name: "imageOrPrintOptions",
            baseName: "ImageOrPrintOptions",
            type: "ImageOrPrintOptions",
        },
        {
            name: "pageSetup",
            baseName: "PageSetup",
            type: "PageSetup",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  RangeConvertRequest.attributeTypeMap;

    }

    public source: Range;
    public imageType: string;
    public imageOrPrintOptions: ImageOrPrintOptions;
    public pageSetup: PageSetup;

    public constructor(init?: Partial< RangeConvertRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates range copy request   
export class RangeCopyRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "operate",
            baseName: "Operate",
            type: "string",
        },
        {
            name: "source",
            baseName: "Source",
            type: "Range",
        },
        {
            name: "target",
            baseName: "Target",
            type: "Range",
        },
        {
            name: "targetWorkbook",
            baseName: "TargetWorkbook",
            type: "string",
        },
        {
            name: "pasteOptions",
            baseName: "PasteOptions",
            type: "PasteOptions",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  RangeCopyRequest.attributeTypeMap;

    }

    public operate: string;
    public source: Range;
    public target: Range;
    public targetWorkbook: string;
    public pasteOptions: PasteOptions;

    public constructor(init?: Partial< RangeCopyRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates range set outline border request.   
export class RangeSetOutlineBorderRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "range",
            baseName: "Range",
            type: "Range",
        },
        {
            name: "borderEdge",
            baseName: "borderEdge",
            type: "string",
        },
        {
            name: "borderStyle",
            baseName: "borderStyle",
            type: "string",
        },
        {
            name: "borderColor",
            baseName: "borderColor",
            type: "Color",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  RangeSetOutlineBorderRequest.attributeTypeMap;

    }

    public range: Range;
    public borderEdge: string;
    public borderStyle: string;
    public borderColor: Color;

    public constructor(init?: Partial< RangeSetOutlineBorderRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates range set style request.   
export class RangeSetStyleRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "range",
            baseName: "Range",
            type: "Range",
        },
        {
            name: "style",
            baseName: "Style",
            type: "Style",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  RangeSetStyleRequest.attributeTypeMap;

    }

    public range: Range;
    public style: Style;

    public constructor(init?: Partial< RangeSetStyleRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates range sort request   
export class RangeSortRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSorter",
            baseName: "DataSorter",
            type: "DataSorter",
        },
        {
            name: "cellArea",
            baseName: "CellArea",
            type: "Range",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  RangeSortRequest.attributeTypeMap;

    }

    public dataSorter: DataSorter;
    public cellArea: Range;

    public constructor(init?: Partial< RangeSortRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates table total request   
export class TableTotalRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "listColumnIndex",
            baseName: "ListColumnIndex",
            type: "number",
        },
        {
            name: "totalsCalculation",
            baseName: "TotalsCalculation",
            type: "string",
        },
        {
            name: "customFormula",
            baseName: "CustomFormula",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  TableTotalRequest.attributeTypeMap;

    }

    public listColumnIndex: number;
    public totalsCalculation: string;
    public customFormula: string;

    public constructor(init?: Partial< TableTotalRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Indicates text water marker request.   
export class TextWaterMarkerRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "text",
            baseName: "Text",
            type: "string",
        },
        {
            name: "fontName",
            baseName: "FontName",
            type: "string",
        },
        {
            name: "fontSize",
            baseName: "FontSize",
            type: "number",
        },
        {
            name: "height",
            baseName: "Height",
            type: "number",
        },
        {
            name: "width",
            baseName: "Width",
            type: "number",
        },
        {
            name: "imageAdaptOption",
            baseName: "ImageAdaptOption",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  TextWaterMarkerRequest.attributeTypeMap;

    }

    public text: string;
    public fontName: string;
    public fontSize: number;
    public height: number;
    public width: number;
    public imageAdaptOption: string;

    public constructor(init?: Partial< TextWaterMarkerRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Used by workbook encryption/decryption requests.   
export class WorkbookEncryptionRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "encryptionType",
            baseName: "EncryptionType",
            type: "string",
        },
        {
            name: "keyLength",
            baseName: "KeyLength",
            type: "number",
        },
        {
            name: "password",
            baseName: "Password",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  WorkbookEncryptionRequest.attributeTypeMap;

    }

    public encryptionType: string;
    public keyLength: number;
    public password: string;

    public constructor(init?: Partial< WorkbookEncryptionRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// Used by workbook protection requests.   
export class WorkbookProtectionRequest  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "protectionType",
            baseName: "ProtectionType",
            type: "string",
        },
        {
            name: "password",
            baseName: "Password",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  WorkbookProtectionRequest.attributeTypeMap;

    }

    public protectionType: string;
    public password: string;

    public constructor(init?: Partial< WorkbookProtectionRequest >) {  
    
        Object.assign(this, init);
    } 
}
/// A data operation that is used to obtain a query of data.   
export class AppliedOperate  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "appliedOperateType",
            baseName: "AppliedOperateType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  AppliedOperate.attributeTypeMap;

    }

    public appliedOperateType: string;

    public constructor(init?: Partial< AppliedOperate >) {  
    
        Object.assign(this, init);
    } 
}
/// Data query.   
export class DataQuery  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "dataSourceDataType",
            baseName: "DataSourceDataType",
            type: "string",
        },
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "fileInfo",
            baseName: "FileInfo",
            type: "FileInfo",
        },
        {
            name: "dataItem",
            baseName: "DataItem",
            type: "DataItem",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DataQuery.attributeTypeMap;

    }

    public name: string;
    public dataSourceDataType: string;
    public dataSource: DataSource;
    public fileInfo: FileInfo;
    public dataItem: DataItem;

    public constructor(init?: Partial< DataQuery >) {  
    
        Object.assign(this, init);
    } 
}
/// A description of the location to which the data is mounted.   
export class LoadTo  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "worksheet",
            baseName: "Worksheet",
            type: "string",
        },
        {
            name: "beginRowIndex",
            baseName: "beginRowIndex",
            type: "number",
        },
        {
            name: "beginColumnIndex",
            baseName: "beginColumnIndex",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  LoadTo.attributeTypeMap;

    }

    public worksheet: string;
    public beginRowIndex: number;
    public beginColumnIndex: number;

    public constructor(init?: Partial< LoadTo >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents merge quesies.   
export class MergeQueries  extends AppliedOperate  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataQueryNameA",
            baseName: "DataQueryNameA",
            type: "string",
        },
        {
            name: "dataAIndexField",
            baseName: "DataAIndexField",
            type: "string",
        },
        {
            name: "dataQueryNameB",
            baseName: "DataQueryNameB",
            type: "string",
        },
        {
            name: "dataBIndexField",
            baseName: "DataBIndexField",
            type: "string",
        },
        {
            name: "joinType",
            baseName: "JoinType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(MergeQueries.attributeTypeMap) ;

    }

    public dataQueryNameA: string;
    public dataAIndexField: string;
    public dataQueryNameB: string;
    public dataBIndexField: string;
    public joinType: string;

    public constructor(init?: Partial< MergeQueries >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Represents pivot column for data table.   
export class PivotColumn  extends AppliedOperate  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pivotColumnName",
            baseName: "PivotColumnName",
            type: "string",
        },
        {
            name: "valueColumnNames",
            baseName: "ValueColumnNames",
            type: "Array<string>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PivotColumn.attributeTypeMap) ;

    }

    public pivotColumnName: string;
    public valueColumnNames: Array<string>;

    public constructor(init?: Partial< PivotColumn >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Unpivot column.   
export class UnpivotColumn  extends AppliedOperate  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "unpivotColumnNames",
            baseName: "UnpivotColumnNames",
            type: "Array<string>",
        },
        {
            name: "columnMapName",
            baseName: "ColumnMapName",
            type: "string",
        },
        {
            name: "valueMapName",
            baseName: "ValueMapName",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(UnpivotColumn.attributeTypeMap) ;

    }

    public unpivotColumnNames: Array<string>;
    public columnMapName: string;
    public valueMapName: string;

    public constructor(init?: Partial< UnpivotColumn >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///            Represents a item in a PivotField report.
///               
export class PivotItem  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "index",
            baseName: "Index",
            type: "number",
        },
        {
            name: "isHidden",
            baseName: "IsHidden",
            type: "boolean",
        },
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "value",
            baseName: "Value",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  PivotItem.attributeTypeMap;

    }

    public index: number;
    public isHidden: boolean;
    public name: string;
    public value: string;

    public constructor(init?: Partial< PivotItem >) {  
    
        Object.assign(this, init);
    } 
}
///    
export class BaseOperateOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  BaseOperateOptions.attributeTypeMap;

    }

    public name: string;

    public constructor(init?: Partial< BaseOperateOptions >) {  
    
        Object.assign(this, init);
    } 
}
/// Class summary: The features of this class include hands-on learning activities, group projects, interactive discussions, guest speakers, and field trips to real-world applications.   
export class AddTextOptions  extends BaseOperateOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "fileInfo",
            baseName: "FileInfo",
            type: "FileInfo",
        },
        {
            name: "text",
            baseName: "Text",
            type: "string",
        },
        {
            name: "worksheet",
            baseName: "Worksheet",
            type: "string",
        },
        {
            name: "range",
            baseName: "Range",
            type: "string",
        },
        {
            name: "selectPoistion",
            baseName: "SelectPoistion",
            type: "string",
        },
        {
            name: "selectText",
            baseName: "SelectText",
            type: "string",
        },
        {
            name: "skipEmptyCells",
            baseName: "SkipEmptyCells",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(AddTextOptions.attributeTypeMap) ;

    }

    public dataSource: DataSource;
    public fileInfo: FileInfo;
    public text: string;
    public worksheet: string;
    public range: string;
    public selectPoistion: string;
    public selectText: string;
    public skipEmptyCells: boolean;

    public constructor(init?: Partial< AddTextOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class CharacterCountOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "fileInfo",
            baseName: "FileInfo",
            type: "FileInfo",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CharacterCountOptions.attributeTypeMap;

    }

    public dataSource: DataSource;
    public fileInfo: FileInfo;

    public constructor(init?: Partial< CharacterCountOptions >) {  
    
        Object.assign(this, init);
    } 
}
   
export class CheckExternalReferenceOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "fileInfo",
            baseName: "FileInfo",
            type: "FileInfo",
        },
        {
            name: "worksheet",
            baseName: "Worksheet",
            type: "string",
        },
        {
            name: "ranged_Table",
            baseName: "Ranged_Table",
            type: "string",
        },
        {
            name: "chartIndex",
            baseName: "ChartIndex",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CheckExternalReferenceOptions.attributeTypeMap;

    }

    public dataSource: DataSource;
    public fileInfo: FileInfo;
    public worksheet: string;
    public ranged_Table: string;
    public chartIndex: number;

    public constructor(init?: Partial< CheckExternalReferenceOptions >) {  
    
        Object.assign(this, init);
    } 
}
   
export class CheckFormulaErrorOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "fileInfo",
            baseName: "FileInfo",
            type: "FileInfo",
        },
        {
            name: "sheetName",
            baseName: "SheetName",
            type: "string",
        },
        {
            name: "chartIndex",
            baseName: "ChartIndex",
            type: "number",
        },
        {
            name: "names",
            baseName: "Names",
            type: "Array<string>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CheckFormulaErrorOptions.attributeTypeMap;

    }

    public dataSource: DataSource;
    public fileInfo: FileInfo;
    public sheetName: string;
    public chartIndex: number;
    public names: Array<string>;

    public constructor(init?: Partial< CheckFormulaErrorOptions >) {  
    
        Object.assign(this, init);
    } 
}
   
export class CombinationSourceData  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "tag",
            baseName: "Tag",
            type: "string",
        },
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "fileInfo",
            baseName: "FileInfo",
            type: "FileInfo",
        },
        {
            name: "worksheet",
            baseName: "Worksheet",
            type: "string",
        },
        {
            name: "tableName",
            baseName: "TableName",
            type: "string",
        },
        {
            name: "cellArea",
            baseName: "CellArea",
            type: "string",
        },
        {
            name: "hasHeader",
            baseName: "HasHeader",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CombinationSourceData.attributeTypeMap;

    }

    public tag: string;
    public dataSource: DataSource;
    public fileInfo: FileInfo;
    public worksheet: string;
    public tableName: string;
    public cellArea: string;
    public hasHeader: boolean;

    public constructor(init?: Partial< CombinationSourceData >) {  
    
        Object.assign(this, init);
    } 
}
/// Class summary: The features of the new smartphone include a high-resolution display, multiple camera lenses for versatile photography, a fast processor for seamless performance, and a larger battery for extended usage time.   
export class ConvertTextOptions  extends BaseOperateOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "fileInfo",
            baseName: "FileInfo",
            type: "FileInfo",
        },
        {
            name: "worksheet",
            baseName: "Worksheet",
            type: "string",
        },
        {
            name: "range",
            baseName: "Range",
            type: "string",
        },
        {
            name: "convertTextType",
            baseName: "ConvertTextType",
            type: "string",
        },
        {
            name: "sourceCharacters",
            baseName: "SourceCharacters",
            type: "string",
        },
        {
            name: "targetCharacters",
            baseName: "TargetCharacters",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ConvertTextOptions.attributeTypeMap) ;

    }

    public dataSource: DataSource;
    public fileInfo: FileInfo;
    public worksheet: string;
    public range: string;
    public convertTextType: string;
    public sourceCharacters: string;
    public targetCharacters: string;

    public constructor(init?: Partial< ConvertTextOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class ConvertWorkbookOptions  extends BaseOperateOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "fileInfo",
            baseName: "FileInfo",
            type: "FileInfo",
        },
        {
            name: "pageSetup",
            baseName: "PageSetup",
            type: "PageSetup",
        },
        {
            name: "saveOptions",
            baseName: "SaveOptions",
            type: "SaveOptions",
        },
        {
            name: "convertFormat",
            baseName: "ConvertFormat",
            type: "string",
        },
        {
            name: "checkExcelRestriction",
            baseName: "CheckExcelRestriction",
            type: "boolean",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ConvertWorkbookOptions.attributeTypeMap) ;

    }

    public dataSource: DataSource;
    public fileInfo: FileInfo;
    public pageSetup: PageSetup;
    public saveOptions: SaveOptions;
    public convertFormat: string;
    public checkExcelRestriction: boolean;

    public constructor(init?: Partial< ConvertWorkbookOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class ConvertWorksheetOptions  extends BaseOperateOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "fileInfo",
            baseName: "FileInfo",
            type: "FileInfo",
        },
        {
            name: "worksheetName",
            baseName: "WorksheetName",
            type: "string",
        },
        {
            name: "pageSetup",
            baseName: "PageSetup",
            type: "PageSetup",
        },
        {
            name: "imageOrPrintOptions",
            baseName: "ImageOrPrintOptions",
            type: "ImageOrPrintOptions",
        },
        {
            name: "convertFormat",
            baseName: "ConvertFormat",
            type: "string",
        },
        {
            name: "checkExcelRestriction",
            baseName: "CheckExcelRestriction",
            type: "boolean",
        },
        {
            name: "region",
            baseName: "Region",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ConvertWorksheetOptions.attributeTypeMap) ;

    }

    public dataSource: DataSource;
    public fileInfo: FileInfo;
    public worksheetName: string;
    public pageSetup: PageSetup;
    public imageOrPrintOptions: ImageOrPrintOptions;
    public convertFormat: string;
    public checkExcelRestriction: boolean;
    public region: string;

    public constructor(init?: Partial< ConvertWorksheetOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class DataOutputLocation  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "fileInfo",
            baseName: "FileInfo",
            type: "FileInfo",
        },
        {
            name: "worksheet",
            baseName: "Worksheet",
            type: "string",
        },
        {
            name: "beginRowIndex",
            baseName: "BeginRowIndex",
            type: "number",
        },
        {
            name: "beginColumnIndex",
            baseName: "BeginColumnIndex",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DataOutputLocation.attributeTypeMap;

    }

    public dataSource: DataSource;
    public fileInfo: FileInfo;
    public worksheet: string;
    public beginRowIndex: number;
    public beginColumnIndex: number;

    public constructor(init?: Partial< DataOutputLocation >) {  
    
        Object.assign(this, init);
    } 
}
/// I'm happy to help! Could you please provide me with the features you would like me to summarize for you?   
export class ExtractTextOptions  extends BaseOperateOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "fileInfo",
            baseName: "FileInfo",
            type: "FileInfo",
        },
        {
            name: "worksheet",
            baseName: "Worksheet",
            type: "string",
        },
        {
            name: "range",
            baseName: "Range",
            type: "string",
        },
        {
            name: "extractTextType",
            baseName: "ExtractTextType",
            type: "string",
        },
        {
            name: "beforeText",
            baseName: "BeforeText",
            type: "string",
        },
        {
            name: "afterText",
            baseName: "AfterText",
            type: "string",
        },
        {
            name: "beforePosition",
            baseName: "BeforePosition",
            type: "number",
        },
        {
            name: "afterPosition",
            baseName: "AfterPosition",
            type: "number",
        },
        {
            name: "outPositionRange",
            baseName: "OutPositionRange",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ExtractTextOptions.attributeTypeMap) ;

    }

    public dataSource: DataSource;
    public fileInfo: FileInfo;
    public worksheet: string;
    public range: string;
    public extractTextType: string;
    public beforeText: string;
    public afterText: string;
    public beforePosition: number;
    public afterPosition: number;
    public outPositionRange: string;

    public constructor(init?: Partial< ExtractTextOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class MergeTableOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "mainTable",
            baseName: "MainTable",
            type: "CombinationSourceData",
        },
        {
            name: "secondaryTable",
            baseName: "SecondaryTable",
            type: "CombinationSourceData",
        },
        {
            name: "dataMergeType",
            baseName: "DataMergeType",
            type: "string",
        },
        {
            name: "overwriteMainTable",
            baseName: "OverwriteMainTable",
            type: "boolean",
        },
        {
            name: "syncDataToTargetWorkbook",
            baseName: "SyncDataToTargetWorkbook",
            type: "boolean",
        },
        {
            name: "mergedDataToPosition",
            baseName: "MergedDataToPosition",
            type: "DataOutputLocation",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  MergeTableOptions.attributeTypeMap;

    }

    public mainTable: CombinationSourceData;
    public secondaryTable: CombinationSourceData;
    public dataMergeType: string;
    public overwriteMainTable: boolean;
    public syncDataToTargetWorkbook: boolean;
    public mergedDataToPosition: DataOutputLocation;

    public constructor(init?: Partial< MergeTableOptions >) {  
    
        Object.assign(this, init);
    } 
}
/// Class summary: The features include fast and reliable performance, high-quality camera with portrait mode, long-lasting battery life, and a durable water-resistant design.
///                
export class RemoveCharactersByCharacter  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "removeTextMethod",
            baseName: "RemoveTextMethod",
            type: "string",
        },
        {
            name: "removeCharacters",
            baseName: "RemoveCharacters",
            type: "Array<string>",
        },
        {
            name: "removeCharacterSetsType",
            baseName: "RemoveCharacterSetsType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  RemoveCharactersByCharacter.attributeTypeMap;

    }

    public removeTextMethod: string;
    public removeCharacters: Array<string>;
    public removeCharacterSetsType: string;

    public constructor(init?: Partial< RemoveCharactersByCharacter >) {  
    
        Object.assign(this, init);
    } 
}
/// Class summary: Important features to consider when designing a new website include user-friendly navigation, responsive design for different devices, visually appealing layouts, and fast loading speed.
///                
export class RemoveCharactersByPosition  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "theFirstNCharacters",
            baseName: "TheFirstNCharacters",
            type: "number",
        },
        {
            name: "theLastNCharacters",
            baseName: "TheLastNCharacters",
            type: "number",
        },
        {
            name: "allCharactersBeforeText",
            baseName: "AllCharactersBeforeText",
            type: "string",
        },
        {
            name: "allCharactersAfterText",
            baseName: "AllCharactersAfterText",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  RemoveCharactersByPosition.attributeTypeMap;

    }

    public theFirstNCharacters: number;
    public theLastNCharacters: number;
    public allCharactersBeforeText: string;
    public allCharactersAfterText: string;

    public constructor(init?: Partial< RemoveCharactersByPosition >) {  
    
        Object.assign(this, init);
    } 
}
/// Class summary: The class features discussing effective communication strategies, developing problem-solving skills, and increasing self-awareness for personal growth.   
export class RemoveCharactersOptions  extends BaseOperateOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "fileInfo",
            baseName: "FileInfo",
            type: "FileInfo",
        },
        {
            name: "worksheet",
            baseName: "Worksheet",
            type: "string",
        },
        {
            name: "range",
            baseName: "Range",
            type: "string",
        },
        {
            name: "removeCharactersByCharacter",
            baseName: "RemoveCharactersByCharacter",
            type: "RemoveCharactersByCharacter",
        },
        {
            name: "removeCharactersByPosition",
            baseName: "RemoveCharactersByPosition",
            type: "RemoveCharactersByPosition",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(RemoveCharactersOptions.attributeTypeMap) ;

    }

    public dataSource: DataSource;
    public fileInfo: FileInfo;
    public worksheet: string;
    public range: string;
    public removeCharactersByCharacter: RemoveCharactersByCharacter;
    public removeCharactersByPosition: RemoveCharactersByPosition;

    public constructor(init?: Partial< RemoveCharactersOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// I'm here to help! Just let me know the features you would like me to summarize for you.   
export class RemoveDuplicatesOptions  extends BaseOperateOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "fileInfo",
            baseName: "FileInfo",
            type: "FileInfo",
        },
        {
            name: "worksheet",
            baseName: "Worksheet",
            type: "string",
        },
        {
            name: "removeDuplicatesArea",
            baseName: "RemoveDuplicatesArea",
            type: "string",
        },
        {
            name: "removeDuplicatesAreaValue",
            baseName: "RemoveDuplicatesAreaValue",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(RemoveDuplicatesOptions.attributeTypeMap) ;

    }

    public dataSource: DataSource;
    public fileInfo: FileInfo;
    public worksheet: string;
    public removeDuplicatesArea: string;
    public removeDuplicatesAreaValue: string;

    public constructor(init?: Partial< RemoveDuplicatesOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// I'm happy to help! Please provide me with the features you would like me to summarize for the class.
///                
export class ScopeItem  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "worksheetName",
            baseName: "WorksheetName",
            type: "string",
        },
        {
            name: "ranges",
            baseName: "Ranges",
            type: "Array<string>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ScopeItem.attributeTypeMap;

    }

    public worksheetName: string;
    public ranges: Array<string>;

    public constructor(init?: Partial< ScopeItem >) {  
    
        Object.assign(this, init);
    } 
}
/// Here is the class summary: "The features discussed include real-time collaboration, templates for various projects, task assignment and tracking, deadline reminders, and file storage and sharing."
///                
export class ScopeOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "scope",
            baseName: "Scope",
            type: "string",
        },
        {
            name: "scopeItems",
            baseName: "ScopeItems",
            type: "Array<ScopeItem>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ScopeOptions.attributeTypeMap;

    }

    public scope: string;
    public scopeItems: Array<ScopeItem>;

    public constructor(init?: Partial< ScopeOptions >) {  
    
        Object.assign(this, init);
    } 
}
   
export class SpecifyCellsObject  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "worksheetName",
            baseName: "WorksheetName",
            type: "string",
        },
        {
            name: "pageIndex",
            baseName: "PageIndex",
            type: "number",
        },
        {
            name: "region",
            baseName: "Region",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  SpecifyCellsObject.attributeTypeMap;

    }

    public worksheetName: string;
    public pageIndex: number;
    public region: string;

    public constructor(init?: Partial< SpecifyCellsObject >) {  
    
        Object.assign(this, init);
    } 
}
   
export class SpecifyWordsCountOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "fileInfo",
            baseName: "FileInfo",
            type: "FileInfo",
        },
        {
            name: "searchWord",
            baseName: "SearchWord",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  SpecifyWordsCountOptions.attributeTypeMap;

    }

    public dataSource: DataSource;
    public fileInfo: FileInfo;
    public searchWord: string;

    public constructor(init?: Partial< SpecifyWordsCountOptions >) {  
    
        Object.assign(this, init);
    } 
}
/// Appliance features: 1. Automatic defrost system 2. Energy-efficient LED lighting 3. Adjustable glass shelves 4. Ice and water dispenser with filtration system   
export class SplitTextOptions  extends BaseOperateOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "fileInfo",
            baseName: "FileInfo",
            type: "FileInfo",
        },
        {
            name: "worksheet",
            baseName: "Worksheet",
            type: "string",
        },
        {
            name: "range",
            baseName: "Range",
            type: "string",
        },
        {
            name: "splitDelimitersType",
            baseName: "SplitDelimitersType",
            type: "string",
        },
        {
            name: "customDelimiter",
            baseName: "CustomDelimiter",
            type: "string",
        },
        {
            name: "keepDelimitersInResultingCells",
            baseName: "KeepDelimitersInResultingCells",
            type: "boolean",
        },
        {
            name: "keepDelimitersPosition",
            baseName: "KeepDelimitersPosition",
            type: "string",
        },
        {
            name: "howToSplit",
            baseName: "HowToSplit",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(SplitTextOptions.attributeTypeMap) ;

    }

    public dataSource: DataSource;
    public fileInfo: FileInfo;
    public worksheet: string;
    public range: string;
    public splitDelimitersType: string;
    public customDelimiter: string;
    public keepDelimitersInResultingCells: boolean;
    public keepDelimitersPosition: string;
    public howToSplit: string;

    public constructor(init?: Partial< SplitTextOptions >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
   
export class TablePositionInfo  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  TablePositionInfo.attributeTypeMap;

    }


    public constructor(init?: Partial< TablePositionInfo >) {  
    
        Object.assign(this, init);
    } 
}
/// I'm sorry, but you haven't provided any specific content for me to summarize. Please provide the features you would like to be summarized.
///                
export class TrimContentOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "fileInfo",
            baseName: "FileInfo",
            type: "FileInfo",
        },
        {
            name: "trimContent",
            baseName: "TrimContent",
            type: "string",
        },
        {
            name: "trimLeading",
            baseName: "TrimLeading",
            type: "boolean",
        },
        {
            name: "trimTrailing",
            baseName: "TrimTrailing",
            type: "boolean",
        },
        {
            name: "trimSpaceBetweenWordTo1",
            baseName: "TrimSpaceBetweenWordTo1",
            type: "boolean",
        },
        {
            name: "trimNonBreakingSpaces",
            baseName: "TrimNonBreakingSpaces",
            type: "boolean",
        },
        {
            name: "removeExtraLineBreaks",
            baseName: "RemoveExtraLineBreaks",
            type: "boolean",
        },
        {
            name: "removeAllLineBreaks",
            baseName: "RemoveAllLineBreaks",
            type: "boolean",
        },
        {
            name: "scopeOptions",
            baseName: "ScopeOptions",
            type: "ScopeOptions",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  TrimContentOptions.attributeTypeMap;

    }

    public dataSource: DataSource;
    public fileInfo: FileInfo;
    public trimContent: string;
    public trimLeading: boolean;
    public trimTrailing: boolean;
    public trimSpaceBetweenWordTo1: boolean;
    public trimNonBreakingSpaces: boolean;
    public removeExtraLineBreaks: boolean;
    public removeAllLineBreaks: boolean;
    public scopeOptions: ScopeOptions;

    public constructor(init?: Partial< TrimContentOptions >) {  
    
        Object.assign(this, init);
    } 
}
/// I'm here to assist you. Please provide the features you would like me to summarize for the class.
///                
export class WordCaseOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "fileInfo",
            baseName: "FileInfo",
            type: "FileInfo",
        },
        {
            name: "wordCaseType",
            baseName: "WordCaseType",
            type: "string",
        },
        {
            name: "scopeOptions",
            baseName: "ScopeOptions",
            type: "ScopeOptions",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  WordCaseOptions.attributeTypeMap;

    }

    public dataSource: DataSource;
    public fileInfo: FileInfo;
    public wordCaseType: string;
    public scopeOptions: ScopeOptions;

    public constructor(init?: Partial< WordCaseOptions >) {  
    
        Object.assign(this, init);
    } 
}
   
export class WordsCountOptions  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "dataSource",
            baseName: "DataSource",
            type: "DataSource",
        },
        {
            name: "fileInfo",
            baseName: "FileInfo",
            type: "FileInfo",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  WordsCountOptions.attributeTypeMap;

    }

    public dataSource: DataSource;
    public fileInfo: FileInfo;

    public constructor(init?: Partial< WordsCountOptions >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents the cell value and corresponding type.   
export class CellValue  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "rowIndex",
            baseName: "rowIndex",
            type: "number",
        },
        {
            name: "columnIndex",
            baseName: "columnIndex",
            type: "number",
        },
        {
            name: "type",
            baseName: "type",
            type: "string",
        },
        {
            name: "value",
            baseName: "value",
            type: "string",
        },
        {
            name: "formula",
            baseName: "formula",
            type: "string",
        },
        {
            name: "style",
            baseName: "style",
            type: "Style",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CellValue.attributeTypeMap;

    }

    public rowIndex: number;
    public columnIndex: number;
    public type: string;
    public value: string;
    public formula: string;
    public style: Style;

    public constructor(init?: Partial< CellValue >) {  
    
        Object.assign(this, init);
    } 
}
/// I'm happy to help! Please provide me with the features you would like me to summarize for the class.   
export class CustomParserConfig  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "columnIndex",
            baseName: "ColumnIndex",
            type: "number",
        },
        {
            name: "parseMethod",
            baseName: "ParseMethod",
            type: "string",
        },
        {
            name: "customStyle",
            baseName: "CustomStyle",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  CustomParserConfig.attributeTypeMap;

    }

    public columnIndex: number;
    public parseMethod: string;
    public customStyle: string;

    public constructor(init?: Partial< CustomParserConfig >) {  
    
        Object.assign(this, init);
    } 
}
/// I can help summarize features, please provide the details you'd like me to summarize.   
export class Import2DimensionDoubleArrayOption  extends ImportOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "firstRow",
            baseName: "FirstRow",
            type: "number",
        },
        {
            name: "firstColumn",
            baseName: "FirstColumn",
            type: "number",
        },
        {
            name: "data",
            baseName: "Data",
            type: "Array<number>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Import2DimensionDoubleArrayOption.attributeTypeMap) ;

    }

    public firstRow: number;
    public firstColumn: number;
    public data: Array<number>;

    public constructor(init?: Partial< Import2DimensionDoubleArrayOption >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// I'm here to help! Please provide the features you'd like me to summarize.   
export class Import2DimensionIntArrayOption  extends ImportOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "firstRow",
            baseName: "FirstRow",
            type: "number",
        },
        {
            name: "firstColumn",
            baseName: "FirstColumn",
            type: "number",
        },
        {
            name: "data",
            baseName: "Data",
            type: "Array<number>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Import2DimensionIntArrayOption.attributeTypeMap) ;

    }

    public firstRow: number;
    public firstColumn: number;
    public data: Array<number>;

    public constructor(init?: Partial< Import2DimensionIntArrayOption >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// I'm eager to assist you! Please provide me with the features you would like me to summarize into one sentence for your class summary.   
export class Import2DimensionStringArrayOption  extends ImportOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "firstRow",
            baseName: "FirstRow",
            type: "number",
        },
        {
            name: "firstColumn",
            baseName: "FirstColumn",
            type: "number",
        },
        {
            name: "data",
            baseName: "Data",
            type: "Array<string>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Import2DimensionStringArrayOption.attributeTypeMap) ;

    }

    public firstRow: number;
    public firstColumn: number;
    public data: Array<string>;

    public constructor(init?: Partial< Import2DimensionStringArrayOption >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// I'm sorry, but it seems like you haven't provided any features for me to summarize. Could you please share the features you'd like me to summarize into a single sentence for your class?   
export class ImportBatchDataOption  extends ImportOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "batchData",
            baseName: "BatchData",
            type: "Array<CellValue>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImportBatchDataOption.attributeTypeMap) ;

    }

    public batchData: Array<CellValue>;

    public constructor(init?: Partial< ImportBatchDataOption >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// I'm happy to help! Could you please provide me with the features you would like me to summarize into a class summary?   
export class ImportCSVDataOption  extends ImportOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "separatorString",
            baseName: "SeparatorString",
            type: "string",
        },
        {
            name: "convertNumericData",
            baseName: "ConvertNumericData",
            type: "boolean",
        },
        {
            name: "firstRow",
            baseName: "FirstRow",
            type: "number",
        },
        {
            name: "firstColumn",
            baseName: "FirstColumn",
            type: "number",
        },
        {
            name: "sourceFile",
            baseName: "SourceFile",
            type: "string",
        },
        {
            name: "customParsers",
            baseName: "CustomParsers",
            type: "Array<CustomParserConfig>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImportCSVDataOption.attributeTypeMap) ;

    }

    public separatorString: string;
    public convertNumericData: boolean;
    public firstRow: number;
    public firstColumn: number;
    public sourceFile: string;
    public customParsers: Array<CustomParserConfig>;

    public constructor(init?: Partial< ImportCSVDataOption >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Class summary: The features include grammar and spell check, word count, readability analysis, and style suggestions for improving writing.   
export class ImportDoubleArrayOption  extends ImportOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "firstRow",
            baseName: "FirstRow",
            type: "number",
        },
        {
            name: "firstColumn",
            baseName: "FirstColumn",
            type: "number",
        },
        {
            name: "isVertical",
            baseName: "IsVertical",
            type: "boolean",
        },
        {
            name: "data",
            baseName: "Data",
            type: "Array<number>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImportDoubleArrayOption.attributeTypeMap) ;

    }

    public firstRow: number;
    public firstColumn: number;
    public isVertical: boolean;
    public data: Array<number>;

    public constructor(init?: Partial< ImportDoubleArrayOption >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// I'm here to help! Just provide me with the features you'd like to summarize.   
export class ImportIntArrayOption  extends ImportOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "firstRow",
            baseName: "FirstRow",
            type: "number",
        },
        {
            name: "firstColumn",
            baseName: "FirstColumn",
            type: "number",
        },
        {
            name: "isVertical",
            baseName: "IsVertical",
            type: "boolean",
        },
        {
            name: "data",
            baseName: "Data",
            type: "Array<number>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImportIntArrayOption.attributeTypeMap) ;

    }

    public firstRow: number;
    public firstColumn: number;
    public isVertical: boolean;
    public data: Array<number>;

    public constructor(init?: Partial< ImportIntArrayOption >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// Class summary: The features of the topic were explored, discussing its components, patterns, and significance.   
export class ImportPictureOption  extends ImportOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "upperLeftRow",
            baseName: "UpperLeftRow",
            type: "number",
        },
        {
            name: "upperLeftColumn",
            baseName: "UpperLeftColumn",
            type: "number",
        },
        {
            name: "lowerRightRow",
            baseName: "LowerRightRow",
            type: "number",
        },
        {
            name: "lowerRightColumn",
            baseName: "LowerRightColumn",
            type: "number",
        },
        {
            name: "filename",
            baseName: "Filename",
            type: "string",
        },
        {
            name: "data",
            baseName: "Data",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImportPictureOption.attributeTypeMap) ;

    }

    public upperLeftRow: number;
    public upperLeftColumn: number;
    public lowerRightRow: number;
    public lowerRightColumn: number;
    public filename: string;
    public data: string;

    public constructor(init?: Partial< ImportPictureOption >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// I'm happy to help! Could you please provide me with the features you would like me to summarize for the class?   
export class ImportStringArrayOption  extends ImportOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "firstRow",
            baseName: "FirstRow",
            type: "number",
        },
        {
            name: "firstColumn",
            baseName: "FirstColumn",
            type: "number",
        },
        {
            name: "isVertical",
            baseName: "IsVertical",
            type: "boolean",
        },
        {
            name: "data",
            baseName: "Data",
            type: "Array<string>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ImportStringArrayOption.attributeTypeMap) ;

    }

    public firstRow: number;
    public firstColumn: number;
    public isVertical: boolean;
    public data: Array<string>;

    public constructor(init?: Partial< ImportStringArrayOption >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///            Represents the gradient fill.
///               
export class GradientFill  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "fillType",
            baseName: "FillType",
            type: "string",
        },
        {
            name: "directionType",
            baseName: "DirectionType",
            type: "string",
        },
        {
            name: "angle",
            baseName: "Angle",
            type: "number",
        },
        {
            name: "gradientStops",
            baseName: "GradientStops",
            type: "Array<GradientFillStop>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  GradientFill.attributeTypeMap;

    }

    public fillType: string;
    public directionType: string;
    public angle: number;
    public gradientStops: Array<GradientFillStop>;

    public constructor(init?: Partial< GradientFill >) {  
    
        Object.assign(this, init);
    } 
}
///            Encapsulates the object that represents pattern fill format
///               
export class PatternFill  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "pattern",
            baseName: "Pattern",
            type: "string",
        },
        {
            name: "backgroundCellsColor",
            baseName: "BackgroundCellsColor",
            type: "CellsColor",
        },
        {
            name: "foregroundCellsColor",
            baseName: "ForegroundCellsColor",
            type: "CellsColor",
        },
        {
            name: "foregroundColor",
            baseName: "ForegroundColor",
            type: "Color",
        },
        {
            name: "backgroundColor",
            baseName: "BackgroundColor",
            type: "Color",
        },
        {
            name: "backTransparency",
            baseName: "BackTransparency",
            type: "number",
        },
        {
            name: "foreTransparency",
            baseName: "ForeTransparency",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  PatternFill.attributeTypeMap;

    }

    public pattern: string;
    public backgroundCellsColor: CellsColor;
    public foregroundCellsColor: CellsColor;
    public foregroundColor: Color;
    public backgroundColor: Color;
    public backTransparency: number;
    public foreTransparency: number;

    public constructor(init?: Partial< PatternFill >) {  
    
        Object.assign(this, init);
    } 
}
///            Encapsulates the object that represents solid fill format
///               
export class SolidFill  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "color",
            baseName: "Color",
            type: "Color",
        },
        {
            name: "cellsColor",
            baseName: "CellsColor",
            type: "CellsColor",
        },
        {
            name: "transparency",
            baseName: "Transparency",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  SolidFill.attributeTypeMap;

    }

    public color: Color;
    public cellsColor: CellsColor;
    public transparency: number;

    public constructor(init?: Partial< SolidFill >) {  
    
        Object.assign(this, init);
    } 
}
///            Encapsulates the object that represents texture fill format
///               
export class TextureFill  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "transparency",
            baseName: "Transparency",
            type: "number",
        },
        {
            name: "scale",
            baseName: "Scale",
            type: "number",
        },
        {
            name: "tilePicOption",
            baseName: "TilePicOption",
            type: "TilePicOption",
        },
        {
            name: "picFormatOption",
            baseName: "PicFormatOption",
            type: "PicFormatOption",
        },
        {
            name: "image",
            baseName: "Image",
            type: "LinkElement",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  TextureFill.attributeTypeMap;

    }

    public type: string;
    public transparency: number;
    public scale: number;
    public tilePicOption: TilePicOption;
    public picFormatOption: PicFormatOption;
    public image: LinkElement;

    public constructor(init?: Partial< TextureFill >) {  
    
        Object.assign(this, init);
    } 
}
/// Class summary: Understanding the various features and tools available in Adobe Illustrator to create dynamic and professional vector graphics, including shapes, text, brushes, gradients, and layers.   
export class GradientFillStop  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "color",
            baseName: "Color",
            type: "Color",
        },
        {
            name: "position",
            baseName: "Position",
            type: "number",
        },
        {
            name: "transparency",
            baseName: "Transparency",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  GradientFillStop.attributeTypeMap;

    }

    public color: Color;
    public position: number;
    public transparency: number;

    public constructor(init?: Partial< GradientFillStop >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents the group shape which contains the individual shapes.   
export class GroupShape  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(GroupShape.attributeTypeMap) ;

    }


    public constructor(init?: Partial< GroupShape >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
///            Represents picture format option
///               
export class PicFormatOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "scale",
            baseName: "Scale",
            type: "number",
        },
        {
            name: "left",
            baseName: "Left",
            type: "number",
        },
        {
            name: "right",
            baseName: "Right",
            type: "number",
        },
        {
            name: "top",
            baseName: "Top",
            type: "number",
        },
        {
            name: "bottom",
            baseName: "Bottom",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  PicFormatOption.attributeTypeMap;

    }

    public type: string;
    public scale: number;
    public left: number;
    public right: number;
    public top: number;
    public bottom: number;

    public constructor(init?: Partial< PicFormatOption >) {  
    
        Object.assign(this, init);
    } 
}
///            Represents tile picture as texture.
///               
export class TilePicOption  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "offsetX",
            baseName: "OffsetX",
            type: "number",
        },
        {
            name: "offsetY",
            baseName: "OffsetY",
            type: "number",
        },
        {
            name: "scaleX",
            baseName: "ScaleX",
            type: "number",
        },
        {
            name: "scaleY",
            baseName: "ScaleY",
            type: "number",
        },
        {
            name: "alignmentType",
            baseName: "AlignmentType",
            type: "string",
        },
        {
            name: "mirrorType",
            baseName: "MirrorType",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  TilePicOption.attributeTypeMap;

    }

    public offsetX: number;
    public offsetY: number;
    public scaleX: number;
    public scaleY: number;
    public alignmentType: string;
    public mirrorType: string;

    public constructor(init?: Partial< TilePicOption >) {  
    
        Object.assign(this, init);
    } 
}
///            Represents the marker in a line chart, scatter chart, or radar chart.
///               
export class Marker  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "border",
            baseName: "Border",
            type: "Line",
        },
        {
            name: "area",
            baseName: "Area",
            type: "Area",
        },
        {
            name: "markerSize",
            baseName: "MarkerSize",
            type: "number",
        },
        {
            name: "markerStyle",
            baseName: "MarkerStyle",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Marker.attributeTypeMap;

    }

    public border: Line;
    public area: Area;
    public markerSize: number;
    public markerStyle: string;

    public constructor(init?: Partial< Marker >) {  
    
        Object.assign(this, init);
    } 
}
/// Chart shape object   
export class ChartShape  extends Shape  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ChartShape.attributeTypeMap) ;

    }


    public constructor(init?: Partial< ChartShape >) {  
         super(init);     
        Object.assign(this, init);
    } 
}
/// A sparkline represents a tiny chart or graphic in a worksheet cell that provides a visual representation of data.
///                
export class Sparkline  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "column",
            baseName: "Column",
            type: "number",
        },
        {
            name: "dataRange",
            baseName: "DataRange",
            type: "string",
        },
        {
            name: "row",
            baseName: "Row",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  Sparkline.attributeTypeMap;

    }

    public column: number;
    public dataRange: string;
    public row: number;

    public constructor(init?: Partial< Sparkline >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents description of analyzed column.   
export class AnalyzedColumnDescription  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "index",
            baseName: "Index",
            type: "number",
        },
        {
            name: "columnIndex",
            baseName: "ColumnIndex",
            type: "number",
        },
        {
            name: "title",
            baseName: "Title",
            type: "string",
        },
        {
            name: "repetitionRate",
            baseName: "RepetitionRate",
            type: "number",
        },
        {
            name: "columnDataDataType",
            baseName: "ColumnDataDataType",
            type: "string",
        },
        {
            name: "numberCategoryType",
            baseName: "NumberCategoryType",
            type: "string",
        },
        {
            name: "textCategoryType",
            baseName: "TextCategoryType",
            type: "string",
        },
        {
            name: "styleNumber",
            baseName: "StyleNumber",
            type: "number",
        },
        {
            name: "columnDataExceptionDescription",
            baseName: "columnDataExceptionDescription",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  AnalyzedColumnDescription.attributeTypeMap;

    }

    public index: number;
    public columnIndex: number;
    public title: string;
    public repetitionRate: number;
    public columnDataDataType: string;
    public numberCategoryType: string;
    public textCategoryType: string;
    public styleNumber: number;
    public columnDataExceptionDescription: string;

    public constructor(init?: Partial< AnalyzedColumnDescription >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents analyzed table description.   
export class AnalyzedTableDescription  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "sheetName",
            baseName: "SheetName",
            type: "string",
        },
        {
            name: "columns",
            baseName: "Columns",
            type: "Array<AnalyzedColumnDescription>",
        },
        {
            name: "dateColumns",
            baseName: "DateColumns",
            type: "Array<number>",
        },
        {
            name: "numberColumns",
            baseName: "NumberColumns",
            type: "Array<number>",
        },
        {
            name: "textColumns",
            baseName: "TextColumns",
            type: "Array<number>",
        },
        {
            name: "exceptionColumns",
            baseName: "ExceptionColumns",
            type: "Array<number>",
        },
        {
            name: "hasTableHeaderRow",
            baseName: "HasTableHeaderRow",
            type: "boolean",
        },
        {
            name: "hasTableTotalRow",
            baseName: "HasTableTotalRow",
            type: "boolean",
        },
        {
            name: "startDataColumnIndex",
            baseName: "StartDataColumnIndex",
            type: "number",
        },
        {
            name: "endDataColumnIndex",
            baseName: "EndDataColumnIndex",
            type: "number",
        },
        {
            name: "startDataRowIndex",
            baseName: "StartDataRowIndex",
            type: "number",
        },
        {
            name: "endDataRowIndex",
            baseName: "EndDataRowIndex",
            type: "number",
        },
        {
            name: "thumbnail",
            baseName: "Thumbnail",
            type: "string",
        },
        {
            name: "discoverCharts",
            baseName: "DiscoverCharts",
            type: "Array<DiscoverChart>",
        },
        {
            name: "discoverPivotTables",
            baseName: "DiscoverPivotTables",
            type: "Array<DiscoverPivotTable>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  AnalyzedTableDescription.attributeTypeMap;

    }

    public name: string;
    public sheetName: string;
    public columns: Array<AnalyzedColumnDescription>;
    public dateColumns: Array<number>;
    public numberColumns: Array<number>;
    public textColumns: Array<number>;
    public exceptionColumns: Array<number>;
    public hasTableHeaderRow: boolean;
    public hasTableTotalRow: boolean;
    public startDataColumnIndex: number;
    public endDataColumnIndex: number;
    public startDataRowIndex: number;
    public endDataRowIndex: number;
    public thumbnail: string;
    public discoverCharts: Array<DiscoverChart>;
    public discoverPivotTables: Array<DiscoverPivotTable>;

    public constructor(init?: Partial< AnalyzedTableDescription >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents Excel data statistics.   
export class ExcelDataStatistics  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "worksheetDataStatistics",
            baseName: "WorksheetDataStatistics",
            type: "Array<WorksheetDataStatistics>",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  ExcelDataStatistics.attributeTypeMap;

    }

    public worksheetDataStatistics: Array<WorksheetDataStatistics>;

    public constructor(init?: Partial< ExcelDataStatistics >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents results of analyzed data.   
export class AnalyzedResult  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "filename",
            baseName: "Filename",
            type: "string",
        },
        {
            name: "description",
            baseName: "Description",
            type: "string",
        },
        {
            name: "basicStatistics",
            baseName: "BasicStatistics",
            type: "ExcelDataStatistics",
        },
        {
            name: "results",
            baseName: "Results",
            type: "Array<AnalyzedTableDescription>",
        },
        {
            name: "suggestedFile",
            baseName: "SuggestedFile",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  AnalyzedResult.attributeTypeMap;

    }

    public filename: string;
    public description: string;
    public basicStatistics: ExcelDataStatistics;
    public results: Array<AnalyzedTableDescription>;
    public suggestedFile: string;

    public constructor(init?: Partial< AnalyzedResult >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents a chart, which is a chart created based on data analysis of a table.   
export class DiscoverChart  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "sheetName",
            baseName: "SheetName",
            type: "string",
        },
        {
            name: "title",
            baseName: "Title",
            type: "string",
        },
        {
            name: "type",
            baseName: "Type",
            type: "string",
        },
        {
            name: "dataRange",
            baseName: "DataRange",
            type: "string",
        },
        {
            name: "thumbnail",
            baseName: "Thumbnail",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DiscoverChart.attributeTypeMap;

    }

    public name: string;
    public sheetName: string;
    public title: string;
    public type: string;
    public dataRange: string;
    public thumbnail: string;

    public constructor(init?: Partial< DiscoverChart >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents a pivot table, which is a pivot table created based on data analysis of a table.   
export class DiscoverPivotTable  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "title",
            baseName: "Title",
            type: "string",
        },
        {
            name: "dataRange",
            baseName: "DataRange",
            type: "string",
        },
        {
            name: "pivotFieldRows",
            baseName: "PivotFieldRows",
            type: "Array<number>",
        },
        {
            name: "pivotFieldColumns",
            baseName: "PivotFieldColumns",
            type: "Array<number>",
        },
        {
            name: "pivotFieldData",
            baseName: "PivotFieldData",
            type: "Array<number>",
        },
        {
            name: "thumbnail",
            baseName: "Thumbnail",
            type: "string",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  DiscoverPivotTable.attributeTypeMap;

    }

    public name: string;
    public title: string;
    public dataRange: string;
    public pivotFieldRows: Array<number>;
    public pivotFieldColumns: Array<number>;
    public pivotFieldData: Array<number>;
    public thumbnail: string;

    public constructor(init?: Partial< DiscoverPivotTable >) {  
    
        Object.assign(this, init);
    } 
}
/// Represents worksheet data statistics.   
export class WorksheetDataStatistics  {
    /**
     * Attribute type map
     */
    public static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            name: "name",
            baseName: "Name",
            type: "string",
        },
        {
            name: "chartsCount",
            baseName: "ChartsCount",
            type: "number",
        },
        {
            name: "tablesCount",
            baseName: "TablesCount",
            type: "number",
        },
        {
            name: "pivotTablesCount",
            baseName: "PivotTablesCount",
            type: "number",
        },
        {
            name: "shapesCount",
            baseName: "ShapesCount",
            type: "number",
        },
        {
            name: "hyperlinksCount",
            baseName: "HyperlinksCount",
            type: "number",
        },
        {
            name: "queryTablesCount",
            baseName: "QueryTablesCount",
            type: "number",
        },
        {
            name: "cellsCount",
            baseName: "CellsCount",
            type: "number",
        },
        {
            name: "cellsCountInTable",
            baseName: "CellsCountInTable",
            type: "number",
        },
        {
            name: "cellsCountIsFormula",
            baseName: "CellsCountIsFormula",
            type: "number",
        }
    ];
    /**
     * Returns attribute type map
     */
    public static getAttributeTypeMap() {
        return  WorksheetDataStatistics.attributeTypeMap;

    }

    public name: string;
    public chartsCount: number;
    public tablesCount: number;
    public pivotTablesCount: number;
    public shapesCount: number;
    public hyperlinksCount: number;
    public queryTablesCount: number;
    public cellsCount: number;
    public cellsCountInTable: number;
    public cellsCountIsFormula: number;

    public constructor(init?: Partial< WorksheetDataStatistics >) {  
    
        Object.assign(this, init);
    } 
}
const enumsMap = {
};
const typeMap = {
    ValueType,
    DiscUsage,
    ObjectExist,
    ObjectExistsExtensions,
    FileVersion,
    StorageExist,
    FileVersions,
    FilesList,
    FilesUploadResult,
    StorageFile,
    GoogleDriveStorageFile,
    BrokenLink,
    CellArea,
    CellsCloudFileInfo,
    CellsCloudPublicKey,
    Color,
    PdfSecurityOptions,
    Range,
    SaveResult,
    PaginatedSaveOptions,
    TextItem,
    DbfSaveOptions,
    DifSaveOptions,
    DocxSaveOptions,
    HtmlSaveOptions,
    ImageSaveOptions,
    JsonSaveOptions,
    MarkdownSaveOptions,
    MHtmlSaveOptions,
    OdsSaveOptions,
    OoxmlSaveOptions,
    PclSaveOptions,
    PdfSaveOptions,
    PptxSaveOptions,
    SaveOptions,
    SaveOptionsData,
    SpreadsheetML2003SaveOptions,
    SqlScriptSaveOptions,
    SvgSaveOptions,
    TxtSaveOptions,
    XlsbSaveOptions,
    XlsSaveOptions,
    XmlSaveOptions,
    XpsSaveOptions,
    BrokenLinksReponse,
    CellsCloudFileInfoResponse,
    CellsCloudPublicKeyResponse,
    CellsCloudResponse,
    SaveResponse,
    SearchResponse,
    ImageOrPrintOptions,
    RenderingFont,
    RenderingWatermark,
    Error,
    ErrorDetails,
    AboveAverage,
    AbstractCalculationEngine,
    AbstractCalculationMonitor,
    AutoFilter,
    AutoFitterOptions,
    Border,
    CalculationOptions,
    Cell,
    Cells,
    CellsColor,
    CellsDocumentProperties,
    CellsDocumentProperty,
    ColorFilter,
    ColorScale,
    Column,
    Columns,
    Comment,
    Comments,
    ConditionalFormatting,
    ConditionalFormattingIcon,
    ConditionalFormattings,
    ConditionalFormattingValue,
    CopyOptions,
    CriteriaMultipleFilter,
    CustomFilter,
    DataBar,
    DataBarBorder,
    DataCleansing,
    DataColumnFillValue,
    DataFill,
    DataFillValue,
    DataItem,
    DataSorter,
    DataSorterKey,
    DataSource,
    DateTimeGroupItem,
    DeduplicationRegion,
    DynamicFilter,
    FileInfo,
    FileSource,
    FilesResult,
    FilterColumn,
    Font,
    FontSetting,
    FormatCondition,
    FormulaFormatCondition,
    FormulaSettings,
    GlobalizationSettings,
    HorizontalPageBreak,
    HorizontalPageBreaks,
    Hyperlink,
    Hyperlinks,
    IconFilter,
    IconSet,
    Link,
    LinkElement,
    LoadOptions,
    MergedCell,
    MergedCells,
    MultipleFilter,
    MultipleFilters,
    Name,
    Names,
    NegativeBarFormat,
    PageSection,
    PageSetup,
    PasteOptions,
    Protection,
    ProtectSheetParameter,
    Ranges,
    Row,
    Rows,
    SingleValue,
    SortKey,
    SplitResult,
    Style,
    StyleFormatCondition,
    Styles,
    TextFormatCondition,
    TextItems,
    TextOptions,
    ThemeColor,
    TimePeriodFormatCondition,
    Top10,
    Top10Filter,
    Validation,
    Validations,
    VerticalPageBreak,
    VerticalPageBreaks,
    Workbook,
    WorkbookSettings,
    Worksheet,
    Worksheets,
    WriteProtection,
    XmlDataBinding,
    XmlMap,
    CellsObjectOperateTaskParameter,
    ConvertTaskParameter,
    ConvertWorksheetTaskParameter,
    ImportDataTaskParameter,
    ResultDestination,
    SaveFilesToCloudResult,
    SaveResultTaskParameter,
    SmartMarkerTaskParameter,
    SplitWorkbookTaskParameter,
    TaskData,
    TaskDescription,
    TaskParameter,
    TaskResultParameter,
    TaskRunResult,
    ChartOperateParameter,
    ListObjectOperateParameter,
    OperateObject,
    OperateObjectPosition,
    OperateParameter,
    PageBreakOperateParameter,
    PageSetupOperateParameter,
    PivotTableOperateParameter,
    ShapeOperateParameter,
    WorkbookOperateParameter,
    WorkbookSettingsOperateParameter,
    WorksheetOperateParameter,
    ListColumn,
    ListObject,
    ListObjects,
    PivotGlobalizationSettings,
    ArcShapeResponse,
    AutoFilterResponse,
    AutoShapeResponse,
    AutoShapesResponse,
    AxisResponse,
    BorderResponse,
    ButtonResponse,
    CalculateFormulaResponse,
    CellResponse,
    CellsDocumentPropertiesResponse,
    CellsDocumentPropertyResponse,
    CellsDrawingResponse,
    CellsResponse,
    ChartAreaResponse,
    ChartDataTableResponse,
    ChartPointResponse,
    ChartPointsResponse,
    ChartResponse,
    ChartsResponse,
    CheckBoxResponse,
    CheckedExternalReferenceResponse,
    CheckedFormulaErrorsResponse,
    ColumnResponse,
    ColumnsResponse,
    ComboBoxResponse,
    CommentResponse,
    CommentShapeResponse,
    CommentsResponse,
    ConditionalFormattingResponse,
    ConditionalFormattingsResponse,
    DataLabelsResponse,
    DisplayUnitLabelResponse,
    DropBarsResponse,
    ErrorBarResponse,
    FillFormatResponse,
    FindResponse,
    FloorResponse,
    FormResponse,
    FormsResponse,
    GroupBoxResponse,
    HorizontalPageBreakResponse,
    HorizontalPageBreaksResponse,
    HyperlinkResponse,
    HyperlinksResponse,
    LabelResponse,
    LegendEntriesResponse,
    LegendEntryResponse,
    LegendResponse,
    LineResponse,
    LineShapeResponse,
    ListBoxResponse,
    ListObjectResponse,
    ListObjectsResponse,
    MergedCellResponse,
    MergedCellsResponse,
    NameResponse,
    NamesResponse,
    OleObjectResponse,
    OleObjectsResponse,
    OvalResponse,
    PageSectionsResponse,
    PageSetupResponse,
    PictureResponse,
    PicturesResponse,
    PivotFieldResponse,
    PivotFilterResponse,
    PivotFiltersResponse,
    PivotTableResponse,
    PivotTablesResponse,
    PlotAreaResponse,
    RadioButtonResponse,
    RangeResponse,
    RangesResponse,
    RangeValueResponse,
    RectangleShapeResponse,
    RowResponse,
    RowsResponse,
    SaveFilesToCloudResultResponse,
    ScrollBarResponse,
    SeriesesResponse,
    SeriesResponse,
    ShapeResponse,
    ShapesResponse,
    SingleValueResponse,
    SparklineGroupResponse,
    SparklineGroupsResponse,
    SpinnerResponse,
    SplitResultResponse,
    StyleResponse,
    StylesResponse,
    TaskRunResultResponse,
    TextBoxResponse,
    TextItemResponse,
    TextItemsResponse,
    TickLabelsResponse,
    TitleResponse,
    TrendlineResponse,
    TrendlinesResponse,
    ValidationResponse,
    ValidationsResponse,
    VerticalPageBreakResponse,
    VerticalPageBreaksResponse,
    WallsResponse,
    WorkbookReplaceResponse,
    WorkbookResponse,
    WorkbookSettingsResponse,
    WorkbooksResponse,
    WorksheetReplaceResponse,
    WorksheetResponse,
    WorksheetsResponse,
    AnalyzeExcelRequest,
    BatchConvertRequest,
    BatchLockRequest,
    BatchProtectRequest,
    BatchSplitRequest,
    ColorFilterRequest,
    ConvertParameter,
    CreatePivotTableRequest,
    DataCleansingRequest,
    DataDeduplicationRequest,
    DataFillRequest,
    DataTransformationRequest,
    DeleteIncompleteRowsRequest,
    ImportJsonRequest,
    ImportXMLRequest,
    MatchConditionRequest,
    PasswordRequest,
    PivotTableFieldRequest,
    ProtectWorkbookRequest,
    RangeConvertRequest,
    RangeCopyRequest,
    RangeSetOutlineBorderRequest,
    RangeSetStyleRequest,
    RangeSortRequest,
    TableTotalRequest,
    TextWaterMarkerRequest,
    WorkbookEncryptionRequest,
    WorkbookProtectionRequest,
    WorksheetMovingRequest,
    AppliedOperate,
    AppliedStep,
    DataQuery,
    LoadData,
    LoadTo,
    MergeQueries,
    PivotColumn,
    UnpivotColumn,
    PivotField,
    PivotFilter,
    PivotItem,
    PivotTable,
    PivotTables,
    AddTextOptions,
    BaseOperateOptions,
    CharacterCountOptions,
    CheckExternalReferenceOptions,
    CheckFormulaErrorOptions,
    CombinationSourceData,
    ConvertTextOptions,
    ConvertWorkbookOptions,
    ConvertWorksheetOptions,
    DataOutputLocation,
    ExtractTextOptions,
    MergeTableOptions,
    RemoveCharactersByCharacter,
    RemoveCharactersByPosition,
    RemoveCharactersOptions,
    RemoveDuplicatesOptions,
    ScopeItem,
    ScopeOptions,
    SpecifyCellsObject,
    SpecifyWordsCountOptions,
    SplitTextOptions,
    TablePositionInfo,
    TrimContentOptions,
    WordCaseOptions,
    WordsCountOptions,
    CellValue,
    CustomParserConfig,
    Import2DimensionDoubleArrayOption,
    Import2DimensionIntArrayOption,
    Import2DimensionStringArrayOption,
    ImportBatchDataOption,
    ImportCSVDataOption,
    ImportDoubleArrayOption,
    ImportIntArrayOption,
    ImportOption,
    ImportPictureOption,
    ImportPosition,
    ImportStringArrayOption,
    ArcShape,
    Area,
    AutoShape,
    AutoShapes,
    Button,
    CellsDrawing,
    CheckBox,
    ComboBox,
    CommentShape,
    FillFormat,
    Form,
    Forms,
    GradientFill,
    GradientFillStop,
    GroupBox,
    GroupShape,
    Label,
    Line,
    LineFormat,
    LineShape,
    ListBox,
    OleObject,
    OleObjects,
    Oval,
    PatternFill,
    PicFormatOption,
    Picture,
    Pictures,
    RadioButton,
    RectangleShape,
    ScrollBar,
    ShadowEffect,
    Shape,
    Shapes,
    SolidFill,
    Spinner,
    TextBox,
    TextureFill,
    TilePicOption,
    DigitalSignature,
    Axis,
    Chart,
    ChartArea,
    ChartDataTable,
    ChartFrame,
    ChartGlobalizationSettings,
    ChartPoint,
    ChartPoints,
    Charts,
    ChartShape,
    DataLabels,
    DisplayUnitLabel,
    DropBars,
    ErrorBar,
    Floor,
    Legend,
    LegendEntries,
    LegendEntry,
    Marker,
    PlotArea,
    Series,
    SeriesItems,
    Sparkline,
    SparklineGroup,
    SparklineGroups,
    TickLabels,
    Title,
    Trendline,
    Trendlines,
    Walls,
    AnalyzedColumnDescription,
    AnalyzedResult,
    AnalyzedTableDescription,
    DiscoverChart,
    DiscoverPivotTable,
    ExcelDataStatistics,
    WorksheetDataStatistics,
};

export {enumsMap, typeMap};

/// Get Access Token Result: The Cells Cloud Get Token API acts as a proxy service,
/// forwarding user requests to the Aspose Cloud authentication server and returning the resulting access token to the client.   
export class PostAccessTokenRequest  {
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostAccessTokenRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/connect/token";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Check the Health Status of Aspose.Cells Cloud Service.   
export class GetAsposeCellsCloudStatusRequest  {
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetAsposeCellsCloudStatusRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Check the Health Status of Aspose.Cells Cloud Service.   
export class CheckCloudServiceHealthRequest  {
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< CheckCloudServiceHealthRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/status/check";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Converts a spreadsheet in cloud storage to the specified format.   
export class GetWorkbookWithFormatRequest  {
    /// (Required) The name of the workbook file to be retrieved.  
    public name: string;
    /// (Required) The desired output format (e.g., "Xlsx", "Pdf", "Csv").  
    public format: string;
    /// (Optional) The folder path where the workbook is stored. The default is null.  
    public folder: string;
    /// (Optional) The name of the storage if using custom cloud storage. Use default storage if omitted.  
    public storageName: string;
    /// (Optional) The folder path where the workbook is stored. The default is null.  
    public outPath: string;
    /// Output file Storage Name.  
    public outStorageName: string;
    /// Use Custom fonts.  
    public fontsLocation: string;
    /// The spreadsheet region setting.  
    public regoin: string;
    /// The password for opening spreadsheet file.  
    public password: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorkbookWithFormatRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/{name}".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        /// (Required) The desired output format (e.g., "Xlsx", "Pdf", "Csv"). 
        // verify required parameter 'format' is not null or undefined
        if (this.format === null || this.format === undefined) {
            throw new Error('Required parameter "format" was null or undefined when calling GetWorkbookWithFormat.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outPath", this.outPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outStorageName", this.outStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "regoin", this.regoin);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Converts a spreadsheet on a local drive to the specified format.   
export class ConvertWorkbookRequest  {
    /// Upload spreadsheet file.  
    public spreadsheet: any;
    /// (Required) The desired output format (e.g., "Xlsx", "Pdf", "Csv").  
    public format: string;
    /// (Optional) The folder path where the workbook is stored. The default is null.  
    public outPath: string;
    /// Output file Storage Name.  
    public outStorageName: string;
    /// Use Custom fonts.  
    public fontsLocation: string;
    /// The spreadsheet region setting.  
    public regoin: string;
    /// The password for opening spreadsheet file.  
    public password: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< ConvertWorkbookRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/convert";
        const queryParameters: any = {};
        const formParams: any = {};
        /// (Required) The desired output format (e.g., "Xlsx", "Pdf", "Csv"). 
        // verify required parameter 'format' is not null or undefined
        if (this.format === null || this.format === undefined) {
            throw new Error('Required parameter "format" was null or undefined when calling ConvertWorkbook.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outPath", this.outPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outStorageName", this.outStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "regoin", this.regoin);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.spreadsheet !== undefined) {
            if (typeof this.spreadsheet === 'string') {
                if (fs.existsSync(this.spreadsheet)) {
                    const fileName = path.basename( this.spreadsheet)
                    formParams[fileName] = fs.createReadStream(this.spreadsheet)
                }
            }
            else {
                for (var key in this.spreadsheet){
                    formParams[key] = this.spreadsheet[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Converts a spreadsheet in cloud storage to the specified format.   
export class WorkbookSaveAsRequest  {
    /// (Required) The name of the workbook file to be converted.  
    public name: string;
    /// (Required) The desired output format (e.g., "Xlsx", "Pdf", "Csv").  
    public format: string;
    /// (Optional) Save options data. The default is null.  
    public saveOptionsData: SaveOptionsData;
    /// (Optional) The folder path where the workbook is stored. The default is null.  
    public folder: string;
    /// (Optional) The name of the storage if using custom cloud storage. Use default storage if omitted.  
    public storageName: string;
    /// (Optional) The folder path where the workbook is stored. The default is null.  
    public outPath: string;
    /// Output file Storage Name.  
    public outStorageName: string;
    /// Use Custom fonts.  
    public fontsLocation: string;
    /// The spreadsheet region setting.  
    public regoin: string;
    /// The password for opening spreadsheet file.  
    public password: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< WorkbookSaveAsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/{name}/SaveAs".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        /// (Required) The desired output format (e.g., "Xlsx", "Pdf", "Csv"). 
        // verify required parameter 'format' is not null or undefined
        if (this.format === null || this.format === undefined) {
            throw new Error('Required parameter "format" was null or undefined when calling WorkbookSaveAs.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outPath", this.outPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outStorageName", this.outStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "regoin", this.regoin);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.saveOptionsData == null) ? null :   ObjectSerializer.serialize( this.saveOptionsData,this.saveOptionsData.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Merge local spreadsheet files into a specified format file.   
export class MergeFilesRequest  {
    /// Upload spreadsheet file.  
    public spreadsheet: any;
    /// The out file format.  
    public outFormat: string;
    /// Whether to combine all data into a single worksheet.  
    public mergeInOneSheet: boolean;
    /// (Optional) The folder path where the workbook is stored. The default is null.  
    public outPath: string;
    /// Output file Storage Name.  
    public outStorageName: string;
    /// Use Custom fonts.  
    public fontsLocation: string;
    /// The spreadsheet region setting.  
    public regoin: string;
    /// The password for opening spreadsheet file.  
    public password: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< MergeFilesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/merge";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outFormat", this.outFormat);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "mergeInOneSheet", this.mergeInOneSheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outPath", this.outPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outStorageName", this.outStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "regoin", this.regoin);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.spreadsheet !== undefined) {
            if (typeof this.spreadsheet === 'string') {
                if (fs.existsSync(this.spreadsheet)) {
                    const fileName = path.basename( this.spreadsheet)
                    formParams[fileName] = fs.createReadStream(this.spreadsheet)
                }
            }
            else {
                for (var key in this.spreadsheet){
                    formParams[key] = this.spreadsheet[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Merge spreadsheet files in cloud storage into a specified format file.   
export class MergeFilesInRemoteFolderRequest  {
    /// The folder used to store the merged files.  
    public folder: string;
      
    public fileMatchExpression: string;
    /// The out file format.  
    public outFormat: string;
    /// Whether to combine all data into a single worksheet.  
    public mergeInOneSheet: boolean;
    /// (Optional) The name of the storage if using custom cloud storage. Use default storage if omitted.  
    public storageName: string;
    /// (Optional) The folder path where the workbook is stored. The default is null.  
    public outPath: string;
    /// Output file Storage Name.  
    public outStorageName: string;
    /// Use Custom fonts.  
    public fontsLocation: string;
    /// The spreadsheet region setting.  
    public regoin: string;
    /// The password for opening spreadsheet file.  
    public password: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< MergeFilesInRemoteFolderRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/mergeFilesInFolder";
        const queryParameters: any = {};
        /// The folder used to store the merged files. 
        // verify required parameter 'folder' is not null or undefined
        if (this.folder === null || this.folder === undefined) {
            throw new Error('Required parameter "folder" was null or undefined when calling MergeFilesInRemoteFolder.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fileMatchExpression", this.fileMatchExpression);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outFormat", this.outFormat);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "mergeInOneSheet", this.mergeInOneSheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outPath", this.outPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outStorageName", this.outStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "regoin", this.regoin);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Split a local spreadsheet into the specified format, multi-file.   
export class SplitFileRequest  {
    /// Upload spreadsheet file.  
    public spreadsheet: any;
    /// Begin worksheet index.  
    public from: number;
    /// End worksheet index.  
    public to: number;
    /// The out file format.  
    public outFormat: string;
    /// (Optional) The folder path where the workbook is stored. The default is null.  
    public outPath: string;
    /// Output file Storage Name.  
    public outStorageName: string;
    /// Use Custom fonts.  
    public fontsLocation: string;
    /// The spreadsheet region setting.  
    public regoin: string;
    /// The password for opening spreadsheet file.  
    public password: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< SplitFileRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/split";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "from", this.from);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "to", this.to);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outFormat", this.outFormat);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outPath", this.outPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outStorageName", this.outStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "regoin", this.regoin);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.spreadsheet !== undefined) {
            if (typeof this.spreadsheet === 'string') {
                if (fs.existsSync(this.spreadsheet)) {
                    const fileName = path.basename( this.spreadsheet)
                    formParams[fileName] = fs.createReadStream(this.spreadsheet)
                }
            }
            else {
                for (var key in this.spreadsheet){
                    formParams[key] = this.spreadsheet[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Split a spreadsheet in cloud storage into the specified format, multi-file.   
export class SplitFileInRemoteRequest  {
    /// The name of the workbook file to be split.  
    public name: string;
    /// The folder path where the workbook is stored.  
    public folder: string;
    /// Begin worksheet index.  
    public from: number;
    /// End worksheet index.  
    public to: number;
    /// The desired output format (e.g., "Xlsx", "Pdf", "Csv").  
    public outFormat: string;
    /// (Optional) The name of the storage if using custom cloud storage. Use default storage if omitted.  
    public storageName: string;
    /// (Optional) The folder path where the workbook is stored. The default is null.  
    public outPath: string;
    /// Output file Storage Name.  
    public outStorageName: string;
    /// Use Custom fonts.  
    public fontsLocation: string;
    /// The spreadsheet region setting.  
    public regoin: string;
    /// The password for opening spreadsheet file.  
    public password: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< SplitFileInRemoteRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/{name}/split".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "from", this.from);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "to", this.to);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outFormat", this.outFormat);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outPath", this.outPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outStorageName", this.outStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "regoin", this.regoin);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get an asymmetric public key.   
export class GetPublicKeyRequest  {
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetPublicKeyRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/publickey";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Search text in the local spreadsheet.   
export class SearchTextRequest  {
    /// Upload spreadsheet file.  
    public spreadsheet: any;
    /// The searched text.  
    public searchText: string;
    /// Ignore the text of the search.  
    public ignoringCase: boolean;
    /// Specify the worksheet for the lookup.  
    public sheetname: string;
    /// Specify the cell area for the lookup  
    public cellarea: string;
    /// The spreadsheet region setting.  
    public regoin: string;
    /// The password for opening spreadsheet file.  
    public password: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< SearchTextRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/search";
        const queryParameters: any = {};
        const formParams: any = {};
        /// The searched text. 
        // verify required parameter 'searchText' is not null or undefined
        if (this.searchText === null || this.searchText === undefined) {
            throw new Error('Required parameter "searchText" was null or undefined when calling SearchText.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "searchText", this.searchText);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "ignoringCase", this.ignoringCase);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sheetname", this.sheetname);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellarea", this.cellarea);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "regoin", this.regoin);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.spreadsheet !== undefined) {
            if (typeof this.spreadsheet === 'string') {
                if (fs.existsSync(this.spreadsheet)) {
                    const fileName = path.basename( this.spreadsheet)
                    formParams[fileName] = fs.createReadStream(this.spreadsheet)
                }
            }
            else {
                for (var key in this.spreadsheet){
                    formParams[key] = this.spreadsheet[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Search text in the remoted spreadsheet.   
export class SearchTextInRemoteRequest  {
    /// The name of the workbook file to be search.  
    public name: string;
    /// The searched text.  
    public searchText: string;
    /// Ignore the text of the search.  
    public ignoringCase: boolean;
    /// Specify the worksheet for the lookup.  
    public sheetname: string;
    /// Specify the cell area for the lookup  
    public cellarea: string;
    /// The folder path where the workbook is stored.  
    public folder: string;
    /// (Optional) The name of the storage if using custom cloud storage. Use default storage if omitted.  
    public storageName: string;
    /// The spreadsheet region setting.  
    public regoin: string;
    /// The password for opening spreadsheet file.  
    public password: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< SearchTextInRemoteRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/{name}/search".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        /// The searched text. 
        // verify required parameter 'searchText' is not null or undefined
        if (this.searchText === null || this.searchText === undefined) {
            throw new Error('Required parameter "searchText" was null or undefined when calling SearchTextInRemote.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "searchText", this.searchText);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "ignoringCase", this.ignoringCase);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sheetname", this.sheetname);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellarea", this.cellarea);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "regoin", this.regoin);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Replace text in the local spreadsheet.   
export class ReplaceTextRequest  {
    /// Upload spreadsheet file.  
    public spreadsheet: any;
    /// The searched text.  
    public searchText: string;
    /// The replaced text.  
    public replaceText: string;
    /// Specify the worksheet for the replace.  
    public sheetname: string;
    /// Specify the cell area for the replace.  
    public cellarea: string;
    /// The spreadsheet region setting.  
    public regoin: string;
    /// The password for opening spreadsheet file.  
    public password: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< ReplaceTextRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/replace";
        const queryParameters: any = {};
        const formParams: any = {};
        /// The searched text. 
        // verify required parameter 'searchText' is not null or undefined
        if (this.searchText === null || this.searchText === undefined) {
            throw new Error('Required parameter "searchText" was null or undefined when calling ReplaceText.');
        }
        /// The replaced text. 
        // verify required parameter 'replaceText' is not null or undefined
        if (this.replaceText === null || this.replaceText === undefined) {
            throw new Error('Required parameter "replaceText" was null or undefined when calling ReplaceText.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "searchText", this.searchText);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "replaceText", this.replaceText);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sheetname", this.sheetname);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellarea", this.cellarea);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "regoin", this.regoin);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.spreadsheet !== undefined) {
            if (typeof this.spreadsheet === 'string') {
                if (fs.existsSync(this.spreadsheet)) {
                    const fileName = path.basename( this.spreadsheet)
                    formParams[fileName] = fs.createReadStream(this.spreadsheet)
                }
            }
            else {
                for (var key in this.spreadsheet){
                    formParams[key] = this.spreadsheet[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Replace text in the remoted spreadsheet.   
export class ReplaceTextInRemoteRequest  {
    /// The name of the workbook file to be replace.  
    public name: string;
    /// The searched text.  
    public searchText: string;
    /// The replaced text.  
    public replaceText: string;
    /// Specify the worksheet for the replace.  
    public sheetname: string;
    /// Specify the cell area for the replace.  
    public cellarea: string;
    /// The folder path where the workbook is stored.  
    public folder: string;
    /// (Optional) The name of the storage if using custom cloud storage. Use default storage if omitted.  
    public storageName: string;
    /// The spreadsheet region setting.  
    public regoin: string;
    /// The password for opening spreadsheet file.  
    public password: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< ReplaceTextInRemoteRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/{name}/replace".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        /// The searched text. 
        // verify required parameter 'searchText' is not null or undefined
        if (this.searchText === null || this.searchText === undefined) {
            throw new Error('Required parameter "searchText" was null or undefined when calling ReplaceTextInRemote.');
        }
        /// The replaced text. 
        // verify required parameter 'replaceText' is not null or undefined
        if (this.replaceText === null || this.replaceText === undefined) {
            throw new Error('Required parameter "replaceText" was null or undefined when calling ReplaceTextInRemote.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "searchText", this.searchText);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "replaceText", this.replaceText);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sheetname", this.sheetname);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellarea", this.cellarea);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "regoin", this.regoin);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Search broken links in the local spreadsheet.   
export class SearchBrokenLinksRequest  {
    /// Upload spreadsheet file.  
    public spreadsheet: any;
    /// Specify the worksheet for the replace.  
    public sheetname: string;
    /// Specify the cell area for the replace.  
    public cellarea: string;
    /// The spreadsheet region setting.  
    public regoin: string;
    /// The password for opening spreadsheet file.  
    public password: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< SearchBrokenLinksRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/searchBrokenLinks";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sheetname", this.sheetname);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellarea", this.cellarea);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "regoin", this.regoin);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.spreadsheet !== undefined) {
            if (typeof this.spreadsheet === 'string') {
                if (fs.existsSync(this.spreadsheet)) {
                    const fileName = path.basename( this.spreadsheet)
                    formParams[fileName] = fs.createReadStream(this.spreadsheet)
                }
            }
            else {
                for (var key in this.spreadsheet){
                    formParams[key] = this.spreadsheet[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Search broken links in the remoted spreadsheet.   
export class SearchBrokenLinksInRemoteRequest  {
    /// The name of the workbook file to be search.  
    public name: string;
    /// Specify the worksheet for the lookup.  
    public sheetname: string;
    /// Specify the cell area for the lookup  
    public cellarea: string;
    /// The folder path where the workbook is stored.  
    public folder: string;
    /// (Optional) The name of the storage if using custom cloud storage. Use default storage if omitted.  
    public storageName: string;
    /// The spreadsheet region setting.  
    public regoin: string;
    /// The password for opening spreadsheet file.  
    public password: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< SearchBrokenLinksInRemoteRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/{name}/searchBrokenLinks".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sheetname", this.sheetname);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellarea", this.cellarea);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "regoin", this.regoin);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get the specifications   
export class SpecRequest  {
      
    public version: string;
    /// The spreadsheet region setting.  
    public regoin: string;
    /// The password for opening spreadsheet file.  
    public password: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< SpecRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/swagger/spec";
        const queryParameters: any = {};
         
        // verify required parameter 'version' is not null or undefined
        if (this.version === null || this.version === undefined) {
            throw new Error('Required parameter "version" was null or undefined when calling Spec.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "version", this.version);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "regoin", this.regoin);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class CodegenSpecRequest  {
    /// The spreadsheet region setting.  
    public regoin: string;
    /// The password for opening spreadsheet file.  
    public password: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< CodegenSpecRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/codegen/spec";
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "regoin", this.regoin);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class DownloadFileRequest  {
      
    public path: string;
      
    public storageName: string;
      
    public versionId: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DownloadFileRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/storage/file/{path}".replace("{" + "path" + "}", String(this.path));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "versionId", this.versionId);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class UploadFileRequest  {
    /// Upload files to cloud storage.  
    public uploadFiles: any;
      
    public path: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< UploadFileRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/storage/file/{path}".replace("{" + "path" + "}", String(this.path));
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.uploadFiles !== undefined) {
            if (typeof this.uploadFiles === 'string') {
                if (fs.existsSync(this.uploadFiles)) {
                    const fileName = path.basename( this.uploadFiles)
                    formParams[fileName] = fs.createReadStream(this.uploadFiles)
                }
            }
            else {
                for (var key in this.uploadFiles){
                    formParams[key] = this.uploadFiles[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
   
export class CopyFileRequest  {
      
    public srcPath: string;
      
    public destPath: string;
      
    public srcStorageName: string;
      
    public destStorageName: string;
      
    public versionId: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< CopyFileRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/storage/file/copy/{srcPath}".replace("{" + "srcPath" + "}", String(this.srcPath));
        const queryParameters: any = {};
         
        // verify required parameter 'destPath' is not null or undefined
        if (this.destPath === null || this.destPath === undefined) {
            throw new Error('Required parameter "destPath" was null or undefined when calling CopyFile.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destPath", this.destPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "srcStorageName", this.srcStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destStorageName", this.destStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "versionId", this.versionId);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class MoveFileRequest  {
      
    public srcPath: string;
      
    public destPath: string;
      
    public srcStorageName: string;
      
    public destStorageName: string;
      
    public versionId: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< MoveFileRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/storage/file/move/{srcPath}".replace("{" + "srcPath" + "}", String(this.srcPath));
        const queryParameters: any = {};
         
        // verify required parameter 'destPath' is not null or undefined
        if (this.destPath === null || this.destPath === undefined) {
            throw new Error('Required parameter "destPath" was null or undefined when calling MoveFile.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destPath", this.destPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "srcStorageName", this.srcStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destStorageName", this.destStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "versionId", this.versionId);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class DeleteFileRequest  {
      
    public path: string;
      
    public storageName: string;
      
    public versionId: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteFileRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/storage/file/{path}".replace("{" + "path" + "}", String(this.path));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "versionId", this.versionId);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class GetFilesListRequest  {
      
    public path: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetFilesListRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/storage/folder/{path}".replace("{" + "path" + "}", String(this.path));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class CreateFolderRequest  {
      
    public path: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< CreateFolderRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/storage/folder/{path}".replace("{" + "path" + "}", String(this.path));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class CopyFolderRequest  {
      
    public srcPath: string;
      
    public destPath: string;
      
    public srcStorageName: string;
      
    public destStorageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< CopyFolderRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/storage/folder/copy/{srcPath}".replace("{" + "srcPath" + "}", String(this.srcPath));
        const queryParameters: any = {};
         
        // verify required parameter 'destPath' is not null or undefined
        if (this.destPath === null || this.destPath === undefined) {
            throw new Error('Required parameter "destPath" was null or undefined when calling CopyFolder.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destPath", this.destPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "srcStorageName", this.srcStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destStorageName", this.destStorageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class MoveFolderRequest  {
      
    public srcPath: string;
      
    public destPath: string;
      
    public srcStorageName: string;
      
    public destStorageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< MoveFolderRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/storage/folder/move/{srcPath}".replace("{" + "srcPath" + "}", String(this.srcPath));
        const queryParameters: any = {};
         
        // verify required parameter 'destPath' is not null or undefined
        if (this.destPath === null || this.destPath === undefined) {
            throw new Error('Required parameter "destPath" was null or undefined when calling MoveFolder.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destPath", this.destPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "srcStorageName", this.srcStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destStorageName", this.destStorageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class DeleteFolderRequest  {
      
    public path: string;
      
    public storageName: string;
      
    public recursive: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteFolderRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/storage/folder/{path}".replace("{" + "path" + "}", String(this.path));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "recursive", this.recursive);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class StorageExistsRequest  {
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< StorageExistsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/storage/{storageName}/exist".replace("{" + "storageName" + "}", String(this.storageName));
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class ObjectExistsRequest  {
      
    public path: string;
      
    public storageName: string;
      
    public versionId: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< ObjectExistsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/storage/exist/{path}".replace("{" + "path" + "}", String(this.path));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "versionId", this.versionId);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class GetDiscUsageRequest  {
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetDiscUsageRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/storage/disc";
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class GetFileVersionsRequest  {
      
    public path: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetFileVersionsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v4.0/cells/storage/version/{path}".replace("{" + "path" + "}", String(this.path));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Perform business analysis of data in Excel files.   
export class PostAnalyzeExcelRequest  {
    /// Excel files and analysis output requirements  
    public analyzeExcelRequest: AnalyzeExcelRequest;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostAnalyzeExcelRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/analyze";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.analyzeExcelRequest == null) ? null :   ObjectSerializer.serialize( this.analyzeExcelRequest,this.analyzeExcelRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve the description of auto filters from a worksheet.   
export class GetWorksheetAutoFilterRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetAutoFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/autoFilter".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Apply a date filter in the worksheet.   
export class PutWorksheetDateFilterRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the range to which the specified AutoFilter applies.  
    public range: string;
    /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0).  
    public fieldIndex: number;
    /// Specifies how to group dateTime values (Day, Hour, Minute, Month, Second, Year).  
    public dateTimeGroupingType: string;
    /// The year.  
    public year: number;
    /// The month.  
    public month: number;
    /// The day.  
    public day: number;
    /// The hour.  
    public hour: number;
    /// The minute.  
    public minute: number;
    /// The second.  
    public second: number;
    /// Match all blank cell in the list.  
    public matchBlanks: boolean;
    /// Refresh auto filters to hide or unhide the rows.  
    public refresh: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetDateFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/autoFilter/dateFilter".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Represents the range to which the specified AutoFilter applies. 
        // verify required parameter 'range' is not null or undefined
        if (this.range === null || this.range === undefined) {
            throw new Error('Required parameter "range" was null or undefined when calling PutWorksheetDateFilter.');
        }
        /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0). 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling PutWorksheetDateFilter.');
        }
        /// Specifies how to group dateTime values (Day, Hour, Minute, Month, Second, Year). 
        // verify required parameter 'dateTimeGroupingType' is not null or undefined
        if (this.dateTimeGroupingType === null || this.dateTimeGroupingType === undefined) {
            throw new Error('Required parameter "dateTimeGroupingType" was null or undefined when calling PutWorksheetDateFilter.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "dateTimeGroupingType", this.dateTimeGroupingType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "year", this.year);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "month", this.month);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "day", this.day);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "hour", this.hour);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "minute", this.minute);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "second", this.second);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "matchBlanks", this.matchBlanks);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "refresh", this.refresh);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add a filter for a column in the worksheet.   
export class PutWorksheetFilterRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the range to which the specified AutoFilter applies.  
    public range: string;
    /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0).  
    public fieldIndex: number;
    /// The custom criteria.  
    public criteria: string;
    /// Match all blank cell in the list.  
    public matchBlanks: boolean;
    /// Refresh auto filters to hide or unhide the rows.  
    public refresh: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/autoFilter/filter".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Represents the range to which the specified AutoFilter applies. 
        // verify required parameter 'range' is not null or undefined
        if (this.range === null || this.range === undefined) {
            throw new Error('Required parameter "range" was null or undefined when calling PutWorksheetFilter.');
        }
        /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0). 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling PutWorksheetFilter.');
        }
        /// The custom criteria. 
        // verify required parameter 'criteria' is not null or undefined
        if (this.criteria === null || this.criteria === undefined) {
            throw new Error('Required parameter "criteria" was null or undefined when calling PutWorksheetFilter.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "criteria", this.criteria);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "matchBlanks", this.matchBlanks);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "refresh", this.refresh);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add an icon filter in the worksheet.   
export class PutWorksheetIconFilterRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the range to which the specified AutoFilter applies.  
    public range: string;
    /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0).  
    public fieldIndex: number;
    /// The icon set type.  
    public iconSetType: string;
    /// The icon id.  
    public iconId: number;
    /// Match all blank cell in the list.  
    public matchBlanks: boolean;
    /// Refresh auto filters to hide or unhide the rows.  
    public refresh: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetIconFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/autoFilter/iconFilter".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Represents the range to which the specified AutoFilter applies. 
        // verify required parameter 'range' is not null or undefined
        if (this.range === null || this.range === undefined) {
            throw new Error('Required parameter "range" was null or undefined when calling PutWorksheetIconFilter.');
        }
        /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0). 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling PutWorksheetIconFilter.');
        }
        /// The icon set type. 
        // verify required parameter 'iconSetType' is not null or undefined
        if (this.iconSetType === null || this.iconSetType === undefined) {
            throw new Error('Required parameter "iconSetType" was null or undefined when calling PutWorksheetIconFilter.');
        }
        /// The icon id. 
        // verify required parameter 'iconId' is not null or undefined
        if (this.iconId === null || this.iconId === undefined) {
            throw new Error('Required parameter "iconId" was null or undefined when calling PutWorksheetIconFilter.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "iconSetType", this.iconSetType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "iconId", this.iconId);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "matchBlanks", this.matchBlanks);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "refresh", this.refresh);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Filter a list with custom criteria in the worksheet.   
export class PutWorksheetCustomFilterRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the range to which the specified AutoFilter applies.  
    public range: string;
    /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0).  
    public fieldIndex: number;
    /// The filter operator type  
    public operatorType1: string;
    /// The custom criteria.  
    public criteria1: string;
    /// true/false  
    public isAnd: boolean;
      
    public operatorType2: string;
    /// The custom criteria.  
    public criteria2: string;
    /// Match all blank cell in the list.  
    public matchBlanks: boolean;
    /// Refresh auto filters to hide or unhide the rows.  
    public refresh: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetCustomFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/autoFilter/custom".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Represents the range to which the specified AutoFilter applies. 
        // verify required parameter 'range' is not null or undefined
        if (this.range === null || this.range === undefined) {
            throw new Error('Required parameter "range" was null or undefined when calling PutWorksheetCustomFilter.');
        }
        /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0). 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling PutWorksheetCustomFilter.');
        }
        /// The filter operator type 
        // verify required parameter 'operatorType1' is not null or undefined
        if (this.operatorType1 === null || this.operatorType1 === undefined) {
            throw new Error('Required parameter "operatorType1" was null or undefined when calling PutWorksheetCustomFilter.');
        }
        /// The custom criteria. 
        // verify required parameter 'criteria1' is not null or undefined
        if (this.criteria1 === null || this.criteria1 === undefined) {
            throw new Error('Required parameter "criteria1" was null or undefined when calling PutWorksheetCustomFilter.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "operatorType1", this.operatorType1);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "criteria1", this.criteria1);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isAnd", this.isAnd);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "operatorType2", this.operatorType2);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "criteria2", this.criteria2);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "matchBlanks", this.matchBlanks);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "refresh", this.refresh);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add a dynamic filter in the worksheet.   
export class PutWorksheetDynamicFilterRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the range to which the specified AutoFilter applies.  
    public range: string;
    /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0).  
    public fieldIndex: number;
    /// Dynamic filter type.  
    public dynamicFilterType: string;
    /// Match all blank cell in the list.  
    public matchBlanks: boolean;
    /// Refresh auto filters to hide or unhide the rows.  
    public refresh: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetDynamicFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/autoFilter/dynamicFilter".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Represents the range to which the specified AutoFilter applies. 
        // verify required parameter 'range' is not null or undefined
        if (this.range === null || this.range === undefined) {
            throw new Error('Required parameter "range" was null or undefined when calling PutWorksheetDynamicFilter.');
        }
        /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0). 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling PutWorksheetDynamicFilter.');
        }
        /// Dynamic filter type. 
        // verify required parameter 'dynamicFilterType' is not null or undefined
        if (this.dynamicFilterType === null || this.dynamicFilterType === undefined) {
            throw new Error('Required parameter "dynamicFilterType" was null or undefined when calling PutWorksheetDynamicFilter.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "dynamicFilterType", this.dynamicFilterType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "matchBlanks", this.matchBlanks);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "refresh", this.refresh);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Filter the top 10 items in the list in the worksheet.   
export class PutWorksheetFilterTop10Request  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the range to which the specified AutoFilter applies.  
    public range: string;
    /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0).  
    public fieldIndex: number;
    /// Indicates whether filter from top or bottom  
    public isTop: boolean;
    /// Indicates whether the items is percent or count  
    public isPercent: boolean;
    /// The item count  
    public itemCount: number;
    /// Match all blank cell in the list.  
    public matchBlanks: boolean;
    /// Refresh auto filters to hide or unhide the rows.  
    public refresh: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetFilterTop10Request >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/autoFilter/filterTop10".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Represents the range to which the specified AutoFilter applies. 
        // verify required parameter 'range' is not null or undefined
        if (this.range === null || this.range === undefined) {
            throw new Error('Required parameter "range" was null or undefined when calling PutWorksheetFilterTop10.');
        }
        /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0). 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling PutWorksheetFilterTop10.');
        }
        /// Indicates whether filter from top or bottom 
        // verify required parameter 'isTop' is not null or undefined
        if (this.isTop === null || this.isTop === undefined) {
            throw new Error('Required parameter "isTop" was null or undefined when calling PutWorksheetFilterTop10.');
        }
        /// Indicates whether the items is percent or count 
        // verify required parameter 'isPercent' is not null or undefined
        if (this.isPercent === null || this.isPercent === undefined) {
            throw new Error('Required parameter "isPercent" was null or undefined when calling PutWorksheetFilterTop10.');
        }
        /// The item count 
        // verify required parameter 'itemCount' is not null or undefined
        if (this.itemCount === null || this.itemCount === undefined) {
            throw new Error('Required parameter "itemCount" was null or undefined when calling PutWorksheetFilterTop10.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isTop", this.isTop);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isPercent", this.isPercent);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "itemCount", this.itemCount);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "matchBlanks", this.matchBlanks);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "refresh", this.refresh);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add a color filter in the worksheet.   
export class PutWorksheetColorFilterRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the range to which the specified AutoFilter applies.  
    public range: string;
    /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0).  
    public fieldIndex: number;
    /// color filter request.  
    public colorFilter: ColorFilterRequest;
    /// Match all blank cell in the list.  
    public matchBlanks: boolean;
    /// Refresh auto filters to hide or unhide the rows.  
    public refresh: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetColorFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/autoFilter/colorFilter".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Represents the range to which the specified AutoFilter applies. 
        // verify required parameter 'range' is not null or undefined
        if (this.range === null || this.range === undefined) {
            throw new Error('Required parameter "range" was null or undefined when calling PutWorksheetColorFilter.');
        }
        /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0). 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling PutWorksheetColorFilter.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "matchBlanks", this.matchBlanks);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "refresh", this.refresh);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.colorFilter == null) ? null :   ObjectSerializer.serialize( this.colorFilter,this.colorFilter.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Match all blank cells in the list.   
export class PostWorksheetMatchBlanksRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0).  
    public fieldIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetMatchBlanksRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/autoFilter/matchBlanks".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0). 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling PostWorksheetMatchBlanks.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Match all not blank cells in the list.   
export class PostWorksheetMatchNonBlanksRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0).  
    public fieldIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetMatchNonBlanksRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/autoFilter/matchNonBlanks".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0). 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling PostWorksheetMatchNonBlanks.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Refresh auto filters in the worksheet.   
export class PostWorksheetAutoFilterRefreshRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetAutoFilterRefreshRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/autoFilter/refresh".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Remove a date filter in the worksheet.   
export class DeleteWorksheetDateFilterRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0).  
    public fieldIndex: number;
    /// Specifies how to group dateTime values.  
    public dateTimeGroupingType: string;
    /// The year.  
    public year: number;
    /// The month.  
    public month: number;
    /// The day.  
    public day: number;
    /// The hour.  
    public hour: number;
    /// The minute.  
    public minute: number;
    /// The second.  
    public second: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetDateFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/autoFilter/dateFilter".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0). 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling DeleteWorksheetDateFilter.');
        }
        /// Specifies how to group dateTime values. 
        // verify required parameter 'dateTimeGroupingType' is not null or undefined
        if (this.dateTimeGroupingType === null || this.dateTimeGroupingType === undefined) {
            throw new Error('Required parameter "dateTimeGroupingType" was null or undefined when calling DeleteWorksheetDateFilter.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "dateTimeGroupingType", this.dateTimeGroupingType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "year", this.year);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "month", this.month);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "day", this.day);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "hour", this.hour);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "minute", this.minute);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "second", this.second);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete a filter for a column in the worksheet.   
export class DeleteWorksheetFilterRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0).  
    public fieldIndex: number;
    /// The custom criteria.  
    public criteria: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/autoFilter/filter".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The integer offset of the field on which you want to base the filter (from the left of the list; the leftmost field is field 0). 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling DeleteWorksheetFilter.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "criteria", this.criteria);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get autoshapes description in worksheet.   
export class GetWorksheetAutoshapesRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Document's folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetAutoshapesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/autoshapes".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get autoshape description in some format.   
export class GetWorksheetAutoshapeWithFormatRequest  {
    /// The workbook name.  
    public name: string;
    /// Worksheet name.  
    public sheetName: string;
    /// The autoshape number.  
    public autoshapeNumber: number;
    /// Autoshape conversion format.  
    public format: string;
    /// The document folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetAutoshapeWithFormatRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/autoshapes/{autoshapeNumber}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "autoshapeNumber" + "}", String(this.autoshapeNumber));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Batch converting files that meet specific matching conditions.   
export class PostBatchConvertRequest  {
    /// BatchConvertRequest Batch conversion file request.   
    public batchConvertRequest: BatchConvertRequest;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostBatchConvertRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/batch/convert";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.batchConvertRequest == null) ? null :   ObjectSerializer.serialize( this.batchConvertRequest,this.batchConvertRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Batch protecting files that meet specific matching conditions.   
export class PostBatchProtectRequest  {
    /// BatchProtectRequest Batch protection file request.    
    public batchProtectRequest: BatchProtectRequest;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostBatchProtectRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/batch/protect";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.batchProtectRequest == null) ? null :   ObjectSerializer.serialize( this.batchProtectRequest,this.batchProtectRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Batch locking files that meet specific matching conditions.   
export class PostBatchLockRequest  {
    /// BatchLockRequest Batch locking file request.    
    public batchLockRequest: BatchLockRequest;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostBatchLockRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/batch/lock";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.batchLockRequest == null) ? null :   ObjectSerializer.serialize( this.batchLockRequest,this.batchLockRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Batch unlocking files that meet specific matching conditions.   
export class PostBatchUnlockRequest  {
    /// BatchLockRequest Batch locking file request.    
    public batchLockRequest: BatchLockRequest;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostBatchUnlockRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/batch/unlock";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.batchLockRequest == null) ? null :   ObjectSerializer.serialize( this.batchLockRequest,this.batchLockRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Batch splitting files that meet specific matching conditions.   
export class PostBatchSplitRequest  {
    /// BatchSplitRequest Batch splitting file request.    
    public batchSplitRequest: BatchSplitRequest;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostBatchSplitRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/batch/split";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.batchSplitRequest == null) ? null :   ObjectSerializer.serialize( this.batchSplitRequest,this.batchSplitRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Clear cell area contents in the worksheet.   
export class PostClearContentsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the range to which the specified cells applies.  
    public range: string;
    /// The start row index.  
    public startRow: number;
    /// The start column index.  
    public startColumn: number;
    /// The end row index.  
    public endRow: number;
    /// The end column index.  
    public endColumn: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostClearContentsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/clearcontents".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startRow", this.startRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startColumn", this.startColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endRow", this.endRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endColumn", this.endColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Clear cell formats in the worksheet.   
export class PostClearFormatsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the range to which the specified cells applies.  
    public range: string;
    /// The start row index.  
    public startRow: number;
    /// The start column index.  
    public startColumn: number;
    /// The end row index.  
    public endRow: number;
    /// The end column index.  
    public endColumn: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostClearFormatsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/clearformats".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startRow", this.startRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startColumn", this.startColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endRow", this.endRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endColumn", this.endColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update cell range styles in the worksheet.   
export class PostUpdateWorksheetRangeStyleRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the range to which the specified cells applies.  
    public range: string;
    /// Style with update style settings.  
    public style: Style;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUpdateWorksheetRangeStyleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/style".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Represents the range to which the specified cells applies. 
        // verify required parameter 'range' is not null or undefined
        if (this.range === null || this.range === undefined) {
            throw new Error('Required parameter "range" was null or undefined when calling PostUpdateWorksheetRangeStyle.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.style == null) ? null :   ObjectSerializer.serialize( this.style,this.style.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Merge cells in the worksheet.   
export class PostWorksheetMergeRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The start row index.  
    public startRow: number;
    /// The start column index.  
    public startColumn: number;
    /// The total rows number.  
    public totalRows: number;
    /// The total columns number.  
    public totalColumns: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetMergeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/merge".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The start row index. 
        // verify required parameter 'startRow' is not null or undefined
        if (this.startRow === null || this.startRow === undefined) {
            throw new Error('Required parameter "startRow" was null or undefined when calling PostWorksheetMerge.');
        }
        /// The start column index. 
        // verify required parameter 'startColumn' is not null or undefined
        if (this.startColumn === null || this.startColumn === undefined) {
            throw new Error('Required parameter "startColumn" was null or undefined when calling PostWorksheetMerge.');
        }
        /// The total rows number. 
        // verify required parameter 'totalRows' is not null or undefined
        if (this.totalRows === null || this.totalRows === undefined) {
            throw new Error('Required parameter "totalRows" was null or undefined when calling PostWorksheetMerge.');
        }
        /// The total columns number. 
        // verify required parameter 'totalColumns' is not null or undefined
        if (this.totalColumns === null || this.totalColumns === undefined) {
            throw new Error('Required parameter "totalColumns" was null or undefined when calling PostWorksheetMerge.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startRow", this.startRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startColumn", this.startColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalRows", this.totalRows);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalColumns", this.totalColumns);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Unmerge cells in the worksheet.   
export class PostWorksheetUnmergeRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The start row index.  
    public startRow: number;
    /// The start column index.  
    public startColumn: number;
    /// The total rows number.  
    public totalRows: number;
    /// The total columns number.  
    public totalColumns: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetUnmergeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/unmerge".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The start row index. 
        // verify required parameter 'startRow' is not null or undefined
        if (this.startRow === null || this.startRow === undefined) {
            throw new Error('Required parameter "startRow" was null or undefined when calling PostWorksheetUnmerge.');
        }
        /// The start column index. 
        // verify required parameter 'startColumn' is not null or undefined
        if (this.startColumn === null || this.startColumn === undefined) {
            throw new Error('Required parameter "startColumn" was null or undefined when calling PostWorksheetUnmerge.');
        }
        /// The total rows number. 
        // verify required parameter 'totalRows' is not null or undefined
        if (this.totalRows === null || this.totalRows === undefined) {
            throw new Error('Required parameter "totalRows" was null or undefined when calling PostWorksheetUnmerge.');
        }
        /// The total columns number. 
        // verify required parameter 'totalColumns' is not null or undefined
        if (this.totalColumns === null || this.totalColumns === undefined) {
            throw new Error('Required parameter "totalColumns" was null or undefined when calling PostWorksheetUnmerge.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startRow", this.startRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startColumn", this.startColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalRows", this.totalRows);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalColumns", this.totalColumns);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve cell descriptions in a specified format.   
export class GetWorksheetCellsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Begginig offset.  
    public offest: number;
    /// Maximum amount of cells in the response.  
    public count: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetCellsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "offest", this.offest);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "count", this.count);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve cell data using either cell reference or method name in the worksheet.   
export class GetWorksheetCellRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The cell's or method name. (Method name like firstcell, endcell etc.)  
    public cellOrMethodName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetCellRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/{cellOrMethodName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellOrMethodName" + "}", String(this.cellOrMethodName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve cell style descriptions in the worksheet.   
export class GetWorksheetCellStyleRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Cell's name.  
    public cellName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetCellStyleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/{cellName}/style".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellName" + "}", String(this.cellName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Set cell value using cell name in the worksheet.   
export class PostWorksheetCellSetValueRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The cell name.  
    public cellName: string;
    /// The cell value.  
    public value: string;
    /// The value type.  
    public type: string;
    /// Formula for cell  
    public formula: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellSetValueRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/{cellName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellName" + "}", String(this.cellName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "value", this.value);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "type", this.type);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "formula", this.formula);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Set cell style using cell name in the worksheet.   
export class PostUpdateWorksheetCellStyleRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The cell name.  
    public cellName: string;
    /// Style with update style settings.  
    public style: Style;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUpdateWorksheetCellStyleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/{cellName}/style".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellName" + "}", String(this.cellName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.style == null) ? null :   ObjectSerializer.serialize( this.style,this.style.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Set the value of the range in the worksheet.   
export class PostSetCellRangeValueRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Cell area (like "A1:C2")  
    public cellarea: string;
    /// Range value  
    public value: string;
    /// Value data type (like "int")  
    public type: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostSetCellRangeValueRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Cell area (like "A1:C2") 
        // verify required parameter 'cellarea' is not null or undefined
        if (this.cellarea === null || this.cellarea === undefined) {
            throw new Error('Required parameter "cellarea" was null or undefined when calling PostSetCellRangeValue.');
        }
        /// Range value 
        // verify required parameter 'value' is not null or undefined
        if (this.value === null || this.value === undefined) {
            throw new Error('Required parameter "value" was null or undefined when calling PostSetCellRangeValue.');
        }
        /// Value data type (like "int") 
        // verify required parameter 'type' is not null or undefined
        if (this.type === null || this.type === undefined) {
            throw new Error('Required parameter "type" was null or undefined when calling PostSetCellRangeValue.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellarea", this.cellarea);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "value", this.value);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "type", this.type);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Copy data from a source cell to a destination cell in the worksheet.   
export class PostCopyCellIntoCellRequest  {
    /// The file name.  
    public name: string;
    /// The destination cell name.  
    public destCellName: string;
    /// The destination worksheet name.  
    public sheetName: string;
    /// The source worksheet name.  
    public worksheet: string;
    /// The source cell name.  
    public cellname: string;
    /// The source row index.  
    public row: number;
    /// The source column index.  
    public column: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostCopyCellIntoCellRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/{destCellName}/copy".replace("{" + "name" + "}", String(this.name)).replace("{" + "destCellName" + "}", String(this.destCellName)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The source worksheet name. 
        // verify required parameter 'worksheet' is not null or undefined
        if (this.worksheet === null || this.worksheet === undefined) {
            throw new Error('Required parameter "worksheet" was null or undefined when calling PostCopyCellIntoCell.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "worksheet", this.worksheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellname", this.cellname);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "row", this.row);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "column", this.column);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve the HTML string containing data and specific formats in this cell.   
export class GetCellHtmlStringRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The cell name.  
    public cellName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetCellHtmlStringRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/{cellName}/htmlstring".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellName" + "}", String(this.cellName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Set the HTML string containing data and specific formats in this cell.   
export class PostSetCellHtmlStringRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The cell name.  
    public cellName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostSetCellHtmlStringRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/{cellName}/htmlstring".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellName" + "}", String(this.cellName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Calculate cell formula in the worksheet.   
export class PostCellCalculateRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The cell name.  
    public cellName: string;
    /// Calculation Options  
    public options: CalculationOptions;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostCellCalculateRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/{cellName}/calculate".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellName" + "}", String(this.cellName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.options == null) ? null :   ObjectSerializer.serialize( this.options,this.options.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Set cell characters in the worksheet.   
export class PostCellCharactersRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The cell name.  
    public cellName: string;
      
    public options: Array<FontSetting>;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostCellCharactersRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/{cellName}/characters".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellName" + "}", String(this.cellName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.options == null) ? null :   ObjectSerializer.serialize( this.options,this.options.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve descriptions of worksheet columns.   
export class GetWorksheetColumnsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The workdook folder.  
    public offset: number;
      
    public count: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetColumnsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/columns/".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "offset", this.offset);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "count", this.count);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Set worksheet column width.   
export class PostSetWorksheetColumnWidthRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The column index.  
    public columnIndex: number;
    /// Gets and sets the column width in unit of characters.  
    public width: number;
      
    public count: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostSetWorksheetColumnWidthRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/columns/{columnIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "columnIndex" + "}", String(this.columnIndex));
        const queryParameters: any = {};
        /// Gets and sets the column width in unit of characters. 
        // verify required parameter 'width' is not null or undefined
        if (this.width === null || this.width === undefined) {
            throw new Error('Required parameter "width" was null or undefined when calling PostSetWorksheetColumnWidth.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "width", this.width);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "count", this.count);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve worksheet column data by column index.   
export class GetWorksheetColumnRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The column index.  
    public columnIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetColumnRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/columns/{columnIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "columnIndex" + "}", String(this.columnIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Insert worksheet columns in the worksheet.   
export class PutInsertWorksheetColumnsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The column index.  
    public columnIndex: number;
    /// The number of columns.  
    public columns: number;
    /// Indicates if references in other worksheets will be updated.  
    public updateReference: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutInsertWorksheetColumnsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/columns/{columnIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "columnIndex" + "}", String(this.columnIndex));
        const queryParameters: any = {};
        /// The number of columns. 
        // verify required parameter 'columns' is not null or undefined
        if (this.columns === null || this.columns === undefined) {
            throw new Error('Required parameter "columns" was null or undefined when calling PutInsertWorksheetColumns.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "columns", this.columns);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "updateReference", this.updateReference);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete worksheet columns in the worksheet.   
export class DeleteWorksheetColumnsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The column index.  
    public columnIndex: number;
    /// The number of columns.  
    public columns: number;
    /// Indicates if references in other worksheets will be updated.  
    public updateReference: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetColumnsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/columns/{columnIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "columnIndex" + "}", String(this.columnIndex));
        const queryParameters: any = {};
        /// The number of columns. 
        // verify required parameter 'columns' is not null or undefined
        if (this.columns === null || this.columns === undefined) {
            throw new Error('Required parameter "columns" was null or undefined when calling DeleteWorksheetColumns.');
        }
        /// Indicates if references in other worksheets will be updated. 
        // verify required parameter 'updateReference' is not null or undefined
        if (this.updateReference === null || this.updateReference === undefined) {
            throw new Error('Required parameter "updateReference" was null or undefined when calling DeleteWorksheetColumns.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "columns", this.columns);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "updateReference", this.updateReference);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Hide worksheet columns in the worksheet.   
export class PostHideWorksheetColumnsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The begin column index to be operated.  
    public startColumn: number;
    /// Number of columns to be operated.  
    public totalColumns: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostHideWorksheetColumnsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/columns/hide".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The begin column index to be operated. 
        // verify required parameter 'startColumn' is not null or undefined
        if (this.startColumn === null || this.startColumn === undefined) {
            throw new Error('Required parameter "startColumn" was null or undefined when calling PostHideWorksheetColumns.');
        }
        /// Number of columns to be operated. 
        // verify required parameter 'totalColumns' is not null or undefined
        if (this.totalColumns === null || this.totalColumns === undefined) {
            throw new Error('Required parameter "totalColumns" was null or undefined when calling PostHideWorksheetColumns.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startColumn", this.startColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalColumns", this.totalColumns);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Unhide worksheet columns in the worksheet.   
export class PostUnhideWorksheetColumnsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The begin column index to be operated.  
    public startColumn: number;
    /// Number of columns to be operated.  
    public totalColumns: number;
    /// Gets and sets the column width in unit of characters.  
    public width: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUnhideWorksheetColumnsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/columns/unhide".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The begin column index to be operated. 
        // verify required parameter 'startColumn' is not null or undefined
        if (this.startColumn === null || this.startColumn === undefined) {
            throw new Error('Required parameter "startColumn" was null or undefined when calling PostUnhideWorksheetColumns.');
        }
        /// Number of columns to be operated. 
        // verify required parameter 'totalColumns' is not null or undefined
        if (this.totalColumns === null || this.totalColumns === undefined) {
            throw new Error('Required parameter "totalColumns" was null or undefined when calling PostUnhideWorksheetColumns.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startColumn", this.startColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalColumns", this.totalColumns);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "width", this.width);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Group worksheet columns in the worksheet.   
export class PostGroupWorksheetColumnsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The first column index to be operated.  
    public firstIndex: number;
    /// The last column index to be operated.  
    public lastIndex: number;
    /// columns visible state  
    public hide: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostGroupWorksheetColumnsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/columns/group".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The first column index to be operated. 
        // verify required parameter 'firstIndex' is not null or undefined
        if (this.firstIndex === null || this.firstIndex === undefined) {
            throw new Error('Required parameter "firstIndex" was null or undefined when calling PostGroupWorksheetColumns.');
        }
        /// The last column index to be operated. 
        // verify required parameter 'lastIndex' is not null or undefined
        if (this.lastIndex === null || this.lastIndex === undefined) {
            throw new Error('Required parameter "lastIndex" was null or undefined when calling PostGroupWorksheetColumns.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "firstIndex", this.firstIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "lastIndex", this.lastIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "hide", this.hide);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Ungroup worksheet columns.   
export class PostUngroupWorksheetColumnsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The first column index to be operated.  
    public firstIndex: number;
    /// The last column index to be operated.  
    public lastIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUngroupWorksheetColumnsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/columns/ungroup".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The first column index to be operated. 
        // verify required parameter 'firstIndex' is not null or undefined
        if (this.firstIndex === null || this.firstIndex === undefined) {
            throw new Error('Required parameter "firstIndex" was null or undefined when calling PostUngroupWorksheetColumns.');
        }
        /// The last column index to be operated. 
        // verify required parameter 'lastIndex' is not null or undefined
        if (this.lastIndex === null || this.lastIndex === undefined) {
            throw new Error('Required parameter "lastIndex" was null or undefined when calling PostUngroupWorksheetColumns.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "firstIndex", this.firstIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "lastIndex", this.lastIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Copy data from source columns to destination columns in the worksheet.   
export class PostCopyWorksheetColumnsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Source column index  
    public sourceColumnIndex: number;
    /// Destination column index  
    public destinationColumnIndex: number;
    /// The copied column number  
    public columnNumber: number;
    /// The destination worksheet name.  
    public worksheet: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostCopyWorksheetColumnsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/columns/copy".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Source column index 
        // verify required parameter 'sourceColumnIndex' is not null or undefined
        if (this.sourceColumnIndex === null || this.sourceColumnIndex === undefined) {
            throw new Error('Required parameter "sourceColumnIndex" was null or undefined when calling PostCopyWorksheetColumns.');
        }
        /// Destination column index 
        // verify required parameter 'destinationColumnIndex' is not null or undefined
        if (this.destinationColumnIndex === null || this.destinationColumnIndex === undefined) {
            throw new Error('Required parameter "destinationColumnIndex" was null or undefined when calling PostCopyWorksheetColumns.');
        }
        /// The copied column number 
        // verify required parameter 'columnNumber' is not null or undefined
        if (this.columnNumber === null || this.columnNumber === undefined) {
            throw new Error('Required parameter "columnNumber" was null or undefined when calling PostCopyWorksheetColumns.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sourceColumnIndex", this.sourceColumnIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destinationColumnIndex", this.destinationColumnIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "columnNumber", this.columnNumber);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "worksheet", this.worksheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Set column style in the worksheet.   
export class PostColumnStyleRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The column index.  
    public columnIndex: number;
    /// Represents display style of excel document,such as font,color,alignment,border,etc.  
    public style: Style;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostColumnStyleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/columns/{columnIndex}/style".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "columnIndex" + "}", String(this.columnIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.style == null) ? null :   ObjectSerializer.serialize( this.style,this.style.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve descriptions of rows in the worksheet.   
export class GetWorksheetRowsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Row offset.  
    public offset: number;
    /// Display rows number.  
    public count: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetRowsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/rows/".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "offset", this.offset);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "count", this.count);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve row data by the row's index in the worksheet.   
export class GetWorksheetRowRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The row index.  
    public rowIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetRowRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/rows/{rowIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "rowIndex" + "}", String(this.rowIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete a row in the worksheet.   
export class DeleteWorksheetRowRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The row index.  
    public rowIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetRowRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/rows/{rowIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "rowIndex" + "}", String(this.rowIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete several rows in the worksheet.   
export class DeleteWorksheetRowsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The begin row index to be operated.  
    public startrow: number;
    /// Number of rows to be operated.  
    public totalRows: number;
    /// Indicates if update references in other worksheets.  
    public updateReference: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetRowsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/rows/".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The begin row index to be operated. 
        // verify required parameter 'startrow' is not null or undefined
        if (this.startrow === null || this.startrow === undefined) {
            throw new Error('Required parameter "startrow" was null or undefined when calling DeleteWorksheetRows.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startrow", this.startrow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalRows", this.totalRows);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "updateReference", this.updateReference);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Insert several new rows in the worksheet.   
export class PutInsertWorksheetRowsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The begin row index to be operated.  
    public startrow: number;
    /// Number of rows to be operated.  
    public totalRows: number;
    /// Indicates if update references in other worksheets.  
    public updateReference: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutInsertWorksheetRowsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/rows/".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The begin row index to be operated. 
        // verify required parameter 'startrow' is not null or undefined
        if (this.startrow === null || this.startrow === undefined) {
            throw new Error('Required parameter "startrow" was null or undefined when calling PutInsertWorksheetRows.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startrow", this.startrow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalRows", this.totalRows);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "updateReference", this.updateReference);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Insert a new row in the worksheet.   
export class PutInsertWorksheetRowRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The new row index.  
    public rowIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutInsertWorksheetRowRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/rows/{rowIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "rowIndex" + "}", String(this.rowIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update height of rows in the worksheet.   
export class PostUpdateWorksheetRowRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The row index.  
    public rowIndex: number;
    /// The new row height.  
    public height: number;
      
    public count: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUpdateWorksheetRowRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/rows/{rowIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "rowIndex" + "}", String(this.rowIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "height", this.height);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "count", this.count);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Hide rows in worksheet.   
export class PostHideWorksheetRowsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The begin row index to be operated.  
    public startrow: number;
    /// Number of rows to be operated.  
    public totalRows: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostHideWorksheetRowsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/rows/hide".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The begin row index to be operated. 
        // verify required parameter 'startrow' is not null or undefined
        if (this.startrow === null || this.startrow === undefined) {
            throw new Error('Required parameter "startrow" was null or undefined when calling PostHideWorksheetRows.');
        }
        /// Number of rows to be operated. 
        // verify required parameter 'totalRows' is not null or undefined
        if (this.totalRows === null || this.totalRows === undefined) {
            throw new Error('Required parameter "totalRows" was null or undefined when calling PostHideWorksheetRows.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startrow", this.startrow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalRows", this.totalRows);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Unhide rows in the worksheet.   
export class PostUnhideWorksheetRowsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The begin row index to be operated.  
    public startrow: number;
    /// Number of rows to be operated.  
    public totalRows: number;
    /// The new row height.  
    public height: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUnhideWorksheetRowsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/rows/unhide".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The begin row index to be operated. 
        // verify required parameter 'startrow' is not null or undefined
        if (this.startrow === null || this.startrow === undefined) {
            throw new Error('Required parameter "startrow" was null or undefined when calling PostUnhideWorksheetRows.');
        }
        /// Number of rows to be operated. 
        // verify required parameter 'totalRows' is not null or undefined
        if (this.totalRows === null || this.totalRows === undefined) {
            throw new Error('Required parameter "totalRows" was null or undefined when calling PostUnhideWorksheetRows.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startrow", this.startrow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalRows", this.totalRows);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "height", this.height);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Group rows in the worksheet.   
export class PostGroupWorksheetRowsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The first row index to be operated.  
    public firstIndex: number;
    /// The last row index to be operated.  
    public lastIndex: number;
    /// rows visible state  
    public hide: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostGroupWorksheetRowsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/rows/group".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The first row index to be operated. 
        // verify required parameter 'firstIndex' is not null or undefined
        if (this.firstIndex === null || this.firstIndex === undefined) {
            throw new Error('Required parameter "firstIndex" was null or undefined when calling PostGroupWorksheetRows.');
        }
        /// The last row index to be operated. 
        // verify required parameter 'lastIndex' is not null or undefined
        if (this.lastIndex === null || this.lastIndex === undefined) {
            throw new Error('Required parameter "lastIndex" was null or undefined when calling PostGroupWorksheetRows.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "firstIndex", this.firstIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "lastIndex", this.lastIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "hide", this.hide);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Ungroup rows in the worksheet.   
export class PostUngroupWorksheetRowsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The first row index to be operated.  
    public firstIndex: number;
    /// The last row index to be operated.  
    public lastIndex: number;
    /// Is all row to be operated  
    public isAll: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUngroupWorksheetRowsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/rows/ungroup".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The first row index to be operated. 
        // verify required parameter 'firstIndex' is not null or undefined
        if (this.firstIndex === null || this.firstIndex === undefined) {
            throw new Error('Required parameter "firstIndex" was null or undefined when calling PostUngroupWorksheetRows.');
        }
        /// The last row index to be operated. 
        // verify required parameter 'lastIndex' is not null or undefined
        if (this.lastIndex === null || this.lastIndex === undefined) {
            throw new Error('Required parameter "lastIndex" was null or undefined when calling PostUngroupWorksheetRows.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "firstIndex", this.firstIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "lastIndex", this.lastIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isAll", this.isAll);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Copy data and formats from specific entire rows in the worksheet.   
export class PostCopyWorksheetRowsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Source row index  
    public sourceRowIndex: number;
    /// Destination row index  
    public destinationRowIndex: number;
    /// The copied row number  
    public rowNumber: number;
    /// The worksheet name.  
    public worksheet: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostCopyWorksheetRowsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/rows/copy".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Source row index 
        // verify required parameter 'sourceRowIndex' is not null or undefined
        if (this.sourceRowIndex === null || this.sourceRowIndex === undefined) {
            throw new Error('Required parameter "sourceRowIndex" was null or undefined when calling PostCopyWorksheetRows.');
        }
        /// Destination row index 
        // verify required parameter 'destinationRowIndex' is not null or undefined
        if (this.destinationRowIndex === null || this.destinationRowIndex === undefined) {
            throw new Error('Required parameter "destinationRowIndex" was null or undefined when calling PostCopyWorksheetRows.');
        }
        /// The copied row number 
        // verify required parameter 'rowNumber' is not null or undefined
        if (this.rowNumber === null || this.rowNumber === undefined) {
            throw new Error('Required parameter "rowNumber" was null or undefined when calling PostCopyWorksheetRows.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sourceRowIndex", this.sourceRowIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destinationRowIndex", this.destinationRowIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "rowNumber", this.rowNumber);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "worksheet", this.worksheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Apply formats to an entire row in the worksheet.   
export class PostRowStyleRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The row index.  
    public rowIndex: number;
    /// Style description.  
    public style: Style;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostRowStyleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/cells/rows/{rowIndex}/style".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "rowIndex" + "}", String(this.rowIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.style == null) ? null :   ObjectSerializer.serialize( this.style,this.style.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve cell descriptions in a specified format.   
export class GetCellsCloudServicesHealthCheckRequest  {
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetCellsCloudServicesHealthCheckRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Aspose.Cells Cloud service health status check.   
export class GetCellsCloudServiceStatusRequest  {
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetCellsCloudServiceStatusRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/status/check";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve chart area description in the worksheet.   
export class GetChartAreaRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetChartAreaRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/chartArea".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve chart area fill format description in the worksheet.   
export class GetChartAreaFillFormatRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetChartAreaFillFormatRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/chartArea/fillFormat".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve chart area border description.   
export class GetChartAreaBorderRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetChartAreaBorderRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/chartArea/border".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve descriptions of charts in the worksheet.   
export class GetWorksheetChartsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetChartsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve the chart in a specified format.   
export class GetWorksheetChartRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart number.  
    public chartNumber: number;
    /// Chart conversion format.(PNG/TIFF/JPEG/GIF/EMF/BMP)  
    public format: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetChartRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartNumber}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartNumber" + "}", String(this.chartNumber));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add a new chart in the worksheet.   
export class PutWorksheetChartRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Chart type, please refer property Type in chart resource.  
    public chartType: string;
    /// Upper-left row for the new chart.  
    public upperLeftRow: number;
    /// Upper-left column for the new chart.  
    public upperLeftColumn: number;
    /// Lower-left row for the new chart.  
    public lowerRightRow: number;
    /// Lower-left column for the new chart.  
    public lowerRightColumn: number;
    /// Specify the values from which to plot the data series.  
    public area: string;
    /// Specify whether to plot the series from a range of cell values by row or by column.   
    public isVertical: boolean;
    /// Get or set the range of category axis values. It can be a range of cells (e.g., "D1:E10").  
    public categoryData: string;
    /// Specify whether to auto-update the serial name.  
    public isAutoGetSerialName: boolean;
    /// Specify the chart title name.  
    public title: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// Represents the specified chart's data label values display behavior. True to display the values, False to hide them.  
    public dataLabels: boolean;
    /// Represents data label position (Center/InsideBase/InsideEnd/OutsideEnd/Above/Below/Left/Right/BestFit/Moved).  
    public dataLabelsPosition: string;
    /// The source is the data of the pivotTable. If PivotSource is not empty, the chart is a PivotChart.  
    public pivotTableSheet: string;
    /// The pivot table name.  
    public pivotTableName: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetChartRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Chart type, please refer property Type in chart resource. 
        // verify required parameter 'chartType' is not null or undefined
        if (this.chartType === null || this.chartType === undefined) {
            throw new Error('Required parameter "chartType" was null or undefined when calling PutWorksheetChart.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "chartType", this.chartType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "upperLeftRow", this.upperLeftRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "upperLeftColumn", this.upperLeftColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "lowerRightRow", this.lowerRightRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "lowerRightColumn", this.lowerRightColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "area", this.area);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isVertical", this.isVertical);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "categoryData", this.categoryData);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isAutoGetSerialName", this.isAutoGetSerialName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "title", this.title);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "dataLabels", this.dataLabels);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "dataLabelsPosition", this.dataLabelsPosition);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pivotTableSheet", this.pivotTableSheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pivotTableName", this.pivotTableName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete a chart by index in the worksheet.   
export class DeleteWorksheetChartRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetChartRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update chart properties in the worksheet.   
export class PostWorksheetChartRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// Chart Represents a specified chart.  
    public chart: Chart;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetChartRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.chart == null) ? null :   ObjectSerializer.serialize( this.chart,this.chart.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve chart legend description in the worksheet.   
export class GetWorksheetChartLegendRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetChartLegendRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/legend".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update chart legend in the worksheet.   
export class PostWorksheetChartLegendRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
      
    public legend: Legend;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetChartLegendRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/legend".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.legend == null) ? null :   ObjectSerializer.serialize( this.legend,this.legend.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Show chart legend in the worksheet.   
export class PutWorksheetChartLegendRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetChartLegendRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/legend".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Hides chart legend in the worksheet.   
export class DeleteWorksheetChartLegendRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetChartLegendRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/legend".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Clear the charts in the worksheets.   
export class DeleteWorksheetChartsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetChartsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve chart title description in the worksheet.   
export class GetWorksheetChartTitleRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetChartTitleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/title".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update chart title in the worksheet.   
export class PostWorksheetChartTitleRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// TitleChart title  
    public title: Title;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetChartTitleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/title".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.title == null) ? null :   ObjectSerializer.serialize( this.title,this.title.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Set chart title in the worksheet.   
export class PutWorksheetChartTitleRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// TitleChart title.  
    public title: Title;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetChartTitleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/title".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.title == null) ? null :   ObjectSerializer.serialize( this.title,this.title.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Hide chart title in the worksheet.   
export class DeleteWorksheetChartTitleRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetChartTitleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/title".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve descriptions of chart seriesaxis in the chart.   
export class GetChartSeriesAxisRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetChartSeriesAxisRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/seriesaxis".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve descriptions of chart series axis in the chart.   
export class GetChartCategoryAxisRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetChartCategoryAxisRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/categoryaxis".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve chart value axis in the chart.   
export class GetChartValueAxisRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetChartValueAxisRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/valueaxis".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve chart second category axis in the chart   
export class GetChartSecondCategoryAxisRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetChartSecondCategoryAxisRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/secondcategoryaxis".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve chart second value axis in the chart.   
export class GetChartSecondValueAxisRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetChartSecondValueAxisRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/secondvalueaxis".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update chart series axis in the chart.   
export class PostChartSeriesAxisRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// Axis   
    public axis: Axis;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostChartSeriesAxisRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/seriesaxis".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.axis == null) ? null :   ObjectSerializer.serialize( this.axis,this.axis.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update chart category axis in the chart.   
export class PostChartCategoryAxisRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// Axis   
    public axis: Axis;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostChartCategoryAxisRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/categoryaxis".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.axis == null) ? null :   ObjectSerializer.serialize( this.axis,this.axis.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update chart value axis in the chart.   
export class PostChartValueAxisRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// Axis   
    public axis: Axis;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostChartValueAxisRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/valueaxis".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.axis == null) ? null :   ObjectSerializer.serialize( this.axis,this.axis.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update chart sencond category axis in the chart.   
export class PostChartSecondCategoryAxisRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// Axis   
    public axis: Axis;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostChartSecondCategoryAxisRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/secondcategoryaxis".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.axis == null) ? null :   ObjectSerializer.serialize( this.axis,this.axis.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update chart sencond value axis in the chart.   
export class PostChartSecondValueAxisRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The chart index.  
    public chartIndex: number;
    /// Axis   
    public axis: Axis;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostChartSecondValueAxisRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/charts/{chartIndex}/secondvalueaxis".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "chartIndex" + "}", String(this.chartIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.axis == null) ? null :   ObjectSerializer.serialize( this.axis,this.axis.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve descriptions of conditional formattings in a worksheet.   
export class GetWorksheetConditionalFormattingsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetConditionalFormattingsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/conditionalFormattings".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve conditional formatting descriptions in the worksheet.   
export class GetWorksheetConditionalFormattingRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The conditional formatting index.  
    public index: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetConditionalFormattingRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/conditionalFormattings/{index}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "index" + "}", String(this.index));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add conditional formatting in the worksheet.   
export class PutWorksheetConditionalFormattingRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
      
    public formatcondition: FormatCondition;
    /// Adds a conditional formatted cell range.  
    public cellArea: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetConditionalFormattingRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/conditionalFormattings".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Adds a conditional formatted cell range. 
        // verify required parameter 'cellArea' is not null or undefined
        if (this.cellArea === null || this.cellArea === undefined) {
            throw new Error('Required parameter "cellArea" was null or undefined when calling PutWorksheetConditionalFormatting.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellArea", this.cellArea);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.formatcondition == null) ? null :   ObjectSerializer.serialize( this.formatcondition,this.formatcondition.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add a format condition in the worksheet.   
export class PutWorksheetFormatConditionRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the Conditional Formatting element at the specified index.  
    public index: number;
    /// Adds a conditional formatted cell range.  
    public cellArea: string;
    /// Format condition type(CellValue/Expression/ColorScale/DataBar/IconSet/Top10/UniqueValues/DuplicateValues/ContainsText/NotContainsText/BeginsWith/EndsWith/ContainsBlanks/NotContainsBlanks/ContainsErrors/NotContainsErrors/TimePeriod/AboveAverage).  
    public type: string;
    /// Represents the operator type of conditional format and data validation(Between/Equal/GreaterThan/GreaterOrEqual/LessThan/None/NotBetween/NotEqual).  
    public operatorType: string;
    /// The value or expression associated with conditional formatting.  
    public formula1: string;
    /// The value or expression associated with conditional formatting.  
    public formula2: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetFormatConditionRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/conditionalFormattings/{index}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "index" + "}", String(this.index));
        const queryParameters: any = {};
        /// Adds a conditional formatted cell range. 
        // verify required parameter 'cellArea' is not null or undefined
        if (this.cellArea === null || this.cellArea === undefined) {
            throw new Error('Required parameter "cellArea" was null or undefined when calling PutWorksheetFormatCondition.');
        }
        /// Format condition type(CellValue/Expression/ColorScale/DataBar/IconSet/Top10/UniqueValues/DuplicateValues/ContainsText/NotContainsText/BeginsWith/EndsWith/ContainsBlanks/NotContainsBlanks/ContainsErrors/NotContainsErrors/TimePeriod/AboveAverage). 
        // verify required parameter 'type' is not null or undefined
        if (this.type === null || this.type === undefined) {
            throw new Error('Required parameter "type" was null or undefined when calling PutWorksheetFormatCondition.');
        }
        /// Represents the operator type of conditional format and data validation(Between/Equal/GreaterThan/GreaterOrEqual/LessThan/None/NotBetween/NotEqual). 
        // verify required parameter 'operatorType' is not null or undefined
        if (this.operatorType === null || this.operatorType === undefined) {
            throw new Error('Required parameter "operatorType" was null or undefined when calling PutWorksheetFormatCondition.');
        }
        /// The value or expression associated with conditional formatting. 
        // verify required parameter 'formula1' is not null or undefined
        if (this.formula1 === null || this.formula1 === undefined) {
            throw new Error('Required parameter "formula1" was null or undefined when calling PutWorksheetFormatCondition.');
        }
        /// The value or expression associated with conditional formatting. 
        // verify required parameter 'formula2' is not null or undefined
        if (this.formula2 === null || this.formula2 === undefined) {
            throw new Error('Required parameter "formula2" was null or undefined when calling PutWorksheetFormatCondition.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellArea", this.cellArea);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "type", this.type);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "operatorType", this.operatorType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "formula1", this.formula1);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "formula2", this.formula2);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add a cell area for the format condition in the worksheet.   
export class PutWorksheetFormatConditionAreaRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the Conditional Formatting element at the specified index.  
    public index: number;
    /// Adds a conditional formatted cell range.  
    public cellArea: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetFormatConditionAreaRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/conditionalFormattings/{index}/area".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "index" + "}", String(this.index));
        const queryParameters: any = {};
        /// Adds a conditional formatted cell range. 
        // verify required parameter 'cellArea' is not null or undefined
        if (this.cellArea === null || this.cellArea === undefined) {
            throw new Error('Required parameter "cellArea" was null or undefined when calling PutWorksheetFormatConditionArea.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellArea", this.cellArea);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add a condition for the format condition in the worksheet.   
export class PutWorksheetFormatConditionConditionRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the Conditional Formatting element at the specified index.  
    public index: number;
    /// Format condition type(CellValue/Expression/ColorScale/DataBar/IconSet/Top10/UniqueValues/DuplicateValues/ContainsText/NotContainsText/BeginsWith/EndsWith/ContainsBlanks/NotContainsBlanks/ContainsErrors/NotContainsErrors/TimePeriod/AboveAverage).  
    public type: string;
    /// Represents the operator type of conditional format and data validation(Between/Equal/GreaterThan/GreaterOrEqual/LessThan/None/NotBetween/NotEqual).  
    public operatorType: string;
    /// The value or expression associated with conditional formatting.  
    public formula1: string;
    /// The value or expression associated with conditional formatting.  
    public formula2: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetFormatConditionConditionRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/conditionalFormattings/{index}/condition".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "index" + "}", String(this.index));
        const queryParameters: any = {};
        /// Format condition type(CellValue/Expression/ColorScale/DataBar/IconSet/Top10/UniqueValues/DuplicateValues/ContainsText/NotContainsText/BeginsWith/EndsWith/ContainsBlanks/NotContainsBlanks/ContainsErrors/NotContainsErrors/TimePeriod/AboveAverage). 
        // verify required parameter 'type' is not null or undefined
        if (this.type === null || this.type === undefined) {
            throw new Error('Required parameter "type" was null or undefined when calling PutWorksheetFormatConditionCondition.');
        }
        /// Represents the operator type of conditional format and data validation(Between/Equal/GreaterThan/GreaterOrEqual/LessThan/None/NotBetween/NotEqual). 
        // verify required parameter 'operatorType' is not null or undefined
        if (this.operatorType === null || this.operatorType === undefined) {
            throw new Error('Required parameter "operatorType" was null or undefined when calling PutWorksheetFormatConditionCondition.');
        }
        /// The value or expression associated with conditional formatting. 
        // verify required parameter 'formula1' is not null or undefined
        if (this.formula1 === null || this.formula1 === undefined) {
            throw new Error('Required parameter "formula1" was null or undefined when calling PutWorksheetFormatConditionCondition.');
        }
        /// The value or expression associated with conditional formatting. 
        // verify required parameter 'formula2' is not null or undefined
        if (this.formula2 === null || this.formula2 === undefined) {
            throw new Error('Required parameter "formula2" was null or undefined when calling PutWorksheetFormatConditionCondition.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "type", this.type);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "operatorType", this.operatorType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "formula1", this.formula1);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "formula2", this.formula2);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Clear all conditional formattings in the worksheet.   
export class DeleteWorksheetConditionalFormattingsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetConditionalFormattingsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/conditionalFormattings".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Remove a conditional formatting.   
export class DeleteWorksheetConditionalFormattingRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the Conditional Formatting element at the specified index.  
    public index: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetConditionalFormattingRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/conditionalFormattings/{index}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "index" + "}", String(this.index));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Remove cell area from conditional formatting.   
export class DeleteWorksheetConditionalFormattingAreaRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The start row of the range.  
    public startRow: number;
    /// The start column of the range.  
    public startColumn: number;
    /// The number of rows of the range.  
    public totalRows: number;
    /// The number of columns of the range.  
    public totalColumns: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetConditionalFormattingAreaRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/conditionalFormattings/area".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The start row of the range. 
        // verify required parameter 'startRow' is not null or undefined
        if (this.startRow === null || this.startRow === undefined) {
            throw new Error('Required parameter "startRow" was null or undefined when calling DeleteWorksheetConditionalFormattingArea.');
        }
        /// The start column of the range. 
        // verify required parameter 'startColumn' is not null or undefined
        if (this.startColumn === null || this.startColumn === undefined) {
            throw new Error('Required parameter "startColumn" was null or undefined when calling DeleteWorksheetConditionalFormattingArea.');
        }
        /// The number of rows of the range. 
        // verify required parameter 'totalRows' is not null or undefined
        if (this.totalRows === null || this.totalRows === undefined) {
            throw new Error('Required parameter "totalRows" was null or undefined when calling DeleteWorksheetConditionalFormattingArea.');
        }
        /// The number of columns of the range. 
        // verify required parameter 'totalColumns' is not null or undefined
        if (this.totalColumns === null || this.totalColumns === undefined) {
            throw new Error('Required parameter "totalColumns" was null or undefined when calling DeleteWorksheetConditionalFormattingArea.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startRow", this.startRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startColumn", this.startColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalRows", this.totalRows);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalColumns", this.totalColumns);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve workbooks in various formats.   
export class GetWorkbookRequest  {
    /// The file name.  
    public name: string;
    /// The conversion format(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers).  
    public format: string;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Specifies whether set workbook rows to be autofit.  
    public isAutoFit: boolean;
    /// Specifies whether only save table data.Only use pdf to excel.  
    public onlySaveTable: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// Path to save the result. If it's a single file, the `outPath` should encompass both the filename and extension. In the case of multiple files, the `outPath` should only include the folder.  
    public outPath: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// The storage name where the output file is situated.  
    public outStorageName: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// The page wide fit on worksheet.  
    public pageWideFitOnPerSheet: boolean;
    /// The page tall fit on worksheet.  
    public pageTallFitOnPerSheet: boolean;
      
    public onePagePerSheet: boolean;
      
    public onlyAutofitTable: boolean;
    /// Use Custom fonts.  
    public fontsLocation: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorkbookRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isAutoFit", this.isAutoFit);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "onlySaveTable", this.onlySaveTable);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outPath", this.outPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outStorageName", this.outStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pageWideFitOnPerSheet", this.pageWideFitOnPerSheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pageTallFitOnPerSheet", this.pageTallFitOnPerSheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "onePagePerSheet", this.onePagePerSheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "onlyAutofitTable", this.onlyAutofitTable);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Convert the workbook from the requested content into files in different formats.   
export class PutConvertWorkbookRequest  {
    /// File to upload  
    public file: any;
    /// The format to convert(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers).  
    public format: string;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Path to save the result. If it's a single file, the `outPath` should encompass both the filename and extension. In the case of multiple files, the `outPath` should only include the folder.  
    public outPath: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The format of the input file stream.   
    public streamFormat: string;
    /// The regional settings for workbook.  
    public region: string;
    /// The page wide fit on worksheet.  
    public pageWideFitOnPerSheet: boolean;
    /// The page tall fit on worksheet.  
    public pageTallFitOnPerSheet: boolean;
      
    public sheetName: string;
      
    public pageIndex: number;
      
    public onePagePerSheet: boolean;
      
    public autoRowsFit: boolean;
      
    public autoColumnsFit: boolean;
    /// Use Custom fonts.  
    public fontsLocation: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutConvertWorkbookRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/convert";
        const queryParameters: any = {};
        const formParams: any = {};
        /// The format to convert(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers). 
        // verify required parameter 'format' is not null or undefined
        if (this.format === null || this.format === undefined) {
            throw new Error('Required parameter "format" was null or undefined when calling PutConvertWorkbook.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outPath", this.outPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "streamFormat", this.streamFormat);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pageWideFitOnPerSheet", this.pageWideFitOnPerSheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pageTallFitOnPerSheet", this.pageTallFitOnPerSheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sheetName", this.sheetName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pageIndex", this.pageIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "onePagePerSheet", this.onePagePerSheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "autoRowsFit", this.autoRowsFit);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "autoColumnsFit", this.autoColumnsFit);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Save an Excel file in various formats.   
export class PostWorkbookSaveAsRequest  {
    /// The workbook name.  
    public name: string;
    /// newfilename to save the result.The `newfilename` should encompass both the filename and extension.  
    public newfilename: string;
      
    public saveOptions: SaveOptions;
    /// Indicates if Autofit rows in workbook.  
    public isAutoFitRows: boolean;
    /// Indicates if Autofit columns in workbook.  
    public isAutoFitColumns: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// The storage name where the output file is situated.  
    public outStorageName: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// The page wide fit on worksheet.  
    public pageWideFitOnPerSheet: boolean;
    /// The page tall fit on worksheet.  
    public pageTallFitOnPerSheet: boolean;
      
    public onePagePerSheet: boolean;
    /// Use Custom fonts.  
    public fontsLocation: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookSaveAsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/SaveAs".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        /// newfilename to save the result.The `newfilename` should encompass both the filename and extension. 
        // verify required parameter 'newfilename' is not null or undefined
        if (this.newfilename === null || this.newfilename === undefined) {
            throw new Error('Required parameter "newfilename" was null or undefined when calling PostWorkbookSaveAs.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "newfilename", this.newfilename);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isAutoFitRows", this.isAutoFitRows);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isAutoFitColumns", this.isAutoFitColumns);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outStorageName", this.outStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pageWideFitOnPerSheet", this.pageWideFitOnPerSheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pageTallFitOnPerSheet", this.pageTallFitOnPerSheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "onePagePerSheet", this.onePagePerSheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.saveOptions == null) ? null :   ObjectSerializer.serialize( this.saveOptions,this.saveOptions.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Convert Excel file to PDF files.   
export class PostConvertWorkbookToPDFRequest  {
    /// File to upload  
    public file: any;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// Use Custom fonts.  
    public fontsLocation: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostConvertWorkbookToPDFRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/convert/pdf";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Convert Excel file to PNG files.   
export class PostConvertWorkbookToPNGRequest  {
    /// File to upload  
    public file: any;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostConvertWorkbookToPNGRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/convert/png";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Convert Excel file to Docx files.   
export class PostConvertWorkbookToDocxRequest  {
    /// File to upload  
    public file: any;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// Use Custom fonts.  
    public fontsLocation: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostConvertWorkbookToDocxRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/convert/docx";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Convert Excel file to Pptx files.   
export class PostConvertWorkbookToPptxRequest  {
    /// File to upload  
    public file: any;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// Use Custom fonts.  
    public fontsLocation: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostConvertWorkbookToPptxRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/convert/pptx";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Convert Excel file to HTML files.   
export class PostConvertWorkbookToHtmlRequest  {
    /// File to upload  
    public file: any;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// Use Custom fonts.  
    public fontsLocation: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostConvertWorkbookToHtmlRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/convert/html";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Convert Excel file to Markdown files.   
export class PostConvertWorkbookToMarkdownRequest  {
    /// File to upload  
    public file: any;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// Use Custom fonts.  
    public fontsLocation: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostConvertWorkbookToMarkdownRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/convert/markdown";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Convert Excel file to Json files.   
export class PostConvertWorkbookToJsonRequest  {
    /// File to upload  
    public file: any;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// Use Custom fonts.  
    public fontsLocation: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostConvertWorkbookToJsonRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/convert/json";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Convert Excel file to SQL Script files.   
export class PostConvertWorkbookToSQLRequest  {
    /// File to upload  
    public file: any;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostConvertWorkbookToSQLRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/convert/sql";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Convert Excel file to Csv files.   
export class PostConvertWorkbookToCSVRequest  {
    /// File to upload  
    public file: any;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostConvertWorkbookToCSVRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/convert/csv";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
   
export class PostConvertWorksheetToImageRequest  {
      
    public convertWorksheetOptions: ConvertWorksheetOptions;
    /// Use Custom fonts.  
    public fontsLocation: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostConvertWorksheetToImageRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/convertWorksheetToImage";
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.convertWorksheetOptions == null) ? null :   ObjectSerializer.serialize( this.convertWorksheetOptions,this.convertWorksheetOptions.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostConvertWorkbookRequest  {
      
    public convertWorkbookOptions: ConvertWorkbookOptions;
    /// Use Custom fonts.  
    public fontsLocation: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostConvertWorkbookRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/convertWorkbook";
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.convertWorkbookOptions == null) ? null :   ObjectSerializer.serialize( this.convertWorkbookOptions,this.convertWorkbookOptions.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Export Excel internal elements or the workbook itself to various format files.   
export class CheckWrokbookExternalReferenceRequest  {
      
    public checkExternalReferenceOptions: CheckExternalReferenceOptions;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< CheckWrokbookExternalReferenceRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/checkexternalreference";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.checkExternalReferenceOptions == null) ? null :   ObjectSerializer.serialize( this.checkExternalReferenceOptions,this.checkExternalReferenceOptions.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class CheckWorkbookFormulaErrorsRequest  {
      
    public formulaErrorOptions: CheckFormulaErrorOptions;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< CheckWorkbookFormulaErrorsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/checkformulaerrors";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.formulaErrorOptions == null) ? null :   ObjectSerializer.serialize( this.formulaErrorOptions,this.formulaErrorOptions.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Export Excel internal elements or the workbook itself to various format files.   
export class PostExportRequest  {
    /// File to upload  
    public file: any;
    /// Exported object type:workbook/worksheet/chart/comment/picture/shape/listobject/oleobject.  
    public objectType: string;
    /// The conversion format(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers).  
    public format: string;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// Use Custom fonts.  
    public fontsLocation: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostExportRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/export";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "objectType", this.objectType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Export XML data from an Excel file.
/// When there are XML Maps in an Excel file, export XML data. When there is no XML map in the Excel file, convert the Excel file to an XML file.   
export class PostWorkbookExportXMLRequest  {
    /// The file name.  
    public name: string;
    /// The password needed to open an Excel file.  
    public password: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// Path to save the result. If it's a single file, the `outPath` should encompass both the filename and extension. In the case of multiple files, the `outPath` should only include the folder.  
    public outPath: string;
    /// The storage name where the output file is situated.  
    public outStorageName: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookExportXMLRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/exportxml".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outPath", this.outPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outStorageName", this.outStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Import a JSON data file into the workbook. The JSON data file can either be a cloud file or data from an HTTP URI.   
export class PostWorkbookImportJsonRequest  {
    /// The file name.  
    public name: string;
    /// Import Json request.  
    public importJsonRequest: ImportJsonRequest;
    /// The password needed to open an Excel file.  
    public password: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// Path to save the result. If it's a single file, the `outPath` should encompass both the filename and extension. In the case of multiple files, the `outPath` should only include the folder.  
    public outPath: string;
    /// The storage name where the output file is situated.  
    public outStorageName: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookImportJsonRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/importjson".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outPath", this.outPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outStorageName", this.outStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.importJsonRequest == null) ? null :   ObjectSerializer.serialize( this.importJsonRequest,this.importJsonRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Import an XML data file into an Excel file. The XML data file can either be a cloud file or data from an HTTP URI.   
export class PostWorkbookImportXMLRequest  {
    /// The file name.  
    public name: string;
    /// Import XML request.  
    public importXMLRequest: ImportXMLRequest;
    /// The password needed to open an Excel file.  
    public password: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// Path to save the result. If it's a single file, the `outPath` should encompass both the filename and extension. In the case of multiple files, the `outPath` should only include the folder.  
    public outPath: string;
    /// The storage name where the output file is situated.  
    public outStorageName: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookImportXMLRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/importxml".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outPath", this.outPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outStorageName", this.outStorageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.importXMLRequest == null) ? null :   ObjectSerializer.serialize( this.importXMLRequest,this.importXMLRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Import data into the Excel file.   
export class PostImportDataRequest  {
    /// The file name.  
    public name: string;
    /// Import option. They are include of ImportCSVDataOption, ImportBatchDataOption, ImportPictureOption, ImportStringArrayOption, Import2DimensionStringArrayOption, and so on.    
    public importOption: ImportOption;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// The regional settings for workbook.  
    public region: string;
    /// Use Custom fonts.  
    public fontsLocation: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostImportDataRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/importdata".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.importOption == null) ? null :   ObjectSerializer.serialize( this.importOption,this.importOption.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Data cleaning of spreadsheet files is a data management process used to identify, correct, and remove errors, incompleteness, duplicates, or inaccuracies in tables and ranges.   
export class PostWorkbookDataCleansingRequest  {
    /// The file name.  
    public name: string;
    /// data cleansing content.  
    public dataCleansing: DataCleansing;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// The file password.   
    public password: string;
    /// The regional settings for workbook.  
    public region: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookDataCleansingRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/datacleansing".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.dataCleansing == null) ? null :   ObjectSerializer.serialize( this.dataCleansing,this.dataCleansing.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Data cleansing of spreadsheet files is a data management process used to identify, correct, and remove errors, incompleteness, duplicates, or inaccuracies in tables and ranges.   
export class PostDataCleansingRequest  {
      
    public dataCleansingRequest: DataCleansingRequest;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostDataCleansingRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/datacleansing";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.dataCleansingRequest == null) ? null :   ObjectSerializer.serialize( this.dataCleansingRequest,this.dataCleansingRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Data deduplication of spreadsheet files is mainly used to eliminate duplicate data in tables and ranges.   
export class PostWorkbookDataDeduplicationRequest  {
      
    public name: string;
      
    public deduplicationRegion: DeduplicationRegion;
      
    public folder: string;
      
    public storageName: string;
      
    public password: string;
      
    public region: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookDataDeduplicationRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/datadeduplication".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.deduplicationRegion == null) ? null :   ObjectSerializer.serialize( this.deduplicationRegion,this.deduplicationRegion.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Data deduplication of spreadsheet files is mainly used to eliminate duplicate data in tables and ranges.   
export class PostDataDeduplicationRequest  {
      
    public dataDeduplicationRequest: DataDeduplicationRequest;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostDataDeduplicationRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/datadeduplication";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.dataDeduplicationRequest == null) ? null :   ObjectSerializer.serialize( this.dataDeduplicationRequest,this.dataDeduplicationRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Data filling for spreadsheet files is primarily used to fill empty data in tables and ranges.   
export class PostWorkbookDataFillRequest  {
      
    public name: string;
      
    public dataFill: DataFill;
      
    public folder: string;
      
    public storageName: string;
      
    public password: string;
      
    public region: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookDataFillRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/datafill".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.dataFill == null) ? null :   ObjectSerializer.serialize( this.dataFill,this.dataFill.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Data filling for spreadsheet files is primarily used to fill empty data in tables and ranges.   
export class PostDataFillRequest  {
      
    public dataFillRequest: DataFillRequest;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostDataFillRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/datafill";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.dataFillRequest == null) ? null :   ObjectSerializer.serialize( this.dataFillRequest,this.dataFillRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Deleting incomplete rows of spreadsheet files is mainly used to eliminate incomplete rows in tables and ranges.   
export class PostDeleteIncompleteRowsRequest  {
      
    public deleteIncompleteRowsRequest: DeleteIncompleteRowsRequest;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostDeleteIncompleteRowsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/deleteincompleterows";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.deleteIncompleteRowsRequest == null) ? null :   ObjectSerializer.serialize( this.deleteIncompleteRowsRequest,this.deleteIncompleteRowsRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Transform spreadsheet data is mainly used to pivot columns, unpivot columns.   
export class PostDataTransformationRequest  {
      
    public dataTransformationRequest: DataTransformationRequest;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostDataTransformationRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/datatransformation";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.dataTransformationRequest == null) ? null :   ObjectSerializer.serialize( this.dataTransformationRequest,this.dataTransformationRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve descriptions of hyperlinks in the worksheet.   
export class GetWorksheetHyperlinksRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetHyperlinksRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/hyperlinks".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve hyperlink description by index in the worksheet.   
export class GetWorksheetHyperlinkRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The hyperlink's index.  
    public hyperlinkIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetHyperlinkRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/hyperlinks/{hyperlinkIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "hyperlinkIndex" + "}", String(this.hyperlinkIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete hyperlink by index in the worksheet.   
export class DeleteWorksheetHyperlinkRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The hyperlink's index.  
    public hyperlinkIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetHyperlinkRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/hyperlinks/{hyperlinkIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "hyperlinkIndex" + "}", String(this.hyperlinkIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update hyperlink by index in the worksheet.   
export class PostWorksheetHyperlinkRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The hyperlink's index.  
    public hyperlinkIndex: number;
    /// Hyperlink object  
    public hyperlink: Hyperlink;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetHyperlinkRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/hyperlinks/{hyperlinkIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "hyperlinkIndex" + "}", String(this.hyperlinkIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.hyperlink == null) ? null :   ObjectSerializer.serialize( this.hyperlink,this.hyperlink.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add hyperlink in the worksheet.   
export class PutWorksheetHyperlinkRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// First row of the hyperlink range.  
    public firstRow: number;
    /// First column of the hyperlink range.  
    public firstColumn: number;
    /// Number of rows in this hyperlink range.  
    public totalRows: number;
    /// Number of columns of this hyperlink range.  
    public totalColumns: number;
    /// Address of the hyperlink.  
    public address: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetHyperlinkRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/hyperlinks".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// First row of the hyperlink range. 
        // verify required parameter 'firstRow' is not null or undefined
        if (this.firstRow === null || this.firstRow === undefined) {
            throw new Error('Required parameter "firstRow" was null or undefined when calling PutWorksheetHyperlink.');
        }
        /// First column of the hyperlink range. 
        // verify required parameter 'firstColumn' is not null or undefined
        if (this.firstColumn === null || this.firstColumn === undefined) {
            throw new Error('Required parameter "firstColumn" was null or undefined when calling PutWorksheetHyperlink.');
        }
        /// Number of rows in this hyperlink range. 
        // verify required parameter 'totalRows' is not null or undefined
        if (this.totalRows === null || this.totalRows === undefined) {
            throw new Error('Required parameter "totalRows" was null or undefined when calling PutWorksheetHyperlink.');
        }
        /// Number of columns of this hyperlink range. 
        // verify required parameter 'totalColumns' is not null or undefined
        if (this.totalColumns === null || this.totalColumns === undefined) {
            throw new Error('Required parameter "totalColumns" was null or undefined when calling PutWorksheetHyperlink.');
        }
        /// Address of the hyperlink. 
        // verify required parameter 'address' is not null or undefined
        if (this.address === null || this.address === undefined) {
            throw new Error('Required parameter "address" was null or undefined when calling PutWorksheetHyperlink.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "firstRow", this.firstRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "firstColumn", this.firstColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalRows", this.totalRows);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "totalColumns", this.totalColumns);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "address", this.address);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete all hyperlinks in the worksheet.   
export class DeleteWorksheetHyperlinksRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetHyperlinksRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/hyperlinks".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Assemble data files with template files to generate files in various formats.   
export class PostAssembleRequest  {
    /// File to upload  
    public file: any;
      
    public datasource: string;
    /// The format to convert(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers)  
    public outFormat: string;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostAssembleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/assemble";
        const queryParameters: any = {};
        const formParams: any = {};
         
        // verify required parameter 'datasource' is not null or undefined
        if (this.datasource === null || this.datasource === undefined) {
            throw new Error('Required parameter "datasource" was null or undefined when calling PostAssemble.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "datasource", this.datasource);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outFormat", this.outFormat);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Compress files and generate target files in various formats, supported file formats are include Xls, Xlsx, Xlsm, Xlsb, Ods and more.   
export class PostCompressRequest  {
    /// File to upload  
    public file: any;
    /// Compress level. The compression ratio 1-100.  
    public compressLevel: number;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostCompressRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/compress";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "compressLevel", this.compressLevel);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Merge cells in the worksheet.   
export class PostMergeRequest  {
    /// File to upload  
    public file: any;
    /// The output data file format.(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers)  
    public outFormat: string;
    /// Merge all workbooks into a sheet.  
    public mergeToOneSheet: boolean;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostMergeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/merge";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outFormat", this.outFormat);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "mergeToOneSheet", this.mergeToOneSheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Split Excel spreadsheet files based on worksheets and create output files in various formats.   
export class PostSplitRequest  {
    /// File to upload  
    public file: any;
    /// The output data file format.(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers)  
    public outFormat: string;
    /// The password needed to open an Excel file.  
    public password: string;
    /// sheet index  
    public from: number;
    /// sheet index  
    public to: number;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostSplitRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/split";
        const queryParameters: any = {};
        const formParams: any = {};
        /// The output data file format.(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers) 
        // verify required parameter 'outFormat' is not null or undefined
        if (this.outFormat === null || this.outFormat === undefined) {
            throw new Error('Required parameter "outFormat" was null or undefined when calling PostSplit.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outFormat", this.outFormat);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "from", this.from);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "to", this.to);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Search for specified text within Excel files.   
export class PostSearchRequest  {
    /// File to upload  
    public file: any;
    /// Find content  
    public text: string;
    /// The password needed to open an Excel file.  
    public password: string;
    /// The worksheet name. Locate the specified text content in the worksheet.  
    public sheetname: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostSearchRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/search";
        const queryParameters: any = {};
        const formParams: any = {};
        /// Find content 
        // verify required parameter 'text' is not null or undefined
        if (this.text === null || this.text === undefined) {
            throw new Error('Required parameter "text" was null or undefined when calling PostSearch.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "text", this.text);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sheetname", this.sheetname);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Replace specified text with new text in Excel files.   
export class PostReplaceRequest  {
    /// File to upload  
    public file: any;
    /// Find content  
    public text: string;
    /// Replace content  
    public newtext: string;
    /// The password needed to open an Excel file.  
    public password: string;
    /// The worksheet name. Locate the specified text content in the worksheet.  
    public sheetname: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostReplaceRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/replace";
        const queryParameters: any = {};
        const formParams: any = {};
        /// Find content 
        // verify required parameter 'text' is not null or undefined
        if (this.text === null || this.text === undefined) {
            throw new Error('Required parameter "text" was null or undefined when calling PostReplace.');
        }
        /// Replace content 
        // verify required parameter 'newtext' is not null or undefined
        if (this.newtext === null || this.newtext === undefined) {
            throw new Error('Required parameter "newtext" was null or undefined when calling PostReplace.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "text", this.text);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "newtext", this.newtext);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sheetname", this.sheetname);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Import data into an Excel file and generate output files in various formats.   
export class PostImportRequest  {
    /// File to upload  
    public file: any;
    /// The output data file format.(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers)  
    public outFormat: string;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostImportRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/import";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outFormat", this.outFormat);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Add Text Watermark to Excel files and generate output files in various formats.   
export class PostWatermarkRequest  {
    /// File to upload  
    public file: any;
    /// background text.  
    public text: string;
    /// e.g. #1032ff  
    public color: string;
    /// The output data file format.(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers)  
    public outFormat: string;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWatermarkRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/watermark";
        const queryParameters: any = {};
        const formParams: any = {};
        /// background text. 
        // verify required parameter 'text' is not null or undefined
        if (this.text === null || this.text === undefined) {
            throw new Error('Required parameter "text" was null or undefined when calling PostWatermark.');
        }
        /// e.g. #1032ff 
        // verify required parameter 'color' is not null or undefined
        if (this.color === null || this.color === undefined) {
            throw new Error('Required parameter "color" was null or undefined when calling PostWatermark.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "text", this.text);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "color", this.color);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outFormat", this.outFormat);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Clear internal elements in Excel files and generate output files in various formats.   
export class PostClearObjectsRequest  {
    /// File to upload  
    public file: any;
    /// chart/comment/picture/shape/listobject/hyperlink/oleobject/pivottable/validation/Background  
    public objecttype: string;
    /// The worksheet name, specify the scope of the deletion.  
    public sheetname: string;
    /// The output data file format.(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers)  
    public outFormat: string;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostClearObjectsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/clearobjects";
        const queryParameters: any = {};
        const formParams: any = {};
        /// chart/comment/picture/shape/listobject/hyperlink/oleobject/pivottable/validation/Background 
        // verify required parameter 'objecttype' is not null or undefined
        if (this.objecttype === null || this.objecttype === undefined) {
            throw new Error('Required parameter "objecttype" was null or undefined when calling PostClearObjects.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "objecttype", this.objecttype);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sheetname", this.sheetname);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outFormat", this.outFormat);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Reverse rows or columns in Excel files and create output files in various formats.   
export class PostReverseRequest  {
    /// File to upload  
    public file: any;
    /// rows/cols/both  
    public rotateType: string;
    /// The output data file format.(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers)  
    public outFormat: string;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostReverseRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/reverse";
        const queryParameters: any = {};
        const formParams: any = {};
        /// rows/cols/both 
        // verify required parameter 'rotateType' is not null or undefined
        if (this.rotateType === null || this.rotateType === undefined) {
            throw new Error('Required parameter "rotateType" was null or undefined when calling PostReverse.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "rotateType", this.rotateType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outFormat", this.outFormat);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Repair abnormal files and generate files in various formats.   
export class PostRepairRequest  {
    /// File to upload  
    public file: any;
    /// The output data file format.(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers)  
    public outFormat: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostRepairRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/repair";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outFormat", this.outFormat);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Rotate rows, columns, or other objects in Excel files and save them in various formats.   
export class PostRotateRequest  {
    /// File to upload  
    public file: any;
    /// 270/90/row/col/row2col  
    public rotateType: string;
    /// The output data file format.(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers)  
    public outFormat: string;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The regional settings for workbook.  
    public region: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostRotateRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/rotate";
        const queryParameters: any = {};
        const formParams: any = {};
        /// 270/90/row/col/row2col 
        // verify required parameter 'rotateType' is not null or undefined
        if (this.rotateType === null || this.rotateType === undefined) {
            throw new Error('Required parameter "rotateType" was null or undefined when calling PostRotate.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "rotateType", this.rotateType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outFormat", this.outFormat);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Update document properties in Excel file, and save them is various formats.   
export class PostMetadataRequest  {
    /// File to upload  
    public file: any;
    /// document properties  
    public cellsDocuments: Array<CellsDocumentProperty>;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// The output data file format.(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers)  
    public outFormat: string;
    /// The regional settings for workbook.  
    public region: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostMetadataRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/metadata/update";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outFormat", this.outFormat);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "region", this.region);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        const bodyParameter = (this.cellsDocuments == null) ? null :  JSON.stringify(this.cellsDocuments);
        formParams["cellsDocuments"] = bodyParameter;    
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Get cells document properties.   
export class GetMetadataRequest  {
    /// File to upload  
    public file: any;
    /// Cells document property name.  
    public type: string;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetMetadataRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/metadata/get";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "type", this.type);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Delete cells document properties in Excel file, and save them is various formats.   
export class DeleteMetadataRequest  {
    /// File to upload  
    public file: any;
    /// Cells document property name.  
    public type: string;
    /// The output data file format.(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers)  
    public outFormat: string;
    /// The password needed to open an Excel file.  
    public password: string;
    /// Whether check restriction of excel file when user modify cells related objects.  
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteMetadataRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/metadata/delete";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "type", this.type);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outFormat", this.outFormat);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Retrieve descriptions of ListObjects in the worksheet.   
export class GetWorksheetListObjectsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetListObjectsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/listobjects".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve list object description by index in the worksheet.   
export class GetWorksheetListObjectRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// list object index.  
    public listobjectindex: number;
      
    public format: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetListObjectRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/listobjects/{listobjectindex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "listobjectindex" + "}", String(this.listobjectindex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add a ListObject in the worksheet.   
export class PutWorksheetListObjectRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The start row of the list range.  
    public startRow: number;
    /// The start column of the list range.  
    public startColumn: number;
    /// The start row of the list range.  
    public endRow: number;
    /// The start column of the list range.  
    public endColumn: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// Indicate whether the range has headers.  
    public hasHeaders: boolean;
    /// Indicate whether display name.  
    public displayName: string;
    /// Indicate whether show totals.  
    public showTotals: boolean;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetListObjectRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/listobjects".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startRow", this.startRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startColumn", this.startColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endRow", this.endRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endColumn", this.endColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "hasHeaders", this.hasHeaders);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "displayName", this.displayName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "showTotals", this.showTotals);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete ListObjects in the worksheet.   
export class DeleteWorksheetListObjectsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetListObjectsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/listobjects".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete list object by index in the worksheet.   
export class DeleteWorksheetListObjectRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// List object index.  
    public listObjectIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetListObjectRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/listobjects/{listObjectIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "listObjectIndex" + "}", String(this.listObjectIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update list object by index in the worksheet.   
export class PostWorksheetListObjectRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// list Object index  
    public listObjectIndex: number;
    /// listObject dto in request body.  
    public listObject: ListObject;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetListObjectRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/listobjects/{listObjectIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "listObjectIndex" + "}", String(this.listObjectIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.listObject == null) ? null :   ObjectSerializer.serialize( this.listObject,this.listObject.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Convert list object to range in the worksheet.   
export class PostWorksheetListObjectConvertToRangeRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// List object index.  
    public listObjectIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetListObjectConvertToRangeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/listobjects/{listObjectIndex}/ConvertToRange".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "listObjectIndex" + "}", String(this.listObjectIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Create a pivot table with a list object in the worksheet.   
export class PostWorksheetListObjectSummarizeWithPivotTableRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The list object index.  
    public listObjectIndex: number;
    /// The target worksheet name.  
    public destsheetName: string;
    /// Create pivot table request.  
    public createPivotTableRequest: CreatePivotTableRequest;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetListObjectSummarizeWithPivotTableRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/listobjects/{listObjectIndex}/SummarizeWithPivotTable".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "listObjectIndex" + "}", String(this.listObjectIndex));
        const queryParameters: any = {};
        /// The target worksheet name. 
        // verify required parameter 'destsheetName' is not null or undefined
        if (this.destsheetName === null || this.destsheetName === undefined) {
            throw new Error('Required parameter "destsheetName" was null or undefined when calling PostWorksheetListObjectSummarizeWithPivotTable.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destsheetName", this.destsheetName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.createPivotTableRequest == null) ? null :   ObjectSerializer.serialize( this.createPivotTableRequest,this.createPivotTableRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Sort list object in the worksheet.   
export class PostWorksheetListObjectSortTableRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The list object index.  
    public listObjectIndex: number;
    /// Represents sort order for the data range.  
    public dataSorter: DataSorter;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetListObjectSortTableRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/listobjects/{listObjectIndex}/sort".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "listObjectIndex" + "}", String(this.listObjectIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.dataSorter == null) ? null :   ObjectSerializer.serialize( this.dataSorter,this.dataSorter.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Remove duplicates in list object.   
export class PostWorksheetListObjectRemoveDuplicatesRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The list object index.  
    public listObjectIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetListObjectRemoveDuplicatesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/listobjects/{listObjectIndex}/RemoveDuplicates".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "listObjectIndex" + "}", String(this.listObjectIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Insert slicer for list object.   
export class PostWorksheetListObjectInsertSlicerRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// List object index.  
    public listObjectIndex: number;
    /// The index of ListColumn in ListObject.ListColumns   
    public columnIndex: number;
    /// The cell in the upper-left corner of the Slicer range.   
    public destCellName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetListObjectInsertSlicerRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/listobjects/{listObjectIndex}/InsertSlicer".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "listObjectIndex" + "}", String(this.listObjectIndex));
        const queryParameters: any = {};
        /// The index of ListColumn in ListObject.ListColumns  
        // verify required parameter 'columnIndex' is not null or undefined
        if (this.columnIndex === null || this.columnIndex === undefined) {
            throw new Error('Required parameter "columnIndex" was null or undefined when calling PostWorksheetListObjectInsertSlicer.');
        }
        /// The cell in the upper-left corner of the Slicer range.  
        // verify required parameter 'destCellName' is not null or undefined
        if (this.destCellName === null || this.destCellName === undefined) {
            throw new Error('Required parameter "destCellName" was null or undefined when calling PostWorksheetListObjectInsertSlicer.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "columnIndex", this.columnIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destCellName", this.destCellName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update list column in list object.   
export class PostWorksheetListColumnRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The list object index.  
    public listObjectIndex: number;
    /// Represents table column index.  
    public columnIndex: number;
    /// Represents table column description.  
    public listColumn: ListColumn;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetListColumnRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/listobjects/{listObjectIndex}/listcolumns/{columnIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "listObjectIndex" + "}", String(this.listObjectIndex)).replace("{" + "columnIndex" + "}", String(this.columnIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.listColumn == null) ? null :   ObjectSerializer.serialize( this.listColumn,this.listColumn.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update total of list columns in the table.   
export class PostWorksheetListColumnsTotalRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// List object index.  
    public listObjectIndex: number;
    /// Represents table column description.  
    public tableTotalRequests: Array<TableTotalRequest>;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetListColumnsTotalRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/listobjects/{listObjectIndex}/listcolumns/total".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "listObjectIndex" + "}", String(this.listObjectIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.tableTotalRequests == null) ? null :   ObjectSerializer.serialize( this.tableTotalRequests,this.tableTotalRequests.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve descriptions of OLE objects in the worksheet.   
export class GetWorksheetOleObjectsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetOleObjectsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/oleobjects".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve the OLE object in a specified format in the worksheet.   
export class GetWorksheetOleObjectRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The object number.  
    public objectNumber: number;
    /// Object conversion format(PNG/TIFF/JPEG/GIF/EMF/BMP).  
    public format: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetOleObjectRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/oleobjects/{objectNumber}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "objectNumber" + "}", String(this.objectNumber));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete all OLE objects in the worksheet.   
export class DeleteWorksheetOleObjectsRequest  {
    /// The file name.  
    public name: string;
    /// The worsheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetOleObjectsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/oleobjects".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete an OLE object in the worksheet.   
export class DeleteWorksheetOleObjectRequest  {
    /// The file name.  
    public name: string;
    /// The worsheet name.  
    public sheetName: string;
    /// Ole object index.  
    public oleObjectIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetOleObjectRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/oleobjects/{oleObjectIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "oleObjectIndex" + "}", String(this.oleObjectIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update an OLE object in worksheet.   
export class PostUpdateWorksheetOleObjectRequest  {
    /// The file name.  
    public name: string;
    /// The worsheet name.  
    public sheetName: string;
    /// Ole object index.  
    public oleObjectIndex: number;
    /// Ole Object description.  
    public ole: OleObject;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUpdateWorksheetOleObjectRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/oleobjects/{oleObjectIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "oleObjectIndex" + "}", String(this.oleObjectIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.ole == null) ? null :   ObjectSerializer.serialize( this.ole,this.ole.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add an OLE object in the worksheet.   
export class PutWorksheetOleObjectRequest  {
    /// The file name.  
    public name: string;
    /// The worsheet name.  
    public sheetName: string;
    /// Upper left row index  
    public upperLeftRow: number;
    /// Upper left column index  
    public upperLeftColumn: number;
    /// Height of oleObject, in unit of pixel  
    public height: number;
    /// Width of oleObject, in unit of pixel  
    public width: number;
    /// OLE filename path(full file name).  
    public oleFile: string;
    /// Image filename path(full file name).  
    public imageFile: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetOleObjectRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/oleobjects".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "upperLeftRow", this.upperLeftRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "upperLeftColumn", this.upperLeftColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "height", this.height);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "width", this.width);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "oleFile", this.oleFile);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "imageFile", this.imageFile);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve descriptions of vertical page breaks in the worksheet.   
export class GetVerticalPageBreaksRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetVerticalPageBreaksRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/verticalpagebreaks".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve descriptions of horizontal page breaks in the worksheet.   
export class GetHorizontalPageBreaksRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetHorizontalPageBreaksRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/horizontalpagebreaks".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve a vertical page break description in the worksheet.   
export class GetVerticalPageBreakRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The zero based index of the element.  
    public index: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetVerticalPageBreakRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/verticalpagebreaks/{index}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "index" + "}", String(this.index));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve a horizontal page break descripton in the worksheet.   
export class GetHorizontalPageBreakRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The zero based index of the element.  
    public index: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetHorizontalPageBreakRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/horizontalpagebreaks/{index}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "index" + "}", String(this.index));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add a vertical page break in the worksheet.   
export class PutVerticalPageBreakRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Cell name  
    public cellname: string;
    /// Column index, zero based.  
    public column: number;
    /// Row index, zero based.  
    public row: number;
    /// Start row index, zero based.  
    public startRow: number;
    /// End row index, zero based.  
    public endRow: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutVerticalPageBreakRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/verticalpagebreaks".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellname", this.cellname);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "column", this.column);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "row", this.row);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startRow", this.startRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endRow", this.endRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add a horizontal page breaks in the worksheet.   
export class PutHorizontalPageBreakRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Cell name  
    public cellname: string;
    /// Row index, zero based.  
    public row: number;
    /// Column index, zero based.  
    public column: number;
    /// Start column index, zero based.  
    public startColumn: number;
    /// End column index, zero based.  
    public endColumn: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutHorizontalPageBreakRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/horizontalpagebreaks".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellname", this.cellname);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "row", this.row);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "column", this.column);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startColumn", this.startColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endColumn", this.endColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete vertical page breaks in the worksheet.   
export class DeleteVerticalPageBreaksRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Column index, zero based.  
    public column: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteVerticalPageBreaksRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/verticalpagebreaks".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "column", this.column);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete horizontal page breaks in the worksheet.   
export class DeleteHorizontalPageBreaksRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Row index, zero based.  
    public row: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteHorizontalPageBreaksRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/horizontalpagebreaks".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "row", this.row);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete a vertical page break in the worksheet.   
export class DeleteVerticalPageBreakRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Removes the vertical page break element at a specified name. Element index, zero based.  
    public index: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteVerticalPageBreakRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/verticalpagebreaks/{index}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "index" + "}", String(this.index));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete a horizontal page break in the worksheet.   
export class DeleteHorizontalPageBreakRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Removes the horizontal page break element at a specified name. Element index, zero based.  
    public index: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteHorizontalPageBreakRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/horizontalpagebreaks/{index}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "index" + "}", String(this.index));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve page setup description in the worksheet.   
export class GetPageSetupRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetPageSetupRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pagesetup".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update page setup in the worksheet.   
export class PostPageSetupRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// PageSetup Page Setup description.  
    public pageSetup: PageSetup;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostPageSetupRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pagesetup".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.pageSetup == null) ? null :   ObjectSerializer.serialize( this.pageSetup,this.pageSetup.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Clear header and footer in the worksheet.   
export class DeleteHeaderFooterRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteHeaderFooterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pagesetup/clearheaderfooter".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve page header description in the worksheet.   
export class GetHeaderRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetHeaderRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pagesetup/header".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update page header in the worksheet.   
export class PostHeaderRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// 0:Left Section. 1:Center Section 2:Right Section  
    public section: number;
    /// Header format script.  
    public script: string;
    /// Is first page(true/false).  
    public isFirstPage: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostHeaderRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pagesetup/header".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// 0:Left Section. 1:Center Section 2:Right Section 
        // verify required parameter 'section' is not null or undefined
        if (this.section === null || this.section === undefined) {
            throw new Error('Required parameter "section" was null or undefined when calling PostHeader.');
        }
        /// Header format script. 
        // verify required parameter 'script' is not null or undefined
        if (this.script === null || this.script === undefined) {
            throw new Error('Required parameter "script" was null or undefined when calling PostHeader.');
        }
        /// Is first page(true/false). 
        // verify required parameter 'isFirstPage' is not null or undefined
        if (this.isFirstPage === null || this.isFirstPage === undefined) {
            throw new Error('Required parameter "isFirstPage" was null or undefined when calling PostHeader.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "section", this.section);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "script", this.script);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isFirstPage", this.isFirstPage);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve page footer description in the worksheet.   
export class GetFooterRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetFooterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pagesetup/footer".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update page footer in the worksheet.   
export class PostFooterRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// 0:Left Section. 1:Center Section 2:Right Section  
    public section: number;
    /// Header format script.  
    public script: string;
    /// Is first page(true/false).  
    public isFirstPage: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostFooterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pagesetup/footer".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// 0:Left Section. 1:Center Section 2:Right Section 
        // verify required parameter 'section' is not null or undefined
        if (this.section === null || this.section === undefined) {
            throw new Error('Required parameter "section" was null or undefined when calling PostFooter.');
        }
        /// Header format script. 
        // verify required parameter 'script' is not null or undefined
        if (this.script === null || this.script === undefined) {
            throw new Error('Required parameter "script" was null or undefined when calling PostFooter.');
        }
        /// Is first page(true/false). 
        // verify required parameter 'isFirstPage' is not null or undefined
        if (this.isFirstPage === null || this.isFirstPage === undefined) {
            throw new Error('Required parameter "isFirstPage" was null or undefined when calling PostFooter.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "section", this.section);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "script", this.script);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isFirstPage", this.isFirstPage);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Set the scale at which the page will fit wide when printed on the sheet.   
export class PostFitWideToPagesRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostFitWideToPagesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pagesetup/fitwidetopages".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Set the scale at which the page will fit tall when printed on the sheet.   
export class PostFitTallToPagesRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostFitTallToPagesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pagesetup/fittalltopages".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve descriptions of pictures in the worksheet.   
export class GetWorksheetPicturesRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetPicturesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pictures".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve a picture by number in the worksheet.   
export class GetWorksheetPictureWithFormatRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The picture index.  
    public pictureNumber: number;
    /// Picture conversion format(PNG/TIFF/JPEG/GIF/EMF/BMP).  
    public format: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetPictureWithFormatRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pictures/{pictureNumber}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pictureNumber" + "}", String(this.pictureNumber));
        const queryParameters: any = {};
        /// Picture conversion format(PNG/TIFF/JPEG/GIF/EMF/BMP). 
        // verify required parameter 'format' is not null or undefined
        if (this.format === null || this.format === undefined) {
            throw new Error('Required parameter "format" was null or undefined when calling GetWorksheetPictureWithFormat.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add a new picture in the worksheet.   
export class PutWorksheetAddPictureRequest  {
    /// The file name.  
    public name: string;
    /// The worsheet name.  
    public sheetName: string;
    /// Pictute object  
    public picture: Picture;
    /// The image upper left row.  
    public upperLeftRow: number;
    /// The image upper left column.  
    public upperLeftColumn: number;
    /// The image low right row.  
    public lowerRightRow: number;
    /// The image low right column.  
    public lowerRightColumn: number;
    /// The picture path, if not provided the picture data is inspected in the request body.  
    public picturePath: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetAddPictureRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pictures".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "upperLeftRow", this.upperLeftRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "upperLeftColumn", this.upperLeftColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "lowerRightRow", this.lowerRightRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "lowerRightColumn", this.lowerRightColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "picturePath", this.picturePath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.picture == null) ? null :   ObjectSerializer.serialize( this.picture,this.picture.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// add new picture in the cells.   
export class AddPictureInCellRequest  {
      
    public name: string;
      
    public sheetName: string;
      
    public cellName: string;
      
    public picturePath: string;
      
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< AddPictureInCellRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pictures/addPictureInCell".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
         
        // verify required parameter 'cellName' is not null or undefined
        if (this.cellName === null || this.cellName === undefined) {
            throw new Error('Required parameter "cellName" was null or undefined when calling AddPictureInCell.');
        }
         
        // verify required parameter 'picturePath' is not null or undefined
        if (this.picturePath === null || this.picturePath === undefined) {
            throw new Error('Required parameter "picturePath" was null or undefined when calling AddPictureInCell.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellName", this.cellName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "picturePath", this.picturePath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update a picture by index in the worksheet.   
export class PostWorksheetPictureRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The picture's index.  
    public pictureIndex: number;
    /// Picture object description.  
    public picture: Picture;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetPictureRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pictures/{pictureIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pictureIndex" + "}", String(this.pictureIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.picture == null) ? null :   ObjectSerializer.serialize( this.picture,this.picture.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete a picture object by index in the worksheet.   
export class DeleteWorksheetPictureRequest  {
    /// The file name.  
    public name: string;
    /// The worsheet name.  
    public sheetName: string;
    /// Picture index.  
    public pictureIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetPictureRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pictures/{pictureIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pictureIndex" + "}", String(this.pictureIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete all pictures in the worksheet.   
export class DeleteWorksheetPicturesRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetPicturesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pictures".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve descriptions of pivottables  in the worksheet.   
export class GetWorksheetPivotTablesRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetPivotTablesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pivottables".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve PivotTable information by index in the worksheet.   
export class GetWorksheetPivotTableRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivottableIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetPivotTableRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pivottables/{pivottableIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivottableIndex" + "}", String(this.pivottableIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve descriptions of pivot fields in the PivotTable.   
export class GetPivotTableFieldRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The PivotTable index.  
    public pivotTableIndex: number;
    /// The pivot field index of PivotTable.  
    public pivotFieldIndex: number;
    /// The field area type(column/row).  
    public pivotFieldType: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetPivotTableFieldRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotField".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        /// The pivot field index of PivotTable. 
        // verify required parameter 'pivotFieldIndex' is not null or undefined
        if (this.pivotFieldIndex === null || this.pivotFieldIndex === undefined) {
            throw new Error('Required parameter "pivotFieldIndex" was null or undefined when calling GetPivotTableField.');
        }
        /// The field area type(column/row). 
        // verify required parameter 'pivotFieldType' is not null or undefined
        if (this.pivotFieldType === null || this.pivotFieldType === undefined) {
            throw new Error('Required parameter "pivotFieldType" was null or undefined when calling GetPivotTableField.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pivotFieldIndex", this.pivotFieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pivotFieldType", this.pivotFieldType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Gets PivotTable filters in worksheet.   
export class GetWorksheetPivotTableFiltersRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The PivotTable index.  
    public pivotTableIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetPivotTableFiltersRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotFilters".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve PivotTable filters in the worksheet.   
export class GetWorksheetPivotTableFilterRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The PivotTable index in the worksheet.  
    public pivotTableIndex: number;
    /// The pivot filter index of PivotTable.  
    public filterIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetPivotTableFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotFilters/{filterIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex)).replace("{" + "filterIndex" + "}", String(this.filterIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add a PivotTable in the worksheet.   
export class PutWorksheetPivotTableRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The data for the new PivotTable cache.  
    public sourceData: string;
    /// The cell in the upper-left corner of the destination range for the PivotTable report.  
    public destCellName: string;
    /// The name of the new PivotTable.  
    public tableName: string;
    /// Indicates whether using same data source when another existing PivotTable has used this data source. If the property is true, it will save memory.  
    public useSameSource: boolean;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetPivotTableRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pivottables".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sourceData", this.sourceData);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destCellName", this.destCellName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "tableName", this.tableName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "useSameSource", this.useSameSource);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add a pivot field in the PivotTable.   
export class PutPivotTableFieldRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The PivotTable index.  
    public pivotTableIndex: number;
    /// The fields area type.  
    public pivotFieldType: string;
    /// PivotTableFieldRequest The PivotTable field request.  
    public pivotTableFieldRequest: PivotTableFieldRequest;
    /// Whether the specific PivotTable calculate(true/false).  
    public needReCalculate: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutPivotTableFieldRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotField".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        /// The fields area type. 
        // verify required parameter 'pivotFieldType' is not null or undefined
        if (this.pivotFieldType === null || this.pivotFieldType === undefined) {
            throw new Error('Required parameter "pivotFieldType" was null or undefined when calling PutPivotTableField.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pivotFieldType", this.pivotFieldType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "needReCalculate", this.needReCalculate);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.pivotTableFieldRequest == null) ? null :   ObjectSerializer.serialize( this.pivotTableFieldRequest,this.pivotTableFieldRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add a pivot filter to the PivotTable.   
export class PutWorksheetPivotTableFilterRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// PivotFilter Pivot filter description.  
    public filter: PivotFilter;
    /// Whether the specific PivotTable calculate(true/false).  
    public needReCalculate: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetPivotTableFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotFilters".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "needReCalculate", this.needReCalculate);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.filter == null) ? null :   ObjectSerializer.serialize( this.filter,this.filter.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Hide a pivot field item in the PivotTable.   
export class PostPivotTableFieldHideItemRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The PivotTable index.  
    public pivotTableIndex: number;
    /// Represents PivotTable field type(Undefined/Row/Column/Page/Data).  
    public pivotFieldType: string;
    /// The pivot field index.  
    public fieldIndex: number;
    /// The index of the pivot item in the pivot field.  
    public itemIndex: number;
    /// Whether the specific PivotItem is hidden(true/false).  
    public isHide: boolean;
    /// Whether the specific PivotTable calculate(true/false).  
    public needReCalculate: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostPivotTableFieldHideItemRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotField/Hide".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        /// Represents PivotTable field type(Undefined/Row/Column/Page/Data). 
        // verify required parameter 'pivotFieldType' is not null or undefined
        if (this.pivotFieldType === null || this.pivotFieldType === undefined) {
            throw new Error('Required parameter "pivotFieldType" was null or undefined when calling PostPivotTableFieldHideItem.');
        }
        /// The pivot field index. 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling PostPivotTableFieldHideItem.');
        }
        /// The index of the pivot item in the pivot field. 
        // verify required parameter 'itemIndex' is not null or undefined
        if (this.itemIndex === null || this.itemIndex === undefined) {
            throw new Error('Required parameter "itemIndex" was null or undefined when calling PostPivotTableFieldHideItem.');
        }
        /// Whether the specific PivotItem is hidden(true/false). 
        // verify required parameter 'isHide' is not null or undefined
        if (this.isHide === null || this.isHide === undefined) {
            throw new Error('Required parameter "isHide" was null or undefined when calling PostPivotTableFieldHideItem.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pivotFieldType", this.pivotFieldType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "itemIndex", this.itemIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isHide", this.isHide);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "needReCalculate", this.needReCalculate);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Move a pivot field in the PivotTable.   
export class PostPivotTableFieldMoveToRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The PivotTable index.  
    public pivotTableIndex: number;
    /// The pivot field index.  
    public fieldIndex: number;
    /// The fields area type(Column/Row/Page/Data/Undefined).  
    public from: string;
    /// The fields area type(Column/Row/Page/Data/Undefined).  
    public to: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostPivotTableFieldMoveToRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotField/Move".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        /// The pivot field index. 
        // verify required parameter 'fieldIndex' is not null or undefined
        if (this.fieldIndex === null || this.fieldIndex === undefined) {
            throw new Error('Required parameter "fieldIndex" was null or undefined when calling PostPivotTableFieldMoveTo.');
        }
        /// The fields area type(Column/Row/Page/Data/Undefined). 
        // verify required parameter 'from' is not null or undefined
        if (this.from === null || this.from === undefined) {
            throw new Error('Required parameter "from" was null or undefined when calling PostPivotTableFieldMoveTo.');
        }
        /// The fields area type(Column/Row/Page/Data/Undefined). 
        // verify required parameter 'to' is not null or undefined
        if (this.to === null || this.to === undefined) {
            throw new Error('Required parameter "to" was null or undefined when calling PostPivotTableFieldMoveTo.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "fieldIndex", this.fieldIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "from", this.from);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "to", this.to);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update cell style in the PivotTable.   
export class PostPivotTableCellStyleRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The PivotTable index.  
    public pivotTableIndex: number;
    /// The column index of the cell.  
    public column: number;
    /// The row index of the cell.  
    public row: number;
    /// Style Style description in request body.  
    public style: Style;
    /// Whether the specific PivotTable calculate(true/false).  
    public needReCalculate: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostPivotTableCellStyleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/Format".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        /// The column index of the cell. 
        // verify required parameter 'column' is not null or undefined
        if (this.column === null || this.column === undefined) {
            throw new Error('Required parameter "column" was null or undefined when calling PostPivotTableCellStyle.');
        }
        /// The row index of the cell. 
        // verify required parameter 'row' is not null or undefined
        if (this.row === null || this.row === undefined) {
            throw new Error('Required parameter "row" was null or undefined when calling PostPivotTableCellStyle.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "column", this.column);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "row", this.row);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "needReCalculate", this.needReCalculate);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.style == null) ? null :   ObjectSerializer.serialize( this.style,this.style.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update style in the PivotTable.   
export class PostPivotTableStyleRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The PivotTable index.  
    public pivotTableIndex: number;
    /// StyleStyle description in request body.  
    public style: Style;
    /// Whether the specific PivotTable calculate(true/false).  
    public needReCalculate: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostPivotTableStyleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/FormatAll".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "needReCalculate", this.needReCalculate);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.style == null) ? null :   ObjectSerializer.serialize( this.style,this.style.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update pivot fields in the PivotTable.   
export class PostPivotTableUpdatePivotFieldsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The PivotTable index.  
    public pivotTableIndex: number;
    /// Represents PivotTable field type(Undefined/Row/Column/Page/Data).  
    public pivotFieldType: string;
    /// PivotFieldRepresents pivot field.  
    public pivotField: PivotField;
    /// Whether the specific PivotTable calculate(true/false).  
    public needReCalculate: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostPivotTableUpdatePivotFieldsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotFields".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        /// Represents PivotTable field type(Undefined/Row/Column/Page/Data). 
        // verify required parameter 'pivotFieldType' is not null or undefined
        if (this.pivotFieldType === null || this.pivotFieldType === undefined) {
            throw new Error('Required parameter "pivotFieldType" was null or undefined when calling PostPivotTableUpdatePivotFields.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pivotFieldType", this.pivotFieldType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "needReCalculate", this.needReCalculate);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.pivotField == null) ? null :   ObjectSerializer.serialize( this.pivotField,this.pivotField.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update pivot field in the PivotTable.   
export class PostPivotTableUpdatePivotFieldRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The PivotTable index.  
    public pivotTableIndex: number;
    /// The pivot field index.  
    public pivotFieldIndex: number;
    /// Represents PivotTable field type(Undefined/Row/Column/Page/Data).  
    public pivotFieldType: string;
    /// Represents pivot field.  
    public pivotField: PivotField;
    /// Whether the specific PivotTable calculate(true/false).  
    public needReCalculate: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostPivotTableUpdatePivotFieldRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotFields/{pivotFieldIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex)).replace("{" + "pivotFieldIndex" + "}", String(this.pivotFieldIndex));
        const queryParameters: any = {};
        /// Represents PivotTable field type(Undefined/Row/Column/Page/Data). 
        // verify required parameter 'pivotFieldType' is not null or undefined
        if (this.pivotFieldType === null || this.pivotFieldType === undefined) {
            throw new Error('Required parameter "pivotFieldType" was null or undefined when calling PostPivotTableUpdatePivotField.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pivotFieldType", this.pivotFieldType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "needReCalculate", this.needReCalculate);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.pivotField == null) ? null :   ObjectSerializer.serialize( this.pivotField,this.pivotField.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Calculate pivottable's data to cells.   
export class PostWorksheetPivotTableCalculateRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetPivotTableCalculateRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/Calculate".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Move PivotTable in the worksheet.   
export class PostWorksheetPivotTableMoveRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// Row index.  
    public row: number;
    /// Column index.  
    public column: number;
    /// The dest cell name.  
    public destCellName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetPivotTableMoveRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/Move".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "row", this.row);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "column", this.column);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destCellName", this.destCellName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete PivotTables in the worksheet.   
export class DeleteWorksheetPivotTablesRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetPivotTablesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pivottables".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete PivotTable by index in the worksheet.   
export class DeleteWorksheetPivotTableRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetPivotTableRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete a pivot field in the PivotTable.   
export class DeletePivotTableFieldRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// The fields area type.  
    public pivotFieldType: string;
    /// PivotTableFieldRequest PivotTable field request.  
    public pivotTableFieldRequest: PivotTableFieldRequest;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeletePivotTableFieldRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotField".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        /// The fields area type. 
        // verify required parameter 'pivotFieldType' is not null or undefined
        if (this.pivotFieldType === null || this.pivotFieldType === undefined) {
            throw new Error('Required parameter "pivotFieldType" was null or undefined when calling DeletePivotTableField.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pivotFieldType", this.pivotFieldType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.pivotTableFieldRequest == null) ? null :   ObjectSerializer.serialize( this.pivotTableFieldRequest,this.pivotTableFieldRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete all pivot filters in the PivotTable.   
export class DeleteWorksheetPivotTableFiltersRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The PivotTable index.  
    public pivotTableIndex: number;
    /// Whether the specific PivotTable calculate(true/false).  
    public needReCalculate: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetPivotTableFiltersRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotFilters".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "needReCalculate", this.needReCalculate);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete a pivot filter in the PivotTable.   
export class DeleteWorksheetPivotTableFilterRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Gets the PivotTable report by index.  
    public pivotTableIndex: number;
    /// Gets the PivotField Object at the specific index.  
    public fieldIndex: number;
    /// Whether the specific PivotTable calculate(true/false).  
    public needReCalculate: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetPivotTableFilterRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pivottables/{pivotTableIndex}/PivotFilters/{fieldIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "pivotTableIndex" + "}", String(this.pivotTableIndex)).replace("{" + "fieldIndex" + "}", String(this.fieldIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "needReCalculate", this.needReCalculate);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve descriptions of Excel file properties.   
export class GetDocumentPropertiesRequest  {
    /// The workbook name.  
    public name: string;
    /// Excel property type.  
    public type: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetDocumentPropertiesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/documentproperties".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "type", this.type);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Set or add an Excel property.   
export class PutDocumentPropertyRequest  {
    /// The workbook name.  
    public name: string;
    /// Get or set the value of the property.  
    public property: CellsDocumentProperty;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutDocumentPropertyRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/documentproperties".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.property == null) ? null :   ObjectSerializer.serialize( this.property,this.property.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get Excel property by name.   
export class GetDocumentPropertyRequest  {
    /// The workbook name.  
    public name: string;
    /// The property name.  
    public propertyName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetDocumentPropertyRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/documentproperties/{propertyName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "propertyName" + "}", String(this.propertyName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete an Excel property.   
export class DeleteDocumentPropertyRequest  {
    /// The workbook name.  
    public name: string;
    /// The property name.  
    public propertyName: string;
      
    public type: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteDocumentPropertyRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/documentproperties/{propertyName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "propertyName" + "}", String(this.propertyName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "type", this.type);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete all custom document properties and reset built-in ones.   
export class DeleteDocumentPropertiesRequest  {
    /// The workbook name.  
    public name: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteDocumentPropertiesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/documentproperties".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Excel file digital signature.   
export class PostDigitalSignatureRequest  {
    /// The file name.  
    public name: string;
    /// The digital signature file path should include both the folder and the file name, along with the extension.  
    public digitalsignaturefile: string;
    /// The password needed to open an Excel file.  
    public password: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostDigitalSignatureRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/digitalsignature".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        /// The digital signature file path should include both the folder and the file name, along with the extension. 
        // verify required parameter 'digitalsignaturefile' is not null or undefined
        if (this.digitalsignaturefile === null || this.digitalsignaturefile === undefined) {
            throw new Error('Required parameter "digitalsignaturefile" was null or undefined when calling PostDigitalSignature.');
        }
        /// The password needed to open an Excel file. 
        // verify required parameter 'password' is not null or undefined
        if (this.password === null || this.password === undefined) {
            throw new Error('Required parameter "password" was null or undefined when calling PostDigitalSignature.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "digitalsignaturefile", this.digitalsignaturefile);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Excel Encryption.   
export class PostEncryptWorkbookRequest  {
    /// The file name.  
    public name: string;
    /// WorkbookEncryptionRequestEncryption parameters.  
    public encryption: WorkbookEncryptionRequest;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostEncryptWorkbookRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/encryption".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.encryption == null) ? null :   ObjectSerializer.serialize( this.encryption,this.encryption.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Excel files decryption.   
export class DeleteDecryptWorkbookRequest  {
    /// The file name.  
    public name: string;
    /// WorkbookEncryptionRequestEncryption parameters.  
    public encryption: WorkbookEncryptionRequest;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteDecryptWorkbookRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/encryption".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.encryption == null) ? null :   ObjectSerializer.serialize( this.encryption,this.encryption.constructor.name);
        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Excel protection.   
export class PostProtectWorkbookRequest  {
    /// The file name.  
    public name: string;
    /// The protection settings.  
    public protectWorkbookRequest: ProtectWorkbookRequest;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostProtectWorkbookRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/protection".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.protectWorkbookRequest == null) ? null :   ObjectSerializer.serialize( this.protectWorkbookRequest,this.protectWorkbookRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Excel unprotection.   
export class DeleteUnProtectWorkbookRequest  {
    /// The file name.  
    public name: string;
    /// Protection settings, only password can be specified.  
    public password: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteUnProtectWorkbookRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/protection".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        /// Protection settings, only password can be specified. 
        // verify required parameter 'password' is not null or undefined
        if (this.password === null || this.password === undefined) {
            throw new Error('Required parameter "password" was null or undefined when calling DeleteUnProtectWorkbook.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Excel file write protection.   
export class PutDocumentProtectFromChangesRequest  {
    /// The file name.  
    public name: string;
    /// The password needed to open an Excel file.  
    public password: PasswordRequest;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutDocumentProtectFromChangesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/writeProtection".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.password == null) ? null :   ObjectSerializer.serialize( this.password,this.password.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Excel file cancel write protection.   
export class DeleteDocumentUnProtectFromChangesRequest  {
    /// The file name.  
    public name: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteDocumentUnProtectFromChangesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/writeProtection".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Unlock Excel files.   
export class PostUnlockRequest  {
    /// File to upload  
    public file: any;
    /// The password needed to open an Excel file.  
    public password: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUnlockRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/unlock";
        const queryParameters: any = {};
        const formParams: any = {};
        /// The password needed to open an Excel file. 
        // verify required parameter 'password' is not null or undefined
        if (this.password === null || this.password === undefined) {
            throw new Error('Required parameter "password" was null or undefined when calling PostUnlock.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Lock Excel files.   
export class PostLockRequest  {
    /// File to upload  
    public file: any;
    /// The password needed to open an Excel file.  
    public password: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostLockRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/lock";
        const queryParameters: any = {};
        const formParams: any = {};
        /// The password needed to open an Excel file. 
        // verify required parameter 'password' is not null or undefined
        if (this.password === null || this.password === undefined) {
            throw new Error('Required parameter "password" was null or undefined when calling PostLock.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Excel files encryption.   
export class PostProtectRequest  {
    /// File to upload  
    public file: any;
      
    public protectWorkbookRequest: ProtectWorkbookRequest;
    /// The password needed to open an Excel file.  
    public password: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostProtectRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/protect";
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        const bodyParameter = (this.protectWorkbookRequest == null) ? null :  JSON.stringify(this.protectWorkbookRequest);
        formParams["protectWorkbookRequest"] = bodyParameter;    
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Copy content from the source range to the destination range in the worksheet.   
export class PostWorksheetCellsRangesCopyRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// RangeCopyRequestcopydata,copystyle,copyto,copyvalue  
    public rangeOperate: RangeCopyRequest;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellsRangesCopyRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/ranges/copy".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.rangeOperate == null) ? null :   ObjectSerializer.serialize( this.rangeOperate,this.rangeOperate.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Merge a range of cells into a single cell.   
export class PostWorksheetCellsRangeMergeRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Rangerange description.  
    public range: Range;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellsRangeMergeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/ranges/merge".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.range == null) ? null :   ObjectSerializer.serialize( this.range,this.range.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Unmerge merged cells within this range.   
export class PostWorksheetCellsRangeUnMergeRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Range range description.  
    public range: Range;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellsRangeUnMergeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/ranges/unmerge".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.range == null) ? null :   ObjectSerializer.serialize( this.range,this.range.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Set the style for the specified range.   
export class PostWorksheetCellsRangeStyleRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// RangeSetStyleRequest Range Set Style Request   
    public rangeOperate: RangeSetStyleRequest;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellsRangeStyleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/ranges/style".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.rangeOperate == null) ? null :   ObjectSerializer.serialize( this.rangeOperate,this.rangeOperate.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve the values of cells within the specified range.   
export class GetWorksheetCellsRangeValueRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The range name.  
    public namerange: string;
    /// Gets the index of the first row of the range.  
    public firstRow: number;
    /// Gets the index of the first columnn of the range.  
    public firstColumn: number;
    /// Gets the count of rows in the range.  
    public rowCount: number;
    /// Gets the count of columns in the range.  
    public columnCount: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetCellsRangeValueRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/ranges/value".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "namerange", this.namerange);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "firstRow", this.firstRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "firstColumn", this.firstColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "rowCount", this.rowCount);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "columnCount", this.columnCount);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Assign a value to the range; if necessary, the value will be converted to another data type, and the cell's number format will be reset.   
export class PostWorksheetCellsRangeValueRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The range in worksheet.   
    public range: Range;
    /// Input value.  
    public value: string;
    /// True: converted to other data type if appropriate.  
    public isConverted: boolean;
    /// True: set the number format to cell's style when converting to other data type.  
    public setStyle: boolean;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellsRangeValueRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/ranges/value".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Input value. 
        // verify required parameter 'value' is not null or undefined
        if (this.value === null || this.value === undefined) {
            throw new Error('Required parameter "value" was null or undefined when calling PostWorksheetCellsRangeValue.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "value", this.value);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isConverted", this.isConverted);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "setStyle", this.setStyle);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.range == null) ? null :   ObjectSerializer.serialize( this.range,this.range.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Move the current range to the destination range.   
export class PostWorksheetCellsRangeMoveToRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// range in worksheet   
    public range: Range;
    /// The start row of the dest range.  
    public destRow: number;
    /// The start column of the dest range.  
    public destColumn: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellsRangeMoveToRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/ranges/moveto".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The start row of the dest range. 
        // verify required parameter 'destRow' is not null or undefined
        if (this.destRow === null || this.destRow === undefined) {
            throw new Error('Required parameter "destRow" was null or undefined when calling PostWorksheetCellsRangeMoveTo.');
        }
        /// The start column of the dest range. 
        // verify required parameter 'destColumn' is not null or undefined
        if (this.destColumn === null || this.destColumn === undefined) {
            throw new Error('Required parameter "destColumn" was null or undefined when calling PostWorksheetCellsRangeMoveTo.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destRow", this.destRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "destColumn", this.destColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.range == null) ? null :   ObjectSerializer.serialize( this.range,this.range.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Perform data sorting around a range of cells.   
export class PostWorksheetCellsRangeSortRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// RangeSortRequest Range Sort Request   
    public rangeSortRequest: RangeSortRequest;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellsRangeSortRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/ranges/sort".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.rangeSortRequest == null) ? null :   ObjectSerializer.serialize( this.rangeSortRequest,this.rangeSortRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Apply an outline border around a range of cells.   
export class PostWorksheetCellsRangeOutlineBorderRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// RangeSetOutlineBorderRequest Range Set OutlineBorder Request.  
    public rangeOperate: RangeSetOutlineBorderRequest;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellsRangeOutlineBorderRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/ranges/outlineBorder".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.rangeOperate == null) ? null :   ObjectSerializer.serialize( this.rangeOperate,this.rangeOperate.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Set the column width of the specified range.   
export class PostWorksheetCellsRangeColumnWidthRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Range The range object.  
    public range: Range;
    /// Sets the column width of this range.  
    public value: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellsRangeColumnWidthRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/ranges/columnWidth".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Sets the column width of this range. 
        // verify required parameter 'value' is not null or undefined
        if (this.value === null || this.value === undefined) {
            throw new Error('Required parameter "value" was null or undefined when calling PostWorksheetCellsRangeColumnWidth.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "value", this.value);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.range == null) ? null :   ObjectSerializer.serialize( this.range,this.range.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Sets row height of range.   
export class PostWorksheetCellsRangeRowHeightRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The range object.  
    public range: Range;
    /// Sets the column height of this range.  
    public value: number;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellsRangeRowHeightRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/ranges/rowHeight".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Sets the column height of this range. 
        // verify required parameter 'value' is not null or undefined
        if (this.value === null || this.value === undefined) {
            throw new Error('Required parameter "value" was null or undefined when calling PostWorksheetCellsRangeRowHeight.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "value", this.value);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.range == null) ? null :   ObjectSerializer.serialize( this.range,this.range.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostWorksheetCellsRangeToImageRequest  {
      
    public name: string;
      
    public sheetName: string;
      
    public rangeConvertRequest: RangeConvertRequest;
      
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCellsRangeToImageRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/ranges/convertToImage".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.rangeConvertRequest == null) ? null :   ObjectSerializer.serialize( this.rangeConvertRequest,this.rangeConvertRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Insert a range of cells and shift existing cells based on the specified shift option.   
export class PutWorksheetCellsRangeRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The range object.  
    public range: string;
    /// Represent the shift options when deleting a range of cells(Down/Left/None/Right/Up).  
    public shift: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetCellsRangeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/ranges".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The range object. 
        // verify required parameter 'range' is not null or undefined
        if (this.range === null || this.range === undefined) {
            throw new Error('Required parameter "range" was null or undefined when calling PutWorksheetCellsRange.');
        }
        /// Represent the shift options when deleting a range of cells(Down/Left/None/Right/Up). 
        // verify required parameter 'shift' is not null or undefined
        if (this.shift === null || this.shift === undefined) {
            throw new Error('Required parameter "shift" was null or undefined when calling PutWorksheetCellsRange.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "shift", this.shift);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete a range of cells and shift existing cells based on the specified shift option.   
export class DeleteWorksheetCellsRangeRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The range object.  
    public range: string;
    /// Represent the shift options when deleting a range of cells(Down/Left/None/Right/Up).  
    public shift: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetCellsRangeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/ranges".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The range object. 
        // verify required parameter 'range' is not null or undefined
        if (this.range === null || this.range === undefined) {
            throw new Error('Required parameter "range" was null or undefined when calling DeleteWorksheetCellsRange.');
        }
        /// Represent the shift options when deleting a range of cells(Down/Left/None/Right/Up). 
        // verify required parameter 'shift' is not null or undefined
        if (this.shift === null || this.shift === undefined) {
            throw new Error('Required parameter "shift" was null or undefined when calling DeleteWorksheetCellsRange.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "shift", this.shift);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve descriptions of shapes in the worksheet.   
export class GetWorksheetShapesRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetShapesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/shapes".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve description of shape in the worksheet.   
export class GetWorksheetShapeRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// shape index in worksheet shapes.  
    public shapeindex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetShapeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/shapes/{shapeindex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "shapeindex" + "}", String(this.shapeindex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add a shape in the worksheet.   
export class PutWorksheetShapeRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
      
    public shapeDTO: Shape;
    /// Shape object type  
    public drawingType: string;
    /// Upper left row index.  
    public upperLeftRow: number;
    /// Upper left column index.  
    public upperLeftColumn: number;
    /// Represents the vertical offset of Spinner from its left row, in unit of pixel.  
    public top: number;
    /// Represents the horizontal offset of Spinner from its left column, in unit of pixel.  
    public left: number;
    /// Represents the height of Spinner, in unit of pixel.  
    public width: number;
    /// Represents the width of Spinner, in unit of pixel.  
    public height: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetShapeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/shapes".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "drawingType", this.drawingType);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "upperLeftRow", this.upperLeftRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "upperLeftColumn", this.upperLeftColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "top", this.top);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "left", this.left);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "width", this.width);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "height", this.height);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.shapeDTO == null) ? null :   ObjectSerializer.serialize( this.shapeDTO,this.shapeDTO.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete all shapes in the worksheet.   
export class DeleteWorksheetShapesRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetShapesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/shapes".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete a shape in the worksheet.   
export class DeleteWorksheetShapeRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// shape index in worksheet shapes.  
    public shapeindex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetShapeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/shapes/{shapeindex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "shapeindex" + "}", String(this.shapeindex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update a shape in the worksheet.   
export class PostWorksheetShapeRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// shape index in worksheet shapes.  
    public shapeindex: number;
    /// The shape description.  
    public dto: Shape;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetShapeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/shapes/{shapeindex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "shapeindex" + "}", String(this.shapeindex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.dto == null) ? null :   ObjectSerializer.serialize( this.dto,this.dto.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Group shapes in the worksheet.   
export class PostWorksheetGroupShapeRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Shape index array.  
    public listShape: Array<number>;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetGroupShapeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/shapes/group".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.listShape == null) ? null :   ObjectSerializer.serialize( this.listShape,this.listShape.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Ungroup shapes in the worksheet.   
export class PostWorksheetUngroupShapeRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
      
    public shapeindex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetUngroupShapeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/shapes/{shapeindex}/ungroup".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "shapeindex" + "}", String(this.shapeindex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve descriptions of sparkline groups in the worksheet.   
export class GetWorksheetSparklineGroupsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetSparklineGroupsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/sparklineGroups".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve description of a sparkline group in the worksheet.   
export class GetWorksheetSparklineGroupRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The zero based index of the element.  
    public sparklineIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetSparklineGroupRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/sparklineGroups/{sparklineIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "sparklineIndex" + "}", String(this.sparklineIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete sparkline groups in the worksheet.   
export class DeleteWorksheetSparklineGroupsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetSparklineGroupsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/sparklineGroups".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete a sparkline group in the worksheet.   
export class DeleteWorksheetSparklineGroupRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The zero based index of the element.  
    public sparklineIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetSparklineGroupRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/sparklineGroups/{sparklineIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "sparklineIndex" + "}", String(this.sparklineIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add a sparkline group in the worksheet.   
export class PutWorksheetSparklineGroupRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the sparkline types(Line/Column/Stacked).  
    public type: string;
    /// Specifies the data range of the sparkline group.  
    public dataRange: string;
    /// Specifies whether to plot the sparklines from the data range by row or by column.  
    public isVertical: boolean;
    /// Specifies where the sparklines to be placed.  
    public locationRange: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetSparklineGroupRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/sparklineGroups".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Represents the sparkline types(Line/Column/Stacked). 
        // verify required parameter 'type' is not null or undefined
        if (this.type === null || this.type === undefined) {
            throw new Error('Required parameter "type" was null or undefined when calling PutWorksheetSparklineGroup.');
        }
        /// Specifies the data range of the sparkline group. 
        // verify required parameter 'dataRange' is not null or undefined
        if (this.dataRange === null || this.dataRange === undefined) {
            throw new Error('Required parameter "dataRange" was null or undefined when calling PutWorksheetSparklineGroup.');
        }
        /// Specifies whether to plot the sparklines from the data range by row or by column. 
        // verify required parameter 'isVertical' is not null or undefined
        if (this.isVertical === null || this.isVertical === undefined) {
            throw new Error('Required parameter "isVertical" was null or undefined when calling PutWorksheetSparklineGroup.');
        }
        /// Specifies where the sparklines to be placed. 
        // verify required parameter 'locationRange' is not null or undefined
        if (this.locationRange === null || this.locationRange === undefined) {
            throw new Error('Required parameter "locationRange" was null or undefined when calling PutWorksheetSparklineGroup.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "type", this.type);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "dataRange", this.dataRange);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isVertical", this.isVertical);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "locationRange", this.locationRange);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update a sparkline group in the worksheet.   
export class PostWorksheetSparklineGroupRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The zero based index of the element.  
    public sparklineGroupIndex: number;
    /// Spark line group description.  
    public sparklineGroup: SparklineGroup;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetSparklineGroupRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/sparklineGroups/{sparklineGroupIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "sparklineGroupIndex" + "}", String(this.sparklineGroupIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.sparklineGroup == null) ? null :   ObjectSerializer.serialize( this.sparklineGroup,this.sparklineGroup.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostCharacterCountRequest  {
      
    public characterCountOptions: CharacterCountOptions;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostCharacterCountRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/charactercount";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.characterCountOptions == null) ? null :   ObjectSerializer.serialize( this.characterCountOptions,this.characterCountOptions.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostWordsCountRequest  {
      
    public wordsCountOptions: WordsCountOptions;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWordsCountRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/wordscount";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.wordsCountOptions == null) ? null :   ObjectSerializer.serialize( this.wordsCountOptions,this.wordsCountOptions.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostSpecifyWordsCountRequest  {
      
    public specifyWordsCountOptions: SpecifyWordsCountOptions;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostSpecifyWordsCountRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/specifywordscount";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.specifyWordsCountOptions == null) ? null :   ObjectSerializer.serialize( this.specifyWordsCountOptions,this.specifyWordsCountOptions.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Run tasks.   
export class PostRunTaskRequest  {
    /// Task Data Descrition  
    public taskData: TaskData;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostRunTaskRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/task/runtask";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.taskData == null) ? null :   ObjectSerializer.serialize( this.taskData,this.taskData.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Adds text content to a workbook at specified positions within cells based on provided options using ASP.NET Core Web API.   
export class PostAddTextContentRequest  {
      
    public addTextOptions: AddTextOptions;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostAddTextContentRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/addtext";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.addTextOptions == null) ? null :   ObjectSerializer.serialize( this.addTextOptions,this.addTextOptions.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostTrimContentRequest  {
      
    public trimContentOptions: TrimContentOptions;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostTrimContentRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/trimcontent";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.trimContentOptions == null) ? null :   ObjectSerializer.serialize( this.trimContentOptions,this.trimContentOptions.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostUpdateWordCaseRequest  {
      
    public wordCaseOptions: WordCaseOptions;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUpdateWordCaseRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/updatewordcase";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.wordCaseOptions == null) ? null :   ObjectSerializer.serialize( this.wordCaseOptions,this.wordCaseOptions.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostRemoveCharactersRequest  {
      
    public removeCharactersOptions: RemoveCharactersOptions;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostRemoveCharactersRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/removecharacters";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.removeCharactersOptions == null) ? null :   ObjectSerializer.serialize( this.removeCharactersOptions,this.removeCharactersOptions.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostConvertTextRequest  {
      
    public convertTextOptions: ConvertTextOptions;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostConvertTextRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/converttext";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.convertTextOptions == null) ? null :   ObjectSerializer.serialize( this.convertTextOptions,this.convertTextOptions.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostRemoveDuplicatesRequest  {
      
    public removeDuplicatesOptions: RemoveDuplicatesOptions;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostRemoveDuplicatesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/removeduplicates";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.removeDuplicatesOptions == null) ? null :   ObjectSerializer.serialize( this.removeDuplicatesOptions,this.removeDuplicatesOptions.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostExtractTextRequest  {
      
    public extractTextOptions: ExtractTextOptions;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostExtractTextRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/extracttext";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.extractTextOptions == null) ? null :   ObjectSerializer.serialize( this.extractTextOptions,this.extractTextOptions.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
   
export class PostSplitTextRequest  {
      
    public splitTextOptions: SplitTextOptions;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostSplitTextRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/splittext";
        const queryParameters: any = {};
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.splitTextOptions == null) ? null :   ObjectSerializer.serialize( this.splitTextOptions,this.splitTextOptions.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve the description of the default style for the workbook .   
export class GetWorkbookDefaultStyleRequest  {
    /// The file name.  
    public name: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorkbookDefaultStyleRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/defaultstyle".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve text items in the workbook.   
export class GetWorkbookTextItemsRequest  {
    /// The file name.  
    public name: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorkbookTextItemsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/textItems".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve named ranges in the workbook.   
export class GetWorkbookNamesRequest  {
    /// The file name.  
    public name: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorkbookNamesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/names".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Define a new name in the workbook.   
export class PutWorkbookNameRequest  {
    /// The file name.  
    public name: string;
    /// Name  
    public newName: Name;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorkbookNameRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/names".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.newName == null) ? null :   ObjectSerializer.serialize( this.newName,this.newName.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve description of a named range in the workbook.   
export class GetWorkbookNameRequest  {
    /// The file name.  
    public name: string;
    /// The name.  
    public nameName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorkbookNameRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/names/{nameName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "nameName" + "}", String(this.nameName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update a named range in the workbook.   
export class PostWorkbookNameRequest  {
    /// The file name.  
    public name: string;
    /// the Aspose.Cells.Name element name.  
    public nameName: string;
    /// Namenew name.  
    public newName: Name;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookNameRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/names/{nameName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "nameName" + "}", String(this.nameName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.newName == null) ? null :   ObjectSerializer.serialize( this.newName,this.newName.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve the value of a named range in the workbook.   
export class GetWorkbookNameValueRequest  {
    /// The file name.  
    public name: string;
    /// the Aspose.Cells.Name element name.  
    public nameName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorkbookNameValueRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/names/{nameName}/value".replace("{" + "name" + "}", String(this.name)).replace("{" + "nameName" + "}", String(this.nameName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete all named ranges in the workbook.   
export class DeleteWorkbookNamesRequest  {
    /// The file name.  
    public name: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorkbookNamesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/names".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete a named range in the workbook.   
export class DeleteWorkbookNameRequest  {
    /// The file name.  
    public name: string;
    /// the Aspose.Cells.Name element name.  
    public nameName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorkbookNameRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/names/{nameName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "nameName" + "}", String(this.nameName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Merge a workbook into the existing workbook.   
export class PostWorkbooksMergeRequest  {
    /// The file name.  
    public name: string;
    /// The workbook to merge with.  
    public mergeWith: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// Storage name.  
    public mergedStorageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbooksMergeRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/merge".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        /// The workbook to merge with. 
        // verify required parameter 'mergeWith' is not null or undefined
        if (this.mergeWith === null || this.mergeWith === undefined) {
            throw new Error('Required parameter "mergeWith" was null or undefined when calling PostWorkbooksMerge.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "mergeWith", this.mergeWith);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "mergedStorageName", this.mergedStorageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Search for text in the workbook.   
export class PostWorkbooksTextSearchRequest  {
    /// The file name.  
    public name: string;
    /// Text sample.  
    public text: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbooksTextSearchRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/findText".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        /// Text sample. 
        // verify required parameter 'text' is not null or undefined
        if (this.text === null || this.text === undefined) {
            throw new Error('Required parameter "text" was null or undefined when calling PostWorkbooksTextSearch.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "text", this.text);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Replace text in the workbook.   
export class PostWorkbookTextReplaceRequest  {
    /// The file name.  
    public name: string;
    /// The old value.  
    public oldValue: string;
    /// The new value.  
    public newValue: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookTextReplaceRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/replaceText".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        /// The old value. 
        // verify required parameter 'oldValue' is not null or undefined
        if (this.oldValue === null || this.oldValue === undefined) {
            throw new Error('Required parameter "oldValue" was null or undefined when calling PostWorkbookTextReplace.');
        }
        /// The new value. 
        // verify required parameter 'newValue' is not null or undefined
        if (this.newValue === null || this.newValue === undefined) {
            throw new Error('Required parameter "newValue" was null or undefined when calling PostWorkbookTextReplace.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "oldValue", this.oldValue);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "newValue", this.newValue);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Smart marker processing.   
export class PostWorkbookGetSmartMarkerResultRequest  {
    /// The file name.  
    public name: string;
    /// The xml file full path, if empty the data is read from request body.  
    public xmlFile: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The path to save result  
    public outPath: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// The storage name where the result file is situated.  
    public outStorageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookGetSmartMarkerResultRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/smartmarker".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "xmlFile", this.xmlFile);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outPath", this.outPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outStorageName", this.outStorageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Create a new workbook using different methods.   
export class PutWorkbookCreateRequest  {
    /// The new document name.  
    public name: string;
    /// The template file, if the data not provided default workbook is created.  
    public templateFile: string;
    /// Smart marker data file, if the data not provided the request content is checked for the data.  
    public dataFile: string;
    /// Specifies whether to write over targer file.  
    public isWriteOver: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
      
    public checkExcelRestriction: boolean;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorkbookCreateRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "templateFile", this.templateFile);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "dataFile", this.dataFile);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isWriteOver", this.isWriteOver);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "checkExcelRestriction", this.checkExcelRestriction);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Split the workbook with a specific format.   
export class PostWorkbookSplitRequest  {
    /// The file name.  
    public name: string;
    /// Split format.  
    public format: string;
      
    public outFolder: string;
    /// Start worksheet index.  
    public from: number;
    /// End worksheet index.  
    public to: number;
    /// Image horizontal resolution.  
    public horizontalResolution: number;
    /// Image vertical resolution.  
    public verticalResolution: number;
    /// rule name : sheetname  newguid   
    public splitNameRule: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
      
    public outStorageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookSplitRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/split".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outFolder", this.outFolder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "from", this.from);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "to", this.to);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "horizontalResolution", this.horizontalResolution);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "verticalResolution", this.verticalResolution);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "splitNameRule", this.splitNameRule);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "outStorageName", this.outStorageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Calculate all formulas in the workbook.   
export class PostWorkbookCalculateFormulaRequest  {
    /// The file name.  
    public name: string;
    /// CalculationOptions Calculation Options.  
    public options: CalculationOptions;
    /// ignore Error.  
    public ignoreError: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookCalculateFormulaRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/calculateformula".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "ignoreError", this.ignoreError);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.options == null) ? null :   ObjectSerializer.serialize( this.options,this.options.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Autofit rows in the workbook.   
export class PostAutofitWorkbookRowsRequest  {
    /// The file name.  
    public name: string;
    /// Start row.  
    public startRow: number;
    /// End row.  
    public endRow: number;
    /// Only auto.  
    public onlyAuto: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
      
    public firstColumn: number;
      
    public lastColumn: number;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostAutofitWorkbookRowsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/autofitrows".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startRow", this.startRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endRow", this.endRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "onlyAuto", this.onlyAuto);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "firstColumn", this.firstColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "lastColumn", this.lastColumn);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Autofit columns in the workbook.   
export class PostAutofitWorkbookColumnsRequest  {
      
    public name: string;
    /// The start column index.  
    public startColumn: number;
    /// The end column index.  
    public endColumn: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostAutofitWorkbookColumnsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/autofitcolumns".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startColumn", this.startColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endColumn", this.endColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve descriptions of workbook settings.   
export class GetWorkbookSettingsRequest  {
    /// The file name.  
    public name: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorkbookSettingsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/settings".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update setting in the workbook.   
export class PostWorkbookSettingsRequest  {
    /// The file name.  
    public name: string;
    /// Workbook Setting description.  
    public settings: WorkbookSettings;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorkbookSettingsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/settings".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.settings == null) ? null :   ObjectSerializer.serialize( this.settings,this.settings.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Set background in the workbook.   
export class PutWorkbookBackgroundRequest  {
    /// The file name.  
    public name: string;
    /// The picture full path.  
    public picPath: string;
      
    public imageAdaptOption: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// File to upload  
    public file: any;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorkbookBackgroundRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/background".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "picPath", this.picPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "imageAdaptOption", this.imageAdaptOption);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Delete background in the workbook.   
export class DeleteWorkbookBackgroundRequest  {
    /// The file name.  
    public name: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorkbookBackgroundRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/background".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Set water marker in the workbook.   
export class PutWorkbookWaterMarkerRequest  {
    /// The file name.  
    public name: string;
    /// Text water marker request  
    public textWaterMarkerRequest: TextWaterMarkerRequest;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorkbookWaterMarkerRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/watermarker".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.textWaterMarkerRequest == null) ? null :   ObjectSerializer.serialize( this.textWaterMarkerRequest,this.textWaterMarkerRequest.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get page count in the workbook.   
export class GetPageCountRequest  {
    /// The file name.  
    public name: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetPageCountRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/pagecount".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get all style in the workbook.   
export class GetAllStylesRequest  {
      
    public name: string;
      
    public folder: string;
      
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetAllStylesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/allstyles".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve the description of worksheets from a workbook.   
export class GetWorksheetsRequest  {
    /// The file name.  
    public name: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve the worksheet in a specified format from the workbook.   
export class GetWorksheetWithFormatRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Export format(CSV/XLS/HTML/MHTML/ODS/PDF/XML/TXT/TIFF/XLSB/XLSM/XLSX/XLTM/XLTX/XPS/PNG/JPG/JPEG/GIF/EMF/BMP/MD[Markdown]/Numbers).  
    public format: string;
    /// Image vertical resolution.  
    public verticalResolution: number;
    /// Image horizontal resolution.  
    public horizontalResolution: number;
    /// Represents the range to be printed.  
    public area: string;
    /// Represents the page to be printed  
    public pageIndex: number;
      
    public onePagePerSheet: boolean;
      
    public printHeadings: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetWithFormatRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "verticalResolution", this.verticalResolution);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "horizontalResolution", this.horizontalResolution);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "area", this.area);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "pageIndex", this.pageIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "onePagePerSheet", this.onePagePerSheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "printHeadings", this.printHeadings);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Change worksheet visibility in the workbook.   
export class PutChangeVisibilityWorksheetRequest  {
    /// The file name.  
    public name: string;
    /// Worksheet name.  
    public sheetName: string;
    /// New worksheet visibility value.  
    public isVisible: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutChangeVisibilityWorksheetRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/visible".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// New worksheet visibility value. 
        // verify required parameter 'isVisible' is not null or undefined
        if (this.isVisible === null || this.isVisible === undefined) {
            throw new Error('Required parameter "isVisible" was null or undefined when calling PutChangeVisibilityWorksheet.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "isVisible", this.isVisible);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Set active worksheet index in the workbook.   
export class PutActiveWorksheetRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutActiveWorksheetRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/active".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Insert a new worksheet in the workbook.   
export class PutInsertNewWorksheetRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
      
    public index: number;
    /// Specifies the worksheet type(VB/Worksheet/Chart/BIFF4Macro/InternationalMacro/Other/Dialog).  
    public sheettype: string;
      
    public newsheetname: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutInsertNewWorksheetRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/insert".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        /// The worksheet name. 
        // verify required parameter 'sheetName' is not null or undefined
        if (this.sheetName === null || this.sheetName === undefined) {
            throw new Error('Required parameter "sheetName" was null or undefined when calling PutInsertNewWorksheet.');
        }
         
        // verify required parameter 'index' is not null or undefined
        if (this.index === null || this.index === undefined) {
            throw new Error('Required parameter "index" was null or undefined when calling PutInsertNewWorksheet.');
        }
        /// Specifies the worksheet type(VB/Worksheet/Chart/BIFF4Macro/InternationalMacro/Other/Dialog). 
        // verify required parameter 'sheettype' is not null or undefined
        if (this.sheettype === null || this.sheettype === undefined) {
            throw new Error('Required parameter "sheettype" was null or undefined when calling PutInsertNewWorksheet.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sheetName", this.sheetName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "index", this.index);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sheettype", this.sheettype);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "newsheetname", this.newsheetname);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add a new worksheet in the workbook.   
export class PutAddNewWorksheetRequest  {
    /// The file name.  
    public name: string;
    /// The new sheet name.  
    public sheetName: string;
    /// The new sheet position.  
    public position: number;
    /// Specifies the worksheet type(VB/Worksheet/Chart/BIFF4Macro/InternationalMacro/Other/Dialog).  
    public sheettype: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutAddNewWorksheetRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "position", this.position);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sheettype", this.sheettype);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete a worksheet in the workbook.   
export class DeleteWorksheetRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete matched worksheets in the workbook.   
export class DeleteWorksheetsRequest  {
      
    public name: string;
      
    public matchCondition: MatchConditionRequest;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.matchCondition == null) ? null :   ObjectSerializer.serialize( this.matchCondition,this.matchCondition.constructor.name);
        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Move worksheet in the workbook.   
export class PostMoveWorksheetRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// WorksheetMovingRequest with moving parameters.  
    public moving: WorksheetMovingRequest;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostMoveWorksheetRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/position".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.moving == null) ? null :   ObjectSerializer.serialize( this.moving,this.moving.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Protect worksheet.   
export class PutProtectWorksheetRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// ProtectSheetParameter with protection settings.  
    public protectParameter: ProtectSheetParameter;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutProtectWorksheetRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/protection".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.protectParameter == null) ? null :   ObjectSerializer.serialize( this.protectParameter,this.protectParameter.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Unprotect worksheet.   
export class DeleteUnprotectWorksheetRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// WorksheetResponse with protection settings. Only password is used here.  
    public protectParameter: ProtectSheetParameter;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteUnprotectWorksheetRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/protection".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.protectParameter == null) ? null :   ObjectSerializer.serialize( this.protectParameter,this.protectParameter.constructor.name);
        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve text items in the worksheet.   
export class GetWorksheetTextItemsRequest  {
    /// Workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetTextItemsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/textItems".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve the description of comments in the worksheet.   
export class GetWorksheetCommentsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetCommentsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/comments".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve the description of comment in the worksheet.   
export class GetWorksheetCommentRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The cell name  
    public cellName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetCommentRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/comments/{cellName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellName" + "}", String(this.cellName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add cell comment in the worksheet.   
export class PutWorksheetCommentRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The cell name.  
    public cellName: string;
    /// Comment object.  
    public comment: Comment;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetCommentRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/comments/{cellName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellName" + "}", String(this.cellName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.comment == null) ? null :   ObjectSerializer.serialize( this.comment,this.comment.constructor.name);
        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update cell comment in the worksheet.   
export class PostWorksheetCommentRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The cell name.  
    public cellName: string;
    /// Comment object.  
    public comment: Comment;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCommentRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/comments/{cellName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellName" + "}", String(this.cellName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.comment == null) ? null :   ObjectSerializer.serialize( this.comment,this.comment.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete cell comment in the worksheet.   
export class DeleteWorksheetCommentRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The cell name.  
    public cellName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetCommentRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/comments/{cellName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "cellName" + "}", String(this.cellName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete all comments in the worksheet.   
export class DeleteWorksheetCommentsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetCommentsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/comments".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get worksheet merged cells.   
export class GetWorksheetMergedCellsRequest  {
    /// The file name.  
    public name: string;
    /// The workseet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetMergedCellsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/mergedCells".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve description of a merged cell by its index in the worksheet.   
export class GetWorksheetMergedCellRequest  {
    /// The file name.  
    public name: string;
    /// Worksheet name.  
    public sheetName: string;
    /// Merged cell index.  
    public mergedCellIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetMergedCellRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/mergedCells/{mergedCellIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "mergedCellIndex" + "}", String(this.mergedCellIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Calculate formula in the worksheet.   
export class GetWorksheetCalculateFormulaRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The formula.  
    public formula: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetCalculateFormulaRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/formulaResult".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The formula. 
        // verify required parameter 'formula' is not null or undefined
        if (this.formula === null || this.formula === undefined) {
            throw new Error('Required parameter "formula" was null or undefined when calling GetWorksheetCalculateFormula.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "formula", this.formula);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Calculate formula in the worksheet.   
export class PostWorksheetCalculateFormulaRequest  {
    /// The file name.  
    public name: string;
    /// Worksheet name.  
    public sheetName: string;
    /// The formula.  
    public formula: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetCalculateFormulaRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/calculateformula".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The formula. 
        // verify required parameter 'formula' is not null or undefined
        if (this.formula === null || this.formula === undefined) {
            throw new Error('Required parameter "formula" was null or undefined when calling PostWorksheetCalculateFormula.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "formula", this.formula);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Search for text in the worksheet.   
export class PostWorksheetTextSearchRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Text to search.  
    public text: string;
    /// Original workbook folder.  
    public folder: string;
    /// Storage name.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetTextSearchRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/findText".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Text to search. 
        // verify required parameter 'text' is not null or undefined
        if (this.text === null || this.text === undefined) {
            throw new Error('Required parameter "text" was null or undefined when calling PostWorksheetTextSearch.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "text", this.text);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Replace old text with new text in the worksheet.   
export class PostWorksheetTextReplaceRequest  {
    /// The file name.  
    public name: string;
    /// Worksheet name.  
    public sheetName: string;
    /// The old text to replace.  
    public oldValue: string;
    /// The new text to replace by.  
    public newValue: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetTextReplaceRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/replaceText".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The old text to replace. 
        // verify required parameter 'oldValue' is not null or undefined
        if (this.oldValue === null || this.oldValue === undefined) {
            throw new Error('Required parameter "oldValue" was null or undefined when calling PostWorksheetTextReplace.');
        }
        /// The new text to replace by. 
        // verify required parameter 'newValue' is not null or undefined
        if (this.newValue === null || this.newValue === undefined) {
            throw new Error('Required parameter "newValue" was null or undefined when calling PostWorksheetTextReplace.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "oldValue", this.oldValue);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "newValue", this.newValue);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Sort a range in the worksheet.   
export class PostWorksheetRangeSortRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The area needed to sort.  
    public cellArea: string;
    /// DataSorter with sorting settings.  
    public dataSorter: DataSorter;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetRangeSortRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/sort".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The area needed to sort. 
        // verify required parameter 'cellArea' is not null or undefined
        if (this.cellArea === null || this.cellArea === undefined) {
            throw new Error('Required parameter "cellArea" was null or undefined when calling PostWorksheetRangeSort.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "cellArea", this.cellArea);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.dataSorter == null) ? null :   ObjectSerializer.serialize( this.dataSorter,this.dataSorter.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Autofit a row in the worksheet.   
export class PostAutofitWorksheetRowRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The row index.  
    public rowIndex: number;
    /// The first column index.  
    public firstColumn: number;
    /// The last column index.  
    public lastColumn: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
      
    public rowCount: number;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostAutofitWorksheetRowRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/autofitrow".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// The row index. 
        // verify required parameter 'rowIndex' is not null or undefined
        if (this.rowIndex === null || this.rowIndex === undefined) {
            throw new Error('Required parameter "rowIndex" was null or undefined when calling PostAutofitWorksheetRow.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "rowIndex", this.rowIndex);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "firstColumn", this.firstColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "lastColumn", this.lastColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "rowCount", this.rowCount);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Autofit rows in the worksheet.   
export class PostAutofitWorksheetRowsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The start row index.  
    public startRow: number;
    /// The end row index.  
    public endRow: number;
    /// Autofits all rows in this worksheet.  
    public onlyAuto: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostAutofitWorksheetRowsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/autofitrows".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startRow", this.startRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endRow", this.endRow);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "onlyAuto", this.onlyAuto);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Autofit columns in the worksheet.   
export class PostAutofitWorksheetColumnsRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The start column index.  
    public startColumn: number;
    /// The end column index.  
    public endColumn: number;
      
    public onlyAuto: boolean;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostAutofitWorksheetColumnsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/autofitcolumns".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "startColumn", this.startColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "endColumn", this.endColumn);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "onlyAuto", this.onlyAuto);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Set background image in the worksheet.   
export class PutWorksheetBackgroundRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// picture full filename.  
    public picPath: string;
      
    public imageAdaptOption: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// File to upload  
    public file: any;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetBackgroundRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/background".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        const formParams: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "picPath", this.picPath);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "imageAdaptOption", this.imageAdaptOption);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }
        if (this.file !== undefined) {
            if (typeof this.file === 'string') {
                if (fs.existsSync(this.file)) {
                    const fileName = path.basename( this.file)
                    formParams[fileName] = fs.createReadStream(this.file)
                }
            }
            else {
                for (var key in this.file){
                    formParams[key] = this.file[key];
                }
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        (requestOptions as any).formData = formParams;        
        return Promise.resolve(requestOptions);

    }

}
/// Delete background image in the worksheet.   
export class DeleteWorksheetBackgroundRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetBackgroundRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/background".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Set freeze panes in the worksheet.   
export class PutWorksheetFreezePanesRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Row index.  
    public row: number;
    /// Column index.  
    public column: number;
    /// Number of visible rows in top pane, no more than row index.  
    public freezedRows: number;
    /// Number of visible columns in left pane, no more than column index.  
    public freezedColumns: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetFreezePanesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/freezepanes".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Row index. 
        // verify required parameter 'row' is not null or undefined
        if (this.row === null || this.row === undefined) {
            throw new Error('Required parameter "row" was null or undefined when calling PutWorksheetFreezePanes.');
        }
        /// Column index. 
        // verify required parameter 'column' is not null or undefined
        if (this.column === null || this.column === undefined) {
            throw new Error('Required parameter "column" was null or undefined when calling PutWorksheetFreezePanes.');
        }
        /// Number of visible rows in top pane, no more than row index. 
        // verify required parameter 'freezedRows' is not null or undefined
        if (this.freezedRows === null || this.freezedRows === undefined) {
            throw new Error('Required parameter "freezedRows" was null or undefined when calling PutWorksheetFreezePanes.');
        }
        /// Number of visible columns in left pane, no more than column index. 
        // verify required parameter 'freezedColumns' is not null or undefined
        if (this.freezedColumns === null || this.freezedColumns === undefined) {
            throw new Error('Required parameter "freezedColumns" was null or undefined when calling PutWorksheetFreezePanes.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "row", this.row);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "column", this.column);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "freezedRows", this.freezedRows);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "freezedColumns", this.freezedColumns);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Unfreeze panes in worksheet.   
export class DeleteWorksheetFreezePanesRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Row index.  
    public row: number;
    /// Column index.  
    public column: number;
    /// Number of visible rows in top pane, no more than row index.  
    public freezedRows: number;
    /// Number of visible columns in left pane, no more than column index.  
    public freezedColumns: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetFreezePanesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/freezepanes".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Row index. 
        // verify required parameter 'row' is not null or undefined
        if (this.row === null || this.row === undefined) {
            throw new Error('Required parameter "row" was null or undefined when calling DeleteWorksheetFreezePanes.');
        }
        /// Column index. 
        // verify required parameter 'column' is not null or undefined
        if (this.column === null || this.column === undefined) {
            throw new Error('Required parameter "column" was null or undefined when calling DeleteWorksheetFreezePanes.');
        }
        /// Number of visible rows in top pane, no more than row index. 
        // verify required parameter 'freezedRows' is not null or undefined
        if (this.freezedRows === null || this.freezedRows === undefined) {
            throw new Error('Required parameter "freezedRows" was null or undefined when calling DeleteWorksheetFreezePanes.');
        }
        /// Number of visible columns in left pane, no more than column index. 
        // verify required parameter 'freezedColumns' is not null or undefined
        if (this.freezedColumns === null || this.freezedColumns === undefined) {
            throw new Error('Required parameter "freezedColumns" was null or undefined when calling DeleteWorksheetFreezePanes.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "row", this.row);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "column", this.column);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "freezedRows", this.freezedRows);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "freezedColumns", this.freezedColumns);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Copy contents and formats from another worksheet.   
export class PostCopyWorksheetRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Source worksheet.  
    public sourceSheet: string;
    /// Represents the copy options.  
    public options: CopyOptions;
    /// source Workbook.  
    public sourceWorkbook: string;
    /// Original workbook folder.  
    public sourceFolder: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostCopyWorksheetRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/copy".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Source worksheet. 
        // verify required parameter 'sourceSheet' is not null or undefined
        if (this.sourceSheet === null || this.sourceSheet === undefined) {
            throw new Error('Required parameter "sourceSheet" was null or undefined when calling PostCopyWorksheet.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sourceSheet", this.sourceSheet);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sourceWorkbook", this.sourceWorkbook);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "sourceFolder", this.sourceFolder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.options == null) ? null :   ObjectSerializer.serialize( this.options,this.options.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Rename worksheet in the workbook.   
export class PostRenameWorksheetRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// New worksheet name.  
    public newname: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostRenameWorksheetRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/rename".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// New worksheet name. 
        // verify required parameter 'newname' is not null or undefined
        if (this.newname === null || this.newname === undefined) {
            throw new Error('Required parameter "newname" was null or undefined when calling PostRenameWorksheet.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "newname", this.newname);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update worksheet properties in the workbook.   
export class PostUpdateWorksheetPropertyRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The worksheet description.  
    public sheet: Worksheet;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUpdateWorksheetPropertyRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.sheet == null) ? null :   ObjectSerializer.serialize( this.sheet,this.sheet.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve descriptions of ranges in the worksheets.   
export class GetNamedRangesRequest  {
    /// The file name.  
    public name: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetNamedRangesRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/ranges".replace("{" + "name" + "}", String(this.name));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve values in range.   
export class GetNamedRangeValueRequest  {
    /// The file name.  
    public name: string;
    /// Range name.  
    public namerange: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetNamedRangeValueRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/ranges/{namerange}/value".replace("{" + "name" + "}", String(this.name)).replace("{" + "namerange" + "}", String(this.namerange));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update the scaling percentage in the worksheet. It should be between 10 and 400.   
export class PostUpdateWorksheetZoomRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Represents the scaling factor in percentage. It should be between 10 and 400.  
    public value: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostUpdateWorksheetZoomRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/zoom".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        /// Represents the scaling factor in percentage. It should be between 10 and 400. 
        // verify required parameter 'value' is not null or undefined
        if (this.value === null || this.value === undefined) {
            throw new Error('Required parameter "value" was null or undefined when calling PostUpdateWorksheetZoom.');
        }
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "value", this.value);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Get page count in the worksheet.   
export class GetWorksheetPageCountRequest  {
    /// The file name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetPageCountRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/pagecount".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve descriptions of validations in the worksheet.   
export class GetWorksheetValidationsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetValidationsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/validations".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Retrieve a validation by its index in the worksheet.   
export class GetWorksheetValidationRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The validation index.  
    public validationIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< GetWorksheetValidationRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/validations/{validationIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "validationIndex" + "}", String(this.validationIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Add a validation at index in the worksheet.   
export class PutWorksheetValidationRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// Specified cells area  
    public range: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PutWorksheetValidationRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/validations".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "range", this.range);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Update a validation by index in the worksheet.   
export class PostWorksheetValidationRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The validation index.  
    public validationIndex: number;
    /// Validation description.  
    public validation: Validation;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< PostWorksheetValidationRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/validations/{validationIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "validationIndex" + "}", String(this.validationIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        const bodyParameter = (this.validation == null) ? null :   ObjectSerializer.serialize( this.validation,this.validation.constructor.name);
        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
            body:bodyParameter,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete a validation by index in worksheet.   
export class DeleteWorksheetValidationRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The validation index.  
    public validationIndex: number;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetValidationRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/validations/{validationIndex}".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName)).replace("{" + "validationIndex" + "}", String(this.validationIndex));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
/// Delete all validations in the worksheet.   
export class DeleteWorksheetValidationsRequest  {
    /// The workbook name.  
    public name: string;
    /// The worksheet name.  
    public sheetName: string;
    /// The folder where the file is situated.  
    public folder: string;
    /// The storage name where the file is situated.  
    public storageName: string;
    /// extend query parameter
    public extendQueryParameterMap: any;

    public constructor(init?: Partial< DeleteWorksheetValidationsRequest >) {  
        Object.assign(this, init);
    } 

    public async createRequestOptions(configuration: Configuration) : Promise<request.Options> {

        let localVarPath = configuration.getApiBaseUrl() + "v3.0/cells/{name}/worksheets/{sheetName}/validations".replace("{" + "name" + "}", String(this.name)).replace("{" + "sheetName" + "}", String(this.sheetName));
        const queryParameters: any = {};
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder);
        localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName);
        if(this.extendQueryParameterMap !== undefined){
            for (var key in this.extendQueryParameterMap){
                localVarPath = addQueryParameterToUrl(localVarPath, queryParameters, key, this.extendQueryParameterMap[key]);
            }
        }


        // const bodyParameter = null;

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            uri: localVarPath,
            json: true,
        };

        return Promise.resolve(requestOptions);

    }

}
